1 00:00:00.000 --> 00:01:17.917
[MÜZİK ÇALIYOR]

2 00:01:17,917 --> 00:01:19,000
DAVID J. MALAN: Pekala.

3 00:01:19,000 --> 00:01:20.560
Yani bu CS50.

4 00:01:20.560 --> 00:01:24,670
Ve bu, yeni bir dil öğrendiğiniz 1. hafta.

5 00:01:24,670 --> 00:01:27,550
teknik olarak geçen hafta söylediğimiz
bir şey, en azından hiç yapmamış olsaydınız

6 00:01:27,550 --> 00:01:30,850
daha önce Scratch olarak bilinen bu
grafik dil ile oynandı.

7 00:01:30,850 --> 00:01:32,530 bir
programlama diliydi.

8 00:01:32,530 --> 00:01:34,660
Ama bugün söz verdiğimiz
gibi bir şeye geçiyoruz.

9 00:01:34,660 --> 00:01:37,120
biraz daha geleneksel, biraz daha
metin tabanlı,
10
00:01:37,120 --> 00:01:39,700
yapboz parçası veya blok tabanlı
değil, C olarak bilinir.

11 00:01:39,700 --> 00:01:40,970
Bu daha eski bir dildir.
12
00:01:40.970 --> 00:01:42,178
Onlarca yıldır var.
13

Machine Translated by Google
00:01:42,178 --> 00:01:45,700

Ama günümüzün daha modern
dillerinin çoğunun altında yatan bir dildir,
14
00:01:45,700 --> 00:01:48,460
aralarında şöyle bir şey var
Python biz de
15
00:01:48,460 --> 00:01:50,020
birkaç hafta içinde gelir.
16
00:01:50,020 --> 00:01:52,120
Nitekim, dönem
sonunda hedef
17
00:01:52,120 --> 00:01:53,860
Scratch'i öğrenmediğinizi
hissetmeniz içindir,
18
00:01:53,860 --> 00:01:56,110 C'yi,
hatta Python'u bile öğrenmedin,
bu konuda,
19
00:01:56,110 --> 00:01:58,570 ama
temelde programlamayı öğrendiniz.

20
00:01:58,570 --> 00:02:01,000
Ne yazık ki, programlamayı
öğrendiğinizde
21
00:02:01,000 --> 00:02:04,880
bunun gibi daha geleneksel bir dille,
dikkat dağıtıcı çok fazla şey var.
22
00:02:04,880 --> 00:02:08,290
Geçen hafta tüm sözdizimini, tüm
garip noktalama işaretlerini tanımladım.
23
00:02:08,290 --> 00:02:11,080
burada gördüğünüz, kare sembolü
gibi, bu açılı ayraçlar,
24
00:02:11,080 --> 00:02:13,960

Machine Translated by Google
parantezler, küme parantezleri,
ters eğik çizgi n ve daha fazlası.

25
00:02:13,960 --> 00:02:17,990
Pekala, bugün tüm bu küçük ayrıntıların ne
olduğunu açıklamayacağız.
26
00:02:17,990 --> 00:02:18,490
kastetmek.

27
00:02:18,490 --> 00:02:22,660
Ancak önümüzdeki haftaya kadar
bu artık Yunan atasözüne benzemeyecek mi?
28
00:02:22,660 --> 00:02:26,590 sizin
için, muhtemelen hiç görmediğiniz veya
yazmadığınız bir dil
29
00:02:26,590 --> 00:02:27,520 önce.

30
00:02:27,520 --> 00:02:31,400 Ancak
bunu yapmak için geçen haftaki
konuların aynısını keşfedeceğiz.
31
00:02:31,400 --> 00:02:34,420
Yani şunu hatırlayın, Scratch
aracılığıyla-- ve muhtemelen problem seti 1-32
00:02:34,420 --> 00:02:37,780
Eylemler veya fiiller olan işlevler
denen şeylere bir göz attık.
33
00:02:37,780 --> 00:02:40,510 Ve
işlevlerle ilgili girdiler gibi argümanlar
vardı.
34
00:02:40,510 --> 00:02:43.960 Ve
bazı fonksiyonlarla ilgili çıktılar gibi
değerler döndürüldü.
35
00:02:43,960 --> 00:02:47,350
Sonra biraz koşullu ifadeler, yoldaki çatallar
hakkında konuştuk, tabiri caizse,

Machine Translated by Google
36
00:02:47,350 --> 00:02:50,740
Yalnızca evet/hayır soruları veya
doğru/yanlış olan Boole ifadeleri
37
00:02:50,740 --> 00:02:54,340
sorular, tekrar tekrar yapmanızı
sağlayan döngüler, değişkenler,
38
00:02:54,340 --> 00:02:57,190
matematikte olduğu gibi, değerleri
geçici olarak saklamanıza izin verir,

39
00:02:57,190 --> 00:02:58,870 ve
hatta diğer konular hala.
40
00:02:58,870 --> 00:03:02,620
Yani, problem seti 0'ın hemen
ardından ve geçen hafta rahatsanız,

41 00:03:02,620 --> 00:03:05,690
tüm bu konuların bizimle
kalacağının farkında olun.
42
00:03:05,690 --> 00:03:09,430
Yani gerçekten, bugün sadece nasıl olduğuna
dair daha fazla zihinsel bir model elde etmekle ilgili.

43
00:03:09,430 --> 00:03:14,110 bu
fikirleri muhtemelen çok şifreli
yeni bir sözdizimine çevirirsiniz-44
00:03:14,110 --> 00:03:16,898
açıkçası yeni bir sözdizimi, bu
aslında daha fazla
45
00:03:16,898 --> 00:03:18,940 bazı
açılardan kendi insan dilinizden
daha basit,
46
00:03:18,940 --> 00:03:22,622
ister İngilizce ister başka bir şey, çünkü çok
daha az kelime var.

Machine Translated by Google
47

00:03:22,622 --> 00:03:24,580
Aslında yapabileceğiniz
çok daha az sözdizimi var
48
00:03:24,580 --> 00:03:26,650,
diyelim ki, tipik bir insan diline sahiptir.
49
00:03:26,650 --> 00:03:30,800
Ancak bu bilgisayar dillerinde daha kesin
olmanız gerekir.
50
00:03:30,800 --> 00:03:33,050
böylece en sonunda, en doğru
şekilde,

51 00:03:33.050 --> 00:03:37,240
ve sonuçta kodunuzun birkaç satırda
başarılı olduğunu görecektir
52
00:03:37,240 --> 00:03:37,820 de.

53
00:03:37,820 --> 00:03:40,990
Yani, en son ne zaman dolaştığınızı
düşünürseniz, gerçekten değil.
54
00:03:40.990 --> 00:03:43,180 ne
yaptığınızı veya yeni bir şeyle
karşılaştığınızı bilmek-55
00:03:43,180 --> 00:03:46,055 o
kadar uzun zaman önce olmayabilirdi,
Harvard Yard'a
56
00:03:46,055 --> 00:03:49,660 ilk
kez veya Old Campus veya benzeri,
Cambridge veya New Haven'da-57
00:03:49,660 --> 00:03:53,022 İlk
yıl olarak gerçekten her şeyi nasıl
yapacağınızı bilmenize gerek yoktu.
58
00:03:53,022 --> 00:03:54,730

Machine Translated by Google
Herkesin kim

olduğunu bilmene gerek yoktu.
59
00:03:54,730 --> 00:03:58,430 her
şey neredeydi, nasıl Harvard veya
Yale ya da bu konuda başka bir şey,
60
00:03:58,430 --> 00:03:58,930 çalıştı.

61
00:03:58,930 --> 00:04:02,055
Sadece önemli olan şeylere odaklanarak
günden güne iyileşiyorsun.
62
00:04:02,055 --> 00:04:03,805
Ve gerçekten anlamadığın
herhangi bir şey,
63
00:04:03,805 --> 00:04:06,160
önemli olana kadar görmezden
geldin.
64
00:04:06,160 --> 00:04:07,960 Ve
gerçekten de bugün yapacağımız
şey bu.
65
00:04:07,960 --> 00:04:09,835
Ve gerçekten, önümüzdeki
birkaç hafta boyunca,
66
00:04:09,835 --> 00:04:12,370
Başlangıçta önemli olan ayrıntılara
odaklanın
67
00:04:12,370 --> 00:04:15,542 ve
deyim yerindeyse, ayrıntılarda elimizi
sallamaya çalışın, evet, sonunda
68
00:04:15,542 --> 00:04:17,000
alacağız, ilginç olabilir.
69
00:04:17,000 --> 00:04:18,667
Ancak şimdilik bunlar dikkat dağıtıcı olabilir.

Machine Translated by Google
70

00:04:18,667 --> 00:04:21,100
Ve dikkat dağıtıcı şeyler derken, gerçekten
bu sözdiziminin bir kısmını kastediyorum.

71
00:04:21,100 --> 00:04:22,700 daha
önce bahsettiğim.
72
00:04:22,700 --> 00:04:25,870
Yani bugünün sonunda-- ve
gerçekten, problem seti 1'in sonunda,
73
00:04:25,870 --> 00:04:28,600
muhtemelen, C adlı bu dile ilk
girişiniz-74
00:04:28,600 --> 00:04:30,370 bir
kod yazmış olacaksınız.
75
00:04:30,370 --> 00:04:32,980
Ve siz kendinize soracaksınız-- biz
kendinize soracağız-76
00:04:32,980 --> 00:04:34,360 bu
kod ne kadar iyi?
77
00:04:34,360 --> 00:04:37,240
Pekala, her şeyden önce, geçen
hafta, Scratch'te olsun
78
00:04:37,240 --> 00:04:42,790 veya
telefon rehberi formu, kodun eninde
sonunda doğru olması, iyi yapılması gerekir.
79
00:04:42,790 --> 00:04:44,740
Sorunun doğru şekilde çözülmesini
istiyorsunuz.
80
00:04:44,740 --> 00:04:46,690 Yani
bir nevi söylemeye gerek yok.

81 00:04:46,690 --> 00:04:50,710
Ve bu terim boyunca size araçlar ve
teknikler sağlayacağız.

Machine Translated by Google
82
00:04:50,710 --> 00:04:53,945
böylece orada durup durmaksızın
bir girdi denemek zorunda kalmazsınız,
83
00:04:53,945 --> 00:04:56,570
çıktıyı kontrol etme, başka bir
girdiyi denemeyi, çıktıyı kontrol etme.
84
00:04:56,570 --> 00:04:58,360
Gerçek dünyada bir sürü
otomasyon aracı var--

85
00:04:58,360 --> 00:05:00,400 ve
bu sınıfta ve bunun gibi
diğerlerinde-- bu
86
00:05:00,400 --> 00:05:04,210 bu
soruyu kendi kendinize cevaplamanıza
yardımcı olacak, benim kodum
87
00:05:04,210 --> 00:05:07,100,
spesifikasyonlarımıza veya
benzerlerine göre doğru.
88
00:05:07,100 --> 00:05:09,640
Ama sonra daha fazla
zaman alacak bir şey
89
00:05:09,640 --> 00:05:13.060 ve
muhtemelen ilk hafta %100 rahat
hissetmeyeceksiniz,
90
00:05:13,060 --> 00:05:16.090 ilk
haftalar, kodunuzun ne kadar iyi
tasarlandığını gösterir.

91 00:05:16,090 --> 00:05:18,813
Konuşmak bir şeydir
İngilizce veya İngilizce yaz,
92
00:05:18,813 --> 00:05:21,230
ama bu başka bir şey-- ya da
herhangi bir dil, bu konuda.

Machine Translated by Google
93
00:05:21,230 --> 00:05:23,390 Ama
onu iyi konuşmak ya da iyi yazmak
başka bir şey.
94
00:05:23,390 --> 00:05:26,348
Ve tüm bu yılları ortaokulda, lisede
geçiriyoruz, muhtemelen,
95
00:05:26,348 --> 00:05:29,800 kağıt
ve diğer belgeleri yazma, not alma ve
bunlarla ilgili geri bildirim alma
96
00:05:29,800 --> 00:05:33.010
argümanlarınızın ne kadar iyi
formüle edildiğine, ne kadar iyi yapılandırıldığına dair
97
00:05:33.010 --> 00:05:34,219
makaleniz ve benzeriydi.
98
00:05:34,219 --> 00:05:36,170 Ve
programlamada da aynı fikir var.

99
00:05:36,170 --> 00:05:40,790 Bir
problemi doğru çözmüş olmanız
önemli değildir.
100
00:05:40,790 --> 00:05:44,815
Kodunuz tamamen görsel bir
karmaşaysa veya çılgınca uzunsa,
101
00:05:44,815 --> 00:05:46,690
başkası için gerçekten zor olacak

102
00:05:46,690 --> 00:05:50,320
kodunuzun ne yaptığını anlamak ve gerçekten
de kendinden emin olmak için
103
00:05:50,320 --> 00:05:51,400
doğruysa.
104

Machine Translated by Google
00:05:51,400 --> 00:05:55,210
Ve dürüst olmak gerekirse,
sen-- ertesi sabah, gelecek yıl,
105
00:05:55,210 --> 00:05:58,750 bu
koda bir daha baktığınızda-- hiçbir
fikriniz olmayabilir
106
00:05:58,750 --> 00:06:00,580
kendin bile ne düşünüyordun.
107
00:06:00,580 --> 00:06:04,930
Ama siz de iyi kod tasarlamaya
odaklanırsanız,
108
00:06:04,930 --> 00:06:07,840
algoritmalarınızı verimli hale
getirmek, kodunuzu güzel ve temiz hale getirmek,
109
00:06:07,840 --> 00:06:10,360 ve
hatta kodunuzun güzel
göründüğünden emin olun.
110
00:06:10,360 --> 00:06:12,080 bir
tarz meselesi olarak tanımlardık.
111
00:06:12,080 --> 00:06:15,713
Yazılı insan dünyasında, noktalama
işaretlerinin doğru yerde olması,
112
00:06:15,713 --> 00:06:18,380
büyük harf kullanımı ve benzeri-bir deneme yazma şekliniz
113
00:06:18,380 --> 00:06:20,420 ancak
kısa mesaj göndermeniz gerekmez--

114
00:06:20,420 --> 00:06:22,620
örneğin stille ilgilidir.
115
00:06:22,620 --> 00:06:24,560
Ve kodda çok iyi bir stil
olacak

Machine Translated by Google
116
00:06:24,560 --> 00:06:28,160
Oldukça kolay öğretilen ve hatırlanan
bu özelliklerden birkaçı.
117
00:06:28,160 --> 00:06:33,180
Ancak belli bir şekilde kod yazma
alışkanlığını kazanmaya başlamanız gerekiyor.
118
00:06:33,180 --> 00:06:36,140
Yani bu üç eksen, tabiri caizse,
doğruluk, tasarım ve stil,
119
00:06:36,140 --> 00:06:39,320,
kod yazarken gerçekten kapsayıcı
hedeflerdir.
120
00:06:39,320 --> 00:06:41,400
sonuçta böyle görünecek.
121
00:06:41,400 --> 00:06:43,400
Yani geçen hafta
tahmin ettiğimiz bu program
122
00:06:43,400 --> 00:06:48,063 Ya
bir Mac'te, PC'de veya başka bir
yerde çalıştırırsanız, muhtemelen?
123
00:06:48,063 --> 00:06:48,730 Ne
işe yarar?
124
00:06:48,730 --> 00:06:50,500
Evet?
125
00:06:50,500 --> 00:06:51,460
İZLEYİCİ: [DUYULMAZ].
126
00:06:51,460 --> 00:06:53,335
DAVID J. MALAN: Sadece
yazdırıyor, Merhaba dünya.
127
00:06:53,335 --> 00:06:55,510
Ve dürüst olmak gerekirse, bu nazik

Machine Translated by Google
senin yaptığın gaddarca
128
00:06:55,510 --> 00:06:59,260 bu
şifreli sözdizimi ile klavye tuşlarınıza bu
kadar çok kez basmanız gerekir.
129
00:06:59,260 --> 00:07:00,940
Merhaba dünya demek için bir program almak için.
130
00:07:00,940 --> 00:07:03,190
Yani bir spoiler-birkaç hafta sonra
131
00:07:03,190 --> 00:07:05,650 Python
gibi diğer, daha modern dilleri tanıtın,

132
00:07:05,650 --> 00:07:09,830 Aynı
mantığı kelimenin tam anlamıyla tek
bir kod satırına damıtabilirsiniz.
133
00:07:09,830 --> 00:07:11,500 Ve
sonunda oraya geliyoruz.
134
00:07:11,500 --> 00:07:14,493
Ama burada neler olduğunu
anlamakta fayda var.
135
00:07:14,493 --> 00:07:16,660 çünkü
bu oldukça şifreli bir sözdizimi olsa
da,
136
00:07:16,660 --> 00:07:19,300 Bu
haftadan sonra ve gerçekten, gelecek
haftadan sonra yapmamanız gereken hiçbir şey yok

137
00:07:19,300 --> 00:07:22,120 Şu
anda görünen bir şeyi bile anlayabilir

138
00:07:22,120 --> 00:07:23,510 bunun
gibi küçük bir şey.
139

Machine Translated by Google
00:07:23,510 --> 00:07:24,843
Peki nasıl kod yazıyorsunuz?
140
00:07:24,843 --> 00:07:27,010
Şey, bize bir sorunun cevabını
verdim.
141
00:07:27,010 --> 00:07:28,927
Merhaba dünya, ekrana nasıl
yazdırıyorsunuz?
142
00:07:28,927 --> 00:07:30,377
Peki bu kodla ne yapacağım?
143
00:07:30,377 --> 00:07:33.460
Şey, tipik olarak Microsoft ile bir şeyler
yazma alışkanlığımız var.
144
00:07:33,460 --> 00:07:35,110
Word veya Google dokümanları.
145
00:07:35,110 --> 00:07:39,230
Ve evet, Word'ü açabilirim veya
Google Dokümanlar veya Sayfalar veya benzerleri

146
00:07:39,230 --> 00:07:41,980 ve
bu karakteri tam anlamıyla
karakter olarak yazın,
147
00:07:41,980 --> 00:07:44,590
kaydedin ve bum, bir programım var.
148
00:07:44,590 --> 00:07:47,830
Ancak geçen haftaki sorun,
bilgisayarların yalnızca anlaması veya konuşmasıdır.
149
00:07:47,830 --> 00:07:50,363
tabiri caizse başka hangi dil?
150
00:07:50,363 --> 00:07:51,280
İZLEYİCİ: [DUYULMAZ].
151
00:07:51,280 --> 00:07:53,510

Machine Translated by Google
DAVID J. MALAN: Evet, yani ikili,
sıfırlar ve birler.
152
00:07:53,510 --> 00:07:55,510 Ve
bu, açıkçası, sıfırlar ve birler değil.

153
00:07:55,510 --> 00:07:58,240
Yani bir Word belgesine, Google
Doc'a, Pages dosyasına koymamın bir önemi yok,

154
00:07:58,240 --> 00:07:58,832
veya benzeri.
155
00:07:58,832 --> 00:08:01,249
Bilgisayar ben bir şekilde
anlayana kadar bunu anlamayacak.
156
00:08:01,249 --> 00:08:02,770
sıfıra ve bire çevir.
157
00:08:02,770 --> 00:08:05,320
Ve dürüst olmak gerekirse,
çaldığım o araçların hiçbiri
158
00:08:05,320 --> 00:08:07,180
programlama için gerçekten uygundur.
159
00:08:07,180 --> 00:08:07,750
Neden?
160
00:08:07,750 --> 00:08:10,210
Kalın yazı ve italik gibi özelliklerle
gelirler.
161
00:08:10,210 --> 00:08:14,080 ve
üzerinde hiçbir işlevsel etkisi
olmayan kabarık, estetik şeyler
162
00:08:14,080 --> 00:08:15,830
kodunuzla yapmaya çalışıyorsunuz.
163
00:08:15,830 --> 00:08:17,860

Machine Translated by Google
Ve yetenekleri yok, olur

164
00:08:17,860 --> 00:08:20.860, bu
kodu nihayetinde sıfırlara ve birlere
dönüştürmek için görünüyor.
165
00:08:20.860 --> 00:08:23.650
Ancak bu yeteneğe sahip
araçlar,
166
00:08:23,650 --> 00:08:27,550 Entegre
Geliştirme olarak adlandırılabilir
Ortamlar veya IDE'ler,
167
00:08:27,550 --> 00:08:29,380 veya
daha basit olarak metin düzenleyiciler.

168
00:08:29,380 --> 00:08:33,760
Bir metin düzenleyici, bir
programcının belki de her gün kullandığı bir araçtır.
169
00:08:33,760 --> 00:08:35,230 kodlarını
yazmak için.
170
00:08:35,230 --> 00:08:38,050
Ve bu basit bir program-- burada,
örneğin, çok popüler bir program
171
00:08:38,050 --> 00:08:40,742 Visual
Studio Code veya VS Code olarak adlandırılır.
172
00:08:40,742 --> 00:08:42,700
Ve burada en üstte,
görüyorsun ki ben aslında
173
00:08:42,700 --> 00:08:47,590 sınıftan
önce "hello.c" adında çok basit bir boş dosya
oluşturuldu.
174
00:08:47,590 --> 00:08:48,220 Neden?

175

Machine Translated by Google
00:08:48,220 --> 00:08:51,940

Pekala, .c konvansiyonel olarak bunun bir
dosya olacağını belirtir.
176
00:08:51,940 --> 00:08:52,840 C kodu
var.
177
00:08:52,840 --> 00:08:57,250 .docx
değil, bu dosyada bir Microsoft Word
belgesi olduğu anlamına gelir,
178
00:08:57,250 --> 00:08:59,260
veya .pages bir Pages dosyasıdır.
179
00:08:59,260 --> 00:09:03,820 Bu .c,
yani bu dosyadaki metin,

180
00:09:03,820 --> 00:09:07,270 C.
Buradaki 1 rakamı sadece yardımcı
olacak otomatik bir satır numarasıdır.
181
00:09:07,270 --> 00:09:09,640 Bu
programın ne kadar uzun veya kısa
olduğunu takip ediyorum.
182
00:09:09,640 --> 00:09:12,250
Ve imleç orada yanıp
sönüyor, bekliyor
183
00:09:12,250 --> 00:09:14,230 kod
yazmaya başlamam için.
184
00:09:14,230 --> 00:09:17,230 Pekala,
devam edeyim ve tamamen aynı
kodu yazayım.
185
00:09:17,230 --> 00:09:19,460 Benim
için hafızadan oldukça rahat geliyor.

186
00:09:19,460 --> 00:09:22,990 Bu
yüzden devam edeceğim ve standardio.h
adında bir şey ekleyeceğim--

Machine Translated by Google
187
00:09:22,990 --> 00:09:24,160 daha
sonra.
188
00:09:24,160 --> 00:09:28,420
Sihirli bir şekilde int main(void)
yazacağım, bu ne anlama geliyorsa-189
00:09:28,420 --> 00:09:29,810 Buna
daha sonra geri döneceğiz-190
00:09:29,810 --> 00:09:34,760 bu
kaşlı ayraçlardan biri ve sonra aynısını
kapatan bir kardeş.
191
00:09:34,760 --> 00:09:37,810 Sonra
birkaç boşluk girintisi yapmak için
Tab tuşuna basacağım.
192
00:09:37,810 --> 00:09:44,050
Sonra print değil printf yazacağım, ardından
"Merhaba dünya" /n,
193
00:09:44,050 --> 00:09:47,050 alıntı,
parantez kapat, noktalı virgül.

194
00:09:47,050 --> 00:09:51,250
Ve sanırım bu aslında bazılarını yazdığım
ilk programdı.
195
00:09:51,250 --> 00:09:52,419 25 yıl
önce.
196
00:09:52,419 --> 00:09:54,490
"Merhaba, CS50" demek için yazdım.
197
00:09:54,490 --> 00:09:57,400 Şimdi
sadece daha kanonik, geleneksel "Merhaba
dünya" diyor.
198
00:09:57,400 --> 00:09:58,299 Ama
bu kadar.

Machine Translated by Google
199
00:09:58,299 --> 00:09:59,590 Bu
benim ilk programım.
200
00:09:59,590 --> 00:10:02,440
Ve şimdi tek yapmam gereken
Komut-S veya Kontrol-S'ye basmak olabilir.
201
00:10:02,440 --> 00:10:03,310
dosyayı kaydetmek için.
202
00:10:03,310 --> 00:10:06,280 Ve
işte, ben bir programcıyım.
203
00:10:06,280 --> 00:10:09,027 Sorun
şu ki, tamam, bunu nasıl çalıştırırım?

204
00:10:09,027 --> 00:10:11,110
Mac'inizde veya PC'nizde bir
programı nasıl çalıştırırsınız?
205
00:10:11,110 --> 00:10:12,610
Genellikle bir simgeye çift tıklayın.
206
00:10:12,610 --> 00:10:14,320
Telefonunuzda bir simgeye dokunun.
207
00:10:14,320 --> 00:10:18,010
Kullandığımız bu ortamda ve birçok
programcı-208
00:10:18,010 --> 00:10:22,870 çoğu
programcının-- kullanın, hemen hoş ve hoş
bir simgeniz olmaz
209
00:10:22,870 --> 00:10:23,710 çift
tıklayın.
210
00:10:23,710 --> 00:10:26,933 Bu
çok kullanıcı dostu, ancak çok
gerekli değil.

Machine Translated by Google
211

00:10:26,933 --> 00:10:29,350
Özellikle programlama konusunda
kendinizi daha rahat hissettiğinizde,
212
00:10:29,350 --> 00:10:32,230
komutları yazmak isteyeceksiniz çünkü işaret
etmekten daha hızlı
213
00:10:32,230 --> 00:10:33,220 ve bir
fare tıklaması.
214
00:10:33,220 --> 00:10:35,053
Ve bazı şeyleri
otomatikleştirmek isteyeceksiniz,
215
00:10:35,053 --> 00:10:37,990 bu,
tamamen komut veya metin
tabanlıysa çok daha kolaydır, aksine
216
00:10:37,990 --> 00:10:40,330 fare
ve kas hareketlerine.
217
00:10:40,330 --> 00:10:43,210 Ve
işte programım burada.
218
00:10:43,210 --> 00:10:45,790
"hello.c" adlı bu dosyada yaşıyor.
219
00:10:45,790 --> 00:10:49,330 Ancak
şimdi onu sıfırlara ve birlere
dönüştürmem gerekiyor.
220
00:10:49,330 --> 00:10:53,530
Peki, bunu nasıl yapacağım ve bundan
nasıl kurtulacağım?
221
00:10:53,530 --> 00:10:54,880 sözde
kod-222
00:10:54,880 --> 00:10:57,670 veya
geleneksel olarak adlandırıldığı gibi
kaynak kodu--

Machine Translated by Google
223

00:10:57,670 --> 00:11:02,240 bunun
üzerine, bu sıfırlar ve birler şimdi
makine kodunu çağırmaya başlayacağız.
224
00:11:02,240 --> 00:11:04,690
Geçen haftaki sıfırlar ve birler
sadece
225
00:11:04,690 --> 00:11:09,950 sayıları
ve harfleri, renkleri, sesi, videoyu ve
daha fazlasını temsil eder.
226
00:11:09,950 --> 00:11:15,250
Ayrıca, yazdırma veya ses çalma gibi bir
bilgisayara verilen talimatları da temsil edebilir,
227
00:11:15,250 --> 00:11:17,290 veya bir
dosyayı silin veya bir dosyayı kaydedin.

228
00:11:17,290 --> 00:11:19,960
Bir bilgisayarın tüm
temelleri bir şekilde
229
00:11:19,960 --> 00:11:23,560 diğer
sıfır ve bir kalıplarıyla temsil edilebilir.

230
00:11:23,560 --> 00:11:26,133
Ve tıpkı geçen hafta olduğu
gibi, duruma bağlı
231
00:11:26,133 --> 00:11:27,550 bu
numaraların saklandığı.
232
00:11:27,550 --> 00:11:30,880 Bazen
bir elektronik tabloda olduğu gibi
sayılar olarak yorumlanırlar.
233
00:11:30,880 --> 00:11:32,590 Bazen
renk olarak yorumlanırlar.
234
00:11:32,590 --> 00:11:37,240
Bazen olarak yorumlanırlar

Machine Translated by Google
talimatlar, bilgisayarınıza komutlar
235
00:11:37,240 --> 00:11:42,020
ekrana bir şey yazdırmak gibi çok
düşük seviyeli işlemler yapmak için.
236
00:11:42,020 --> 00:11:46,810
Neyse ki, geçen haftaki bilgisayar
biliminin problem çözme tanımı
237
00:11:46,810 --> 00:11:49,220
tam olarak eldeki hedef için
güzel bir zihinsel modeldir.
238
00:11:49,220 --> 00:11:52,000
Bazı girdilerim var, AKA kaynak kodu.
239
00:11:52.000 --> 00:11:56,200
Sonuç olarak makine kodunu, o
sıfırları ve birleri çıktılamak istiyorum.
240
00:11:56,200 --> 00:11:58,780 Bu
tür bir işlemi kesinlikle elle
yapmak istemiyorum.
241
00:11:58,780 --> 00:12:02,380
Umarım özel bir program tarafından
uygulanan bir algoritma vardır.
242
00:12:02,380 --> 00:12:03,825
tam olarak bunu yapar.
243
00:12:03,825 --> 00:12:05,950
Ve daha önce tecrübe
sahibi olanlarınız,
244
00:12:05,950 --> 00:12:08,146 bu
program a?
245
00:12:08,146 --> 00:12:09,350 Bir
derleyici.
246
00:12:09,350 --> 00:12:11,350

Machine Translated by Google
Yani birkaçınız, gerçekten,
daha önce programladınız.
247
00:12:11,350 --> 00:12:13,030 Tüm
diller derleyici kullanmaz.
248
00:12:13,030 --> 00:12:15,550 C aslında
derleyici kullanan bir dildir.

249
00:12:15,550 --> 00:12:18,880
Ve bu yüzden kendimi bulmam gerekiyor-250
00:12:18,880 --> 00:12:22,480
bilgisayarımda bir yerde, muhtemelen-sözde derleyici,
251
00:12:22,480 --> 00:12:26,930 hayattaki
amacı bir dili diğerine dönüştürmek olan
bir program.
252
00:12:26,930 --> 00:12:31,660
Ve biraz önce gördüğümüz gibi, metinsel
olarak C ile yazılmış kaynak kodu,
253
00:12:31,660 --> 00:12:32,860 kaynak
kodudur.
254
00:12:32.860 --> 00:12:35,690 Makine
kodu, karşılık gelen sıfırlar ve birlerdir.

255
00:12:35,690 --> 00:12:39,460
Bu yüzden, adı verilen aynı
programlama ortamına geri dönmeme izin verin.
256
00:12:39,460 --> 00:12:41,620 Visual
Studio Code veya VS Code.
257
00:12:41,620 --> 00:12:44,740
Bu genellikle sizin veya internetteki
herhangi bir programcının bir programıdır.
258

Machine Translated by Google
00:12:44,740 --> 00:12:48,550 kendi
Mac'lerine indirebilir veya
PC ve her ne olursa olsun yolda olun
259
00:12:48,550 --> 00:12:50,950 Sahip
olduğunuz bilgisayar bazı kodlar yazar.
260
00:12:50,950 --> 00:12:53,380
Yine de, bu yaklaşımın bir
dezavantajı, hepimizin
261
00:12:53,380 --> 00:12:55,990 Mac
veya PC'lerin biraz farklı sürümlerine
sahiptir.
262
00:12:55,990 --> 00:12:58,570 İşletim
sistemlerinin biraz farklı sürümleri
var.
263
00:12:58,570 --> 00:13:00,130 Güncel
olabilir veya olmayabilir.
264
00:13:00,130 --> 00:13:04,220
Tek tip bir ortam yaratmak sadece teknik
bir destek kabusu,
265
00:13:04,220 --> 00:13:07,030
özellikle herkesin ideal olarak
yapması gereken bir giriş sınıfı için
266
00:13:07,030 --> 00:13:10,400 aynı
sayfada olun, böylece sizi hızla
çalıştırıp çalıştırabiliriz.
267
00:13:10,400 --> 00:13:14,380
Ve bu yüzden aslında VS Kodunun bulut tabanlı
bir sürümünü kullanıyorum, bir şey
268
00:13:14,380 --> 00:13:17.170
erişmek için yalnızca bir tarayıcıya ihtiyacınız var.
269
00:13:17,170 --> 00:13:19,960 Ve
sonra bugün veya yarın herhangi
bir bilgisayarda olabilirsiniz.

Machine Translated by Google
270
00:13:19,960 --> 00:13:23,540
Dönemin sonunda, sizi buluttan
çıkaracağız,
271
00:13:23,540 --> 00:13:27,220
tabiri caizse, elimizden geldiğince
sizi kendi Mac veya PC'nize alalım,
272
00:13:27,220 --> 00:13:30,730
böylece bu dersten sonra, özellikle
de aldığınız tek CS dersiyse,
273
00:13:30,730 --> 00:13:34,330
istediğiniz sayıda dilde
programlamaya devam edebileceğinizi hissediyorsanız,
274
00:13:34,330 --> 00:13:36,470
CS50 arkanızdayken bile.
275
00:13:36,470 --> 00:13:39,160
Ama şimdilik, harika bir şekilde,
VS Code'un tarayıcı sürümü
276
00:13:39,160 --> 00:13:42,992,
nihai olarak indirilebilir olanla
hemen hemen aynı olmalıdır
277
00:13:42,992 --> 00:13:44,200
versiyonu aynı olurdu.
278
00:13:44,200 --> 00:13:46,720
Ve buna nasıl erişeceğinizi
problem seti 1'de göreceksiniz.

279
00:13:46,720 --> 00:13:49,990 ve
ilk programlarınıza nasıl
başlayacağınız.
280
00:13:49,990 --> 00:13:52,840
Ama ekranın bu alt kısmından
bahsetmedim,
281

Machine Translated by Google
00:13:52,840 --> 00:13:54,340
ekranın bu alt kısmı.

282
00:13:54,340 --> 00:13:57,770
Ve bu, terminal penceresi denen
şeye sahip olduğumuz bir alandır.
283
00:13:57,770 --> 00:14:01,600
Yani bu, bir klavyeyle,

284
00:14:01,600 --> 00:14:06,580
nerede olursa olsun bir bilgisayarla
etkileşim kurmak için-- kucağınızda, cebinizde,

285
00:14:06,580 --> 00:14:08,800
veya hatta bu durumda bulutta.
286
00:14:08,800 --> 00:14:11,350
Yani bu ekranın üst
kısmında
287
00:14:11,350 --> 00:14:15,940,
sekmeli pencereler gibi, birçok
programda olduğu gibi metin düzenleyicimdir.
288
00:14:15,940 --> 00:14:18,130
Sadece dosya oluşturabilir ve kod yazabilirim.

289
00:14:18,130 --> 00:14:21,250
Buradaki ekranın alt kısmı,
sözde terminal pencerem,
290
00:14:21,250 --> 00:14:24,340
bana bir sunucuda komut
çalıştırma yeteneği veriyor

291
00:14:24,340 --> 00:14:26,800
şu anda özel erişimim var.
292
00:14:26,800 --> 00:14:30,880
VS'ye giriş yaptığım için
Hesabımla çevrimiçi kod,

Machine Translated by Google
293
00:14:30,880 --> 00:14:35,650
Benim kendi sanal sunucum var,
eğer istersen, bulutta-294
00:14:35,650 --> 00:14:37,900 bu
bağlamda konteyner olarak da
bilinir.
295
00:14:37,900 --> 00:14:40,970
Bunun benim için kendi işletim sistemi
var, kendi sabit diski,
296
00:14:40,970 --> 00:14:43,840
istersen, kendi dosyalarımı
kaydedip oluşturabilirim,
297
00:14:43,840 --> 00:14:46,190
sizinkinden ayrı ve tam tersi.
298
00:14:46,190 --> 00:14:48,580
Ve bu çok basit
istemde, ki
299
00:14:48,580 --> 00:14:51,417
geleneksel olarak-- ama her zaman
değil-- dolar işaretiyle kısaltılır,
300
00:14:51,417 --> 00:14:52,750'nin
para birimiyle hiçbir ilgisi yoktur.
301
00:14:52,750 --> 00:14:54,843
Sadece komutlarınızı buraya yazın anlamına gelir.
302
00:14:54,843 --> 00:14:57,010
Burası komutları yazabileceğim
yer,
303
00:14:57,010 --> 00:15:01,070
kaynak kodumu makine koduna
derlemek gibi.
304
00:15:01,070 --> 00:15:06,722

Machine Translated by Google

Yani bu bir Komut Satırı Arayüzü veya

CLI, bir işletim sisteminin üstünde
305
00:15:06,722 --> 00:15:09,430 hiç
kullanmamış veya görmemiş olabilirsiniz,
ancak çok popüler,
306
00:15:09,430 --> 00:15:10,420 Linux
olarak adlandırılır.
307
00:15:10,420 --> 00:15:14,930
Bu odadaki neredeyse hepimizin şu anda Mac
OS veya Windows kullanma ihtimali var,
308
00:15:14,930 --> 00:15:18,190 ama
hepimiz Linux adında bir işletim sistemi
kullanmaya başlayacağız.
309
00:15:18,190 --> 00:15:21,340 yalnızca
bu komutu sunmakla kalmayan bir işletim
sistemleri ailesindedir.
310
00:15:21,340 --> 00:15:24,430 hat
arabirimi, ancak yalnızca programlama
için değil, hizmet vermek için de kullanılır
311
00:15:24,430 --> 00:15:27,050 web
siteleri ve uygulama geliştirme vb.

312
00:15:27,050 --> 00:15:31,490 Ve
göreceğimiz gibi gerçekten de tanıdık ve
çok güçlü bir arayüz.
313
00:15:31.490 --> 00:15:37,000 Peki bu
merhaba.c dosyasını bir programa nasıl
dönüştürebilirim?
314
00:15:37,000 --> 00:15:39,940 Çift
tıklanacak bir simge yok ama bir komut
var.
315
00:15:39,940 --> 00:15:45,340
Bu dolara yazabilirim, merhaba yapabilirim

Machine Translated by Google
istemi imzalayın, devam edin ve Enter'a basın,

316
00:15:45,340 --> 00:15:47,500 ve hiçbir
şey olmuyor gibi görünüyor.
317
00:15:47,500 --> 00:15:48,732 Ama bu
iyi bir şey.
318
00:15:48,732 --> 00:15:50,690
Ve programlamada
göreceğimiz gibi, neredeyse her zaman,
319
00:15:50,690 --> 00:15:53,860 Eğer bir
şeylerin ters gittiğini görmüyorsanız, bu
her şeyin yolunda gittiği anlamına gelir.
320
00:15:53,860 --> 00:15:55,600
Yani bu ilk başta nadir
olacak,
321
00:15:55,600 --> 00:15:58,690 ama bu
iyi bir şey ki hiçbir şey yapmıyormuş
gibi görünüyor.
322
00:15:58,690 --> 00:16:02,860
Ama şimdi hesaplarımdaki
klasörde var
323
00:16:02,860 --> 00:16:06,460 bu
bulutta "merhaba" adında bir dosya.

324
00:16:06,460 --> 00:16:09,970
Ve bu biraz garip bir komut ama
alışacaksınız.
325
00:16:09,970 --> 00:16:10.780 çok
geçmeden.
326
00:16:10,780 --> 00:16:13,780 . sadece
şu anki klasörüme gitmek anlamına gelir.
327
00:16:13,780 --> 00:16:19,570

Machine Translated by Google
/hello, bu geçerli klasörde "merhaba" adlı
programı çalıştırmak anlamına gelir.
328
00:16:19,570 --> 00:16:24,070 Yani ./
hello, ve sonra Enter ve işte, şimdi aslında
sadece programlama yapmıyorum,
329
00:16:24,070 --> 00:16:26,990 ama
asıl kodumu çalıştırıyor.
330
00:16:26,990 --> 00:16:29,500 Peki az
önce ne yaptım?
331
00:16:29,500 --> 00:16:31,310 Devam
edeyim ve şunu yapayım.
332
00:16:31,310 --> 00:16:33,970
Devam edeceğim ve bu programın
kenar çubuğunu açacağım,
333
00:16:33,970 --> 00:16:36,110 ve
problem seti 1'de bunun nasıl
yapıldığını göreceksiniz.
334
00:16:36,110 --> 00:16:39,250 Ve bu,
kendi yapılandırmanıza bağlı olarak biraz
farklı görünebilir.
335
00:16:39,250 --> 00:16:42,390
Kullandığım renk şeması bile sonuçta sizinkinden
farklı görünebilir.
336
00:16:42,390 --> 00:16:44,140 çünkü
güzel ve renkli bir temayı destekliyor.

337
00:16:44,140 --> 00:16:47,920
Böylece farklı renk ve parlaklıklara
sahip olabilirsiniz.
338
00:16:47,920 --> 00:16:49,450 ruh
halinize veya günün saatine göre.
339

Machine Translated by Google
00:16:49,450 --> 00:16:52,840
Yine de burada açtığım şey, VS
Code Explorer'da denilen şeydir,
340
00:16:52,840 --> 00:16:55,478
ve bu sadece bulut hesabımdaki
dosyaların tamamı.
341
00:16:55,478 --> 00:16:56,770
Ve şu anda çok fazla yok.
342
00:16:56,770 --> 00:16:57,775
Sadece iki tane var.
343
00:16:57,775 --> 00:17:00,280
Biri merhaba.c adlı dosyadır ve
vurgulanmıştır
344
00:17:00,280 --> 00:17:02,050
çünkü tam orada açtım.
345
00:17:02,050 --> 00:17:05,530
Diğeri ise "merhaba" adında
yepyeni bir dosya.
346
00:17:05,530 --> 00:17:08,530
ve bu komutu çalıştırdığımda oluşturuldu.
347
00:17:08,530 --> 00:17:12,630
Ve şimdi kayda değer olan şey, şimdi
işlerin biraz daha fazla olması.
348
00:17:12,630 --> 00:17:13,980
Mac OS ve Windows gibi.
349
00:17:13,980 --> 00:17:17,340
Sol taraftaki gibi, bir GUI'niz var, bir
Grafik Kullanıcı Arayüzü.
350
00:17:17,340 --> 00:17:21,475
Ancak burada en altta yine bir CLI,
Komut Satırı Arayüzü var.
351

Machine Translated by Google
00:17:21,475 --> 00:17:23,850

Bunlar bilgisayarlarla etkileşim
kurmanın sadece farklı yolları,
352
00:17:23,850 --> 00:17:25,392 ve her
ikisiyle de rahat edeceksiniz.
353
00:17:25,392 --> 00:17:28,650
Ve dürüst olmak gerekirse, GUI'lere zaten
aşinasınız ve rahatsınız,
354
00:17:28,650 --> 00:17:32,110 bu
yüzden biraz zaman geçireceğimiz
komut satırı bu.
355
00:17:32,110 --> 00:17:34,800
Şimdi sadece bir şey yapmak
istediğimi varsayalım
356
00:17:34,800 --> 00:17:36,638 bu
programı derlemekten daha fazlası.
357
00:17:36,638 --> 00:17:38,430 Devam
edip onu kaldırmak istediğimi
varsayalım.
358
00:17:38,430 --> 00:17:39,900 Mesela,
uh-uh, hayır, bir hata yaptım.
359
00:17:39,900 --> 00:17:42,270
"Merhaba dünya" değil "Merhaba,
CS50" demek istiyorum.
360
00:17:42,270 --> 00:17:46,320
Herhangi bir yazılımda olduğu gibi,
sadece buraya gelebilirim ve sağ tıklayabilirim,
361
00:17:46,320 --> 00:17:49.080 ve
biraz kurcalayabilirim ve orada kalıcı
olarak silebilirim.
362
00:17:49,080 --> 00:17:51,570
Dolayısıyla çoğumuz bu içgüdüye
Mac veya PC'de sahip olabiliriz.

Machine Translated by Google
363
00:17:51,570 --> 00:17:54.000 Sağ
tıklar veya Control tuşuna basarak
tıklarsınız ve ortalığı dürtersiniz.
364
00:17:54.000 --> 00:17:57,150 Ancak
bir komut satırı arayüzünde bunun
yerine bunu yapmama izin verin.
365
00:17:57,150 --> 00:17:59,640
Bir dosyayı kaldırma veya silme
komutu
366
00:17:59,640 --> 00:18:03,300 Linux
dünyasında, bu diğer işletim sistemi,

367
00:18:03,300 --> 00:18:07,530, yalnızca
kaldırmak için bir rm türüdür ve
ardından "merhaba", Enter'a basın.

368
00:18:07,530 --> 00:18:10.290
Biraz şifreli bir onay mesajı ama bu sadece
şu anlama geliyor,
369
00:18:10,290 --> 00:18:11,160 emin
misin?
370
00:18:11,160 --> 00:18:12,960 Devam
edeceğim ve Evet için Y yazacağım.

371
00:18:12,960 --> 00:18:15,390
Ve şimdi vurduğumda
Girin, ne olduğunu izleyin
372
00:18:15,390 --> 00:18:19,440
Explorer'da sol üstte, GUI, grafik
arayüz.
373
00:18:19,440 --> 00:18:21.989 İşte,
kayboluyor.
374

Machine Translated by Google
00:18:21,989 --> 00:18:24,180

Çok heyecan verici değil, ama
bu sadece şu anlama geliyor

375
00:18:24,180 --> 00:18:26,739 bu,
burada gördüklerimizin grafik
versiyonudur.
376
00:18:26,739 --> 00:18:29,999
Ve aslında, GUI'yi bir daha asla
kullanmak istemiyorsanız-377
00:18:29,999 --> 00:18:32,890
Devam edeceğim ve burada
bir klavye kısayoluyla kapatacağım-378
00:18:32.890 --> 00:18:36,630
sonsuza kadar liste için ls yazıp
Enter'a basabilirsiniz.
379
00:18:36,630 --> 00:18:39,300
Ve komut satırı arayüzünde
göreceksiniz
380
00:18:39,300 --> 00:18:41,817 geçerli
klasörünüzdeki tüm dosyalar.
381
00:18:41,817 --> 00:18:43,650
Yani bir fare ile
yapabileceğiniz her şeyi yapabilirsiniz.
382
00:18:43,650 --> 00:18:45,239 bu
komut satırı arabirimiyle yapın.
383
00:18:45,239 --> 00:18:48,610 Ve
gerçekten de yapabileceğiniz daha
birçok şey göreceğiz.
384
00:18:48,610 --> 00:18:52,290
Ama bunun mucitleri, bu işletim
sistemi ve onun öncülleri,
385
00:18:52,290 --> 00:18:53.490 çok
kısaydı.

Machine Translated by Google
386
00:18:53,490 --> 00:18:55,560
Benzer şekilde, komut kaldırma için rm'dir.
387
00:18:55,560 --> 00:18:57,330
Komut, liste için ls'dir.
388
00:18:57,330 --> 00:18:58,090 Çok
kısa ve öz.
389
00:18:58,090 --> 00:18:58,590
Neden?
390
00:18:58,590 --> 00:19:01,680
Çünkü yazması daha hızlı.
391
00:19:01,680 --> 00:19:05,460
Bundan daha ilginç bir şey yapmaya devam
etmeden önce
392
00:19:05,460 --> 00:19:07,380
sadece "Merhaba dünya," görmek
için burada durayım
393
00:19:07,380 --> 00:19:10.620
kaynak kodu veya makine ile ilgili
sorular varsa
394
00:19:10,620 --> 00:19:15,420 kod
veya derleyici veya bu komut satırı
arabirimi.
395
00:19:15,420 --> 00:19:16,293 Evet?

396
00:19:16,293 --> 00:19:17,828
İZLEYİCİ: [DUYULMAZ].
397
00:19:17,828 --> 00:19:20,120
DAVID J. MALAN: Gerçekten güzel bir
soru, tekrar özetlememe izin verin.
398

Machine Translated by Google
00:19:20,120 --> 00:19:21,950
Eğer programda
değişiklik yapacak olsaydım,
399
00:19:21,950 --> 00:19:25.070
çalıştırın ve sonra belki başka değişiklikler
yapıp yeniden çalıştırmayı deneyin,
400
00:19:25.070 --> 00:19:28,227 Biraz
yeniden yazsam da bu değişiklikler
yansıtılır mı?
401
00:19:28,227 --> 00:19:29,060 Peki,
hadi şunu yapalım.
402
00:19:29,060 --> 00:19:31,160 Eski
sürümü zaten kaldırdım.
403
00:19:31,160 --> 00:19:34,730
Öyleyse devam edeyim ve eğer
şimdi yaparsam ./merhaba,
404
00:19:34,730 --> 00:19:38,960
Dosyayı yeni sildiğim için bir tür hata
göreceğim.
405
00:19:38,960 --> 00:19:41,630
Böyle bir dosya veya dizin yok,
bu yüzden çok kullanıcı dostu değil,
406
00:19:41,630 --> 00:19:43,160 ama
sorunun ne olduğunu söylüyor.
407
00:19:43,160 --> 00:19:46,430 Devam
edeyim ve make merhaba yazarak
yeniden oluşturayım.
408
00:19:46,430 --> 00:19:51,110
Şimdi ls yazarsam, yine bir değil iki
dosya göreceğim ve bunlardan biri
409
00:19:51,110 --> 00:19:54,815
çalıştırılabilir olduğunu belirtmek için
küçük bir yıldız işaretiyle bile yeşildir.

Machine Translated by Google
410
00:19:54,815 --> 00:19:56,690
Bir şeyin metinsel
versiyonu gibi
411
00:19:56,690 --> 00:19:58,450 bizim
insan dünyamıza çift tıklayabilirsiniz.

412
00:19:58,450 --> 00:20:01,700 Şimdi,
tabii ki merhaba koşarsam, başladığım yere
geri döneriz, "Merhaba dünya."
413
00:20:01,700 --> 00:20:07,010 Ama
şimdi yıllar önce yaptığım gibi
"Merhaba, CS50" olarak değiştirdiğimi varsayalım.
414
00:20:07,010 --> 00:20:12,200 Devam
edip dosyayı Command-S veya Control-S ile
kaydetmeme izin verin. Şimdi burada,
415
00:20:12,200 --> 00:20:14,880 izin
ver ./merhaba tekrar koşayım, ve işte.
416
00:20:14,880 --> 00:20:16,370 Ha.

417
00:20:16,370 --> 00:20:18,630 O
halde bir başkasından bu soruyu
yanıtlamasını isteyeyim.
418
00:20:18,630 --> 00:20:20,210 Eksik
adım nedir?
419
00:20:20,210 --> 00:20:22,250 Neden
"Merhaba, CS50" demedi?
420
00:20:22,250 --> 00:20:23,453 Evet?

421
00:20:23,453 --> 00:20:24,370
İZLEYİCİ: [DUYULMAZ].

Machine Translated by Google
422

00:20:24,370 --> 00:20:26,440 DAVID
J. MALAN: Evet, tekrar derlemedim.

423
00:20:26,440 --> 00:20:29,620
Yani bir tür acemi hatası, bu hatayı ve
diğerlerini yapacaksınız
424
00:20:29,620 --> 00:20:30,190 çok
geçmeden.
425
00:20:30,190 --> 00:20:33,250 Ama
şimdi devam edeyim ve merhabayı
yeniden yazayım, girin.
426
00:20:33,250 --> 00:20:36,370
Görünüşe göre aynı programı
yapacak.
427
00:20:36,370 --> 00:20:40,630 Ama
bu sefer çalıştırdığımda, "Merhaba,
CS50."
428
00:20:40.630 --> 00:20:44,380 Bu
yapı taşlarından bazılarıyla ilgili
başka sorunuz var mı?
429
00:20:44,380 --> 00:20:47,780 Ve çok
geçmeden yazdığım tüm çılgın
sözdizimine geri döneceğiz.
430
00:20:47,780 --> 00:20:50,080 Ancak
şimdilik sadece çıktıya odaklanıyoruz.

431
00:20:50,080 --> 00:20:51,030 Evet?

432
00:20:51,030 --> 00:20:52,052
İZLEYİCİ: [DUYULMAZ].
433
00:20:52,052 --> 00:20:53,760 DAVID
J. MALAN: Ne zaman

Machine Translated by Google
koşmaya devam ediyorum,
434
00:20:53,760 --> 00:20:56,710 makine
kodunun yeni bir sürümünü oluşturur.

435
00:20:56,710 --> 00:21:00,690 Yani
merhaba programını ve merhaba dosyasını
değiştirmeye devam ediyor, hepsi bu.
436
00:21:00,690 --> 00:21:03,798 Kendi
başına bir make dosyası yoktur.
437
00:21:03,798 --> 00:21:04,833 İZLEYİCİ:
[DUYULMAZ].
438
00:21:04,833 --> 00:21:06,250 DAVID J.
MALAN: Güzel soru, hayır.
439
00:21:06,250 --> 00:21:09,340 Eğer o
dizini açarsam, sadece bir tane olduğunu
göreceksiniz.
440
00:21:09,340 --> 00:21:12,430
Ve merhaba yapmak için kaç kez
koştuğum önemli değil-441
00:21:12,430 --> 00:21:16,450 üç, dört,
beş-- orijinalin üzerine yazmaya devam
ediyor.
442
00:21:16,450 --> 00:21:19,952
Yani Google Dokümanlar veya Microsoft
dünyasında tasarruf etmek gibi bir şey
443
00:21:19,952 --> 00:21:20.660 Word
veya benzeri.
444
00:21:20.660 --> 00:21:22,202 Ancak
bugün ek bir adım daha var.
445
00:21:22,202 --> 00:21:27,480
O zaman sözlerimi dönüştürmeliyiz

Machine Translated by Google
bilgisayar, sıfırlar ve birler.
446
00:21:27,480 --> 00:21:28,793
Evet, önde.
447
00:21:28,793 --> 00:21:29,740
İZLEYİCİ: [DUYULMAZ].
448
00:21:29,740 --> 00:21:31,930
DAVID J. MALAN: Ah, merhaba.c'yi
çalıştırırsam ne olur?
449
00:21:31,930 --> 00:21:36,280
Öyleyse devam edeyim ve ./hello.c
yapayım, bu her zaman yapacağınız bir hatadır
450
00:21:36,280 --> 00:21:37,720
erken yap.
451
00:21:37,720 --> 00:21:39.020 İzin
reddedildi.
452
00:21:39.020 --> 00:21:40,000 Peki
bu ne anlama geliyor?
453
00:21:40.000 --> 00:21:42.160
Hata mesajlarının bir
anlam ifade ettiği yer burasıdır.
454
00:21:42,160 --> 00:21:44,860
işletim sistemini tasarlayanlara ama biraz
şifreli.
455
00:21:44,860 --> 00:21:46,900
Dosyaya erişiminiz olmadığından
değil.
456
00:21:46,900 --> 00:21:48,610
Yürütülebilir olmadığı anlamına gelir.
457
00:21:48,610 --> 00:21:51,400
Bu, çalıştırma izniniz olan bir
şey değil,

Machine Translated by Google
458
00:21:51,400 --> 00:21:55,942
ancak okuma veya yazma izniniz var-yani değiştirin.
459
00:21:55,942 --> 00:21:57,220
İZLEYİCİ: [DUYULMAZ].
460
00:21:57,720 --> 00:21:59,428
DAVID J. MALAN: Oh, gerçekten
güzel bir soru.
461
00:21:59,428 --> 00:22:03.000
Bu nedenle, dosyama merhaba C
noktası veya daha genel olarak bir ad verdiysem

462
00:22:03.000 --> 00:22:06,960 nokta
C,
Otomatik olarak yapar mı
463
00:22:06,960 --> 00:22:08,580
benim için dosya adını seçer.
464
00:22:08,580 --> 00:22:10,110
Ve biraz tartışacağız--

465
00:22:10,110 --> 00:22:11,910 Bunu
önümüzdeki hafta biraz daha tartışacağız.
466
00:22:11,910 --> 00:22:14,910
Kendini yap-- bugün beyaz
yalanların ilki.
467
00:22:14,910 --> 00:22:16,680'in
kendisi bir derleyici değildir.
468
00:22:16,680 --> 00:22:22,020
Sistemdeki derleyiciyi bulmayı ve
kullanmayı bilen bir programdır.
469
00:22:22,020 --> 00:22:24,360 ve
programı otomatik olarak oluşturun.

Machine Translated by Google
470

00:22:24,360 --> 00:22:28,290
Gelecek hafta tartışacağımız gibi,
gerçek derleyiciyi kendim kullanırsam,
471
00:22:28,290 --> 00:22:32,280
Açıkça belirtmek için çok daha uzun bir
komut dizisi yazmam gerekiyor
472
00:22:32,280 --> 00:22:34,470
Programımın adının ne olmasını
istiyorum.
473
00:22:34,470 --> 00:22:36,510
Make güzel bir program
özellikle 1.haftada
474
00:22:36,510 --> 00:22:38,860 çünkü
tüm bunları bizim için otomatik
hale getiriyor.
475
00:22:38,860 --> 00:22:42,420
Ve burada, artık çok basit bir
şekilde yazdıran bir programımız var.
476
00:22:42,420 --> 00:22:43,420
ekranda bir şey var.
477
00:22:43,420 --> 00:22:45,990
O halde bunu şu
bağlamın içine koymayalım.
478
00:22:45,990 --> 00:22:50,070
Scratch ve giriş çıkışlar bağlamında
geçen sefer ayrıldık.
479
00:22:50,070 --> 00:22:53,160 Bu
yüzden son kez, elbette, işlevleri ve
argümanları tartışıyoruz.
480
00:22:53,160 --> 00:22:58,210 Yine
işlevler, söylemek, sormak veya benzeri
eylemler ve fiillerdir.
481

Machine Translated by Google
00:22:58,210 --> 00:23:00,602
Ve argümanlar bu
fonksiyonların girdileriydi,
482
00:23:00,602 --> 00:23:03,060
genellikle Scratch'te o küçük
beyaz ovallerde
483
00:23:03,060 --> 00:23:05,160
içine kelime veya sayı yazabilir.
484
00:23:05,160 --> 00:23:08,160
Göreceğiz, tüm dillerde bu terimi
göreceğiz,
485
00:23:08,160 --> 00:23:09,482
aynı yeteneğe sahiptir.
486
00:23:09,482 --> 00:23:12,190 Ve
şimdi bunlardan birini diğerine
çevirmeye başlayalım.
487
00:23:12,190 --> 00:23:16,110
Örneğin, aynı programı
C'ye koyalım,
488
00:23:16,110 --> 00:23:17,310
Scratch bağlamında.
489
00:23:17,310 --> 00:23:20.820
Merhaba, Dünya geçen hafta tek işlev
şeklinde böyle görünüyordu.
490
00:23:20.820 --> 00:23:23,730 Bu
hafta tabii ki baskı gibi görünüyor.

491
00:23:23,730 --> 00:23:26,190
Ve sonra parantezler, dikkat
edin, bir tür
492
00:23:26,190 --> 00:23:29,878
Scratch dünyasında aynı şekle benzemesi
için kasıtlı olarak tasarlandı.

Machine Translated by Google
493
00:23:29,878 --> 00:23:31,920
Bu beyaz bir oval olsa
da,
494
00:23:31,920 --> 00:23:36,600
parantez içinde aynı fikri
çağrıştırıyor.
495
00:23:36,600 --> 00:23:40,380
Teknik olarak C'deki fonksiyona
say denmez.
496
00:23:40,380 --> 00:23:41.670
Bunun adı baskı bile değil.
497
00:23:41,670 --> 00:23:42,870 Buna
printf denir.
498
00:23:42,870 --> 00:23:46,260 F,
biçimlendirilmiş anlamına gelir, ancak
bunun ne anlama geldiğini birazdan göreceğiz.

499
00:23:46,260 --> 00:23:48,810
Ancak printf en yakın
benzer işlevdir
500
00:23:48,810 --> 00:23:52,080
örneğin C dünyasında.

501
00:23:52,080 --> 00:23:56,700 gibi
bir şey yazdırmak istiyorum
Merhaba, Dünya veya C'de Merhaba CS50,

502
00:23:56,700 --> 00:24:00,180
Geçen hafta yaptığımız gibi
kelimeleri sadece yazmıyorsunuz.
503
00:24:00,180 --> 00:24:02,610
Ayrıca, zaten fark ettiyseniz,
ne eklediniz?
504

Machine Translated by Google

00:24:02,610 --> 00:24:04,560 Bu

sürümde eksik olan şey.
505
00:24:04,560 --> 00:24:06,880 Evet,
yani sol ve sağdaki çift tırnak.

506
00:24:06,880 --> 00:24:12.198 Yani,
bir dizi kelimeye sahip olduğunuzda C'de
bu gereklidir.
507
00:24:12,198 --> 00:24:13,740 Ve bu
kelimeyi bilinçli olarak kullanıyorum.
508
00:24:13,740 --> 00:24:18.030
Bunun gibi birden fazla kelimeniz
olduğunda, bu bir dize olarak bilinir.
509
00:24:18,030 --> 00:24:18,660
göreceğimiz gibi.
510
00:24:18,660 --> 00:24:22,170 Ve
bunu tek tırnak yerine çift tırnak içine
almalısınız.
511
00:24:22,170 --> 00:24:23,880 Çift
tırnak içine almalısınız.
512
00:24:23,880 --> 00:24:28,080
C kodumda olması gereken aptalca
bir şey daha var.
513
00:24:28,080 --> 00:24:32,170 Bu
işlevin nihayetinde bir şey yapmasını
sağlamak için, hangisi nedir?
514
00:24:32,170 --> 00:24:33.040 Noktalı
virgül.
515
00:24:33,040 --> 00:24:35,440
Yani tıpkı bizim insan
dünyamızda olduğu gibi, sonunda
516

Machine Translated by Google
00:24:35,440 --> 00:24:38,470,
en azından resmi yazılarda,
nokta kullanma alışkanlığı kazandı.
517
00:24:38,470 --> 00:24:41,890
Noktalı virgül genellikle
düşüncenizi bitirmek için kullandığınız şeydir

518
00:24:41,890 --> 00:24:44,980 C
ile programlama dünyasında.
519
00:24:44,980 --> 00:24:47,110
Pekala, bu işlevi yerine getirdik.

520
00:24:47,110 --> 00:24:50,860
Şimdi, bu zihinsel model
açısından gerçekten neye uyuyor?
521
00:24:50,860 --> 00:24:52,270
Peki, fonksiyonlar argüman alır.
522
00:24:52,270 --> 00:24:55,960
Görünen o ki, işlevlerin farklı
türde çıktıları olabilir.
523
00:24:55,960 --> 00:24:58,270 Ve
aslında ikisini de geçen hafta
gördük.
524
00:24:58,270 --> 00:25:02,560
Bir fonksiyondan çıkan bir tür çıktı,
yan etki olarak adlandırılan bir şey olabilir.
525
00:25:02,560 --> 00:25:04,630
Ve genellikle görsel bir
şeye atıfta bulunur,
526
00:25:04,630 --> 00:25:08,770
ekranda görünen bir şey veya
bilgisayarınızdan gelen bir ses gibi.
527
00:25:08,770 --> 00:25:11,410

Bir nevi yan etkisi

Machine Translated by Google
işlev işini yapıyor.
528
00:25:11,410 --> 00:25:15,430
Ve gerçekten de, geçen hafta bunu bir
şeyden geçme bağlamında gördük.
529
00:25:15,430 --> 00:25:18,380 gibi
Merhaba, Dünya say işlevine girdi
olarak.
530
00:25:18,380 --> 00:25:22,240 Ve
ekranda Hello, World'ü gördük,
ama bu bir çeşit kapalıydı.
531
00:25:22,240 --> 00:25:24,130 Bir
ve bitti.
532
00:25:24,130 --> 00:25:27,040
Bu görsel çıktıyla aslında hiçbir
şey yapamazsınız
533
00:25:27,040 --> 00:25:29,780
bunun dışında görsel olarak insan
gözünüzle tüketin.
534
00:25:29,780 --> 00:25:34,450
Ama bazen, geçen haftayı hatırlayın,
sorma bloğu gibi fonksiyonlarımız vardı.
535
00:25:34,450 --> 00:25:36,160
aslında bana bir miktar değer verdi.
536
00:25:36,160 --> 00:25:38,200
Adınız nedir sorusunu hatırlayın.
537
00:25:38,200 --> 00:25:41,883
İnsanın yazdığı cevabı bana geri
verdi.
538
00:25:41,883 --> 00:25:44,050
Sadece keyfi olarak ekranda
göstermedi.
539

Machine Translated by Google
00:25:44,050 --> 00:25:46,390
Kedi mutlaka ekranda söylemedi.

540
00:25:46,390 --> 00:25:52,840
Bunun yerine cevap adı verilen özel
değişkende saklandı.
541
00:25:52,840 --> 00:25:56,710
Çünkü bazı fonksiyonların yan
etkileri değil, dönüş değerleri vardır.
542
00:25:56,710 --> 00:26:00,520
Kullanabileceğiniz ve yeniden
kullanabileceğiniz bir çıktıyı size geri verirler,

543
00:26:00,520 --> 00:26:03,160
yan etkinin aksine, yine
görüntüleniyor ve hepsi bu.
544
00:26:03,160 --> 00:26:05,660
Onu yakalayıp tutamazsınız.

545
00:26:05,660 --> 00:26:08,800
Geçen hafta bağlamında, soru
bloğumuz vardı.
546
00:26:08,800 --> 00:26:11.470 Ve
bu özel cevap dönüş değerine
sahipti.
547
00:26:11.470 --> 00:26:14.170
C'de, birazdan
göreceğiz,
548
00:26:14.170 --> 00:26:16,600
Bunu şu şekilde çevirebiliriz.
549
00:26:16,600 --> 00:26:20,200
Ask bloğu için
önerebileceğim en yakın eşleşme
550
00:26:20,200 --> 00:26:22,780

Machine Translated by Google
get string'i çağırmaya
başlayacağımız bir fonksiyondur.
551
00:26:22,780 --> 00:26:25,930
Dize, yine bir kelimedir, bir
kelime grubu gibi bir kelime grubudur.

552
00:26:25,930 --> 00:26:27,910
veya programlamada bir cümle.
553
00:26:27,910 --> 00:26:32,530
O da girdi aldığı sürece bir
fonksiyondur ve hemen hemen-554
00:26:32,530 --> 00:26:34,750 bu
her zaman doğru değildir-- ama
çoğu zaman
555
00:26:34,750 --> 00:26:39,460 C
harfinde bir açık parantez ve kapalı bir
parantez var,
556
00:26:39,460 --> 00:26:42,160
büyük olasılıkla bir işlevin adıdır.
557
00:26:42,160 --> 00:26:44,660 Ve
bunun bazı istisnaları olduğunu
göreceğiz.
558
00:26:44,660 --> 00:26:46,990
Ama şimdilik bu gerçekten bir
fonksiyon gibi görünüyor

559
00:26:46,990 --> 00:26:48,400
çünkü bu kalıpla eşleşiyor.
560
00:26:48,400 --> 00:26:51,868
Adın ne, soru işareti diye bir
soru sormak istersem...
561
00:26:51,868 --> 00:26:54,910 ve
oraya sadece bir tür hareket için
kasıtlı olarak bir boşluk bile koyacağım

Machine Translated by Google
562

00:26:54,910 --> 00:26:58,360 imleç
biraz üzerinde, böylece insan tam
anlamıyla yazmıyor
563
00:26:58,360 --> 00:26:59,390 soru
işaretinden sonra.
564
00:26:59,390 --> 00:27:01,400 Yani
bu sadece küçük bir estetik.
565
00:27:01,400 --> 00:27:05,680 Bu
belki de sadece bu soruyu sormaya
en yakın analogdur.
566
00:27:05,680 --> 00:27:09,880
Ancak ask bloğu bir
değer döndürdüğü için,
567
00:27:09,880 --> 00:27:13,220
Buradaki unutma dizesi analog
onun da bir değer döndürmesidir.
568
00:27:13,220 --> 00:27:15,160
Sadece insan girdisini yazdırmaz.
569
00:27:15,160 --> 00:27:19,330 Bir
değişken, yani dönüş değeri şeklinde
size geri verir,
570
00:27:19,330 --> 00:27:21,700 sonra
kullanıp yeniden kullanabilirim.
571
00:27:21,700 --> 00:27:24,670
Şimdi ideal olarak, kelimenin tam
anlamıyla bu kadar basit olurdu

572
00:27:24,670 --> 00:27:28,090
soldaki cevap eşittir diyor.
573
00:27:28,090 --> 00:27:29,980
Ve işlerin ayrılmaya
başladığı yer burası

Machine Translated by Google
574

00:27:29,980 --> 00:27:31,840
matematikten ve insan dünyamızın türünden.
575
00:27:31,840 --> 00:27:35,410 Bu
eşittir işareti bundan böyle eşittir
işareti değildir.
576
00:27:35,410 --> 00:27:37,720
Atama operatörüdür.
577
00:27:37,720 --> 00:27:41,230 Bir
değer atamak, bir değişkende bir
değer depolamak anlamına gelir.
578
00:27:41,230 --> 00:27:44,840 Ve
bunları garip bir şekilde sağdan
sola okuyorsunuz.
579
00:27:44,840 --> 00:27:47,020 İşte
get string adında bir fonksiyon.
580
00:27:47,020 --> 00:27:49,510
Sana ne olursa olsun
geri döneceğini iddia ediyorum
581
00:27:49,510 --> 00:27:51,610 insan
türleri adları olarak.
582
00:27:51,610 --> 00:27:54,520
Burada solda saklanacak
çünkü
583
00:27:54,520 --> 00:27:57,530 bu
sözde atama operatörü, evet eşittir
işaretidir.
584
00:27:57,530 --> 00:27:59,780 Ancak
bu bağlamda eşitlik anlamına
gelmez.
585
00:27:59,780 --> 00:28:01,370 İşleri
eşitler.

Machine Translated by Google
586

00:28:01,370 --> 00:28:06,160 Ama
bunu sağdaki değeri soldaki şeye
kopyalayarak yapar.
587
00:28:06,160 --> 00:28:08,140
Maalesef henüz C ile işimiz bitmedi.

588
00:28:08,140 --> 00:28:10.870
Ve burası, yine, ilk başta biraz
can sıkıcı hale geliyor.
589
00:28:10.870 --> 00:28:14.980 burada
Scratch fikirlerimizi çok fazla sözdizimi
olmadan ifade etmemize izin veriyor.
590
00:28:14,980 --> 00:28:18,310
C'de bir değişkeniniz
olduğunda, sadece
591
00:28:18,310 --> 00:28:20,200
Scratch'ta yaptığınız gibi bir isim verin.
592
00:28:20,200 --> 00:28:24,250
Ayrıca bilgisayara ne tür bir değer
olduğunu önceden söylemelisiniz.
593
00:28:24,250 --> 00:28:25,510
depoluyor.
594
00:28:25,510 --> 00:28:28,540 Dize
bu türden bir değerdir.
595
00:28:28,540 --> 00:28:31,270 Int,
tamsayı için başka bir sayı olacak.

596
00:28:31,270 --> 00:28:34,060 Ve
bugün ve ötesinde göreceğimizden
çok daha fazlası var.
597
00:28:34,060 --> 00:28:37,270
Ve bu kısmen şu soruya bir cevap

Machine Translated by Google
bir veya daha fazla kez gelen soru
598
00:28:37,270 --> 00:28:41,170
geçen hafta, bir bilgisayar bu sıfır modelini nasıl
ayırt etti?
599
00:28:41,170 --> 00:28:42,520 ve
bundan olanlar.
600
00:28:42,520 --> 00:28:46,717 Bu
bir harf mi, sayı mı, renk mi, video
parçası mı?
601
00:28:46,717 --> 00:28:49,550 Ve
geçen hafta bunun tamamen
programa bağlı olduğunu iddia ettim.
602
00:28:49,550 --> 00:28:50,633
İçeriğe göre değişir.
603
00:28:50,633 --> 00:28:52.070 Ve
bu doğru.
604
00:28:52.070 --> 00:28:55,390
Ancak bu
programlar içinde, genellikle
605
00:28:55,390 --> 00:29:000,010
insan programcının söylediğine
göre değerin türü.
606
00:29:000,010 --> 00:29:02,050
Bu, dizenin şu anlama
geldiğini belirtirse,
607
00:29:02,050 --> 00:29:04,090
Aşağıdaki sıfırları ve

608
00:29:04,090 --> 00:29:07,840
programımda daha genel olarak
kelimeler veya harfler olarak saklanıyor.
609

Machine Translated by Google
00:29:07,840 --> 00:29:12,160
Tamsayı için bir int ise, programcı
tarafından şunu ima eder,
610
00:29:12,160 --> 00:29:16,180
programımda aşağıdaki sıfırları ve
birleri sayı olarak ele al,
611
00:29:16,180 --> 00:29:17,990 bir
tamsayı, bir dize değil.
612
00:29:17,990 --> 00:29:20.860
İşte bu hafta, Scratch'in
aksine,
613
00:29:20.860 --> 00:29:24,280 ne
demek istediğinizi anlıyor, birçok dilde C ile

614
00:29:24,280 --> 00:29:27,400 Bu
kadar bilgiç olmalı ve ne demek
istediğini anlatmalısın.
615
00:29:27,400 --> 00:29:30,920
Buradaki kodumda hâlâ eksik olan
aptalca bir şey var.
616
00:29:30,920 --> 00:29:32,150
Burada hala eksik olan ne?
617
00:29:32,150 --> 00:29:32,450 Evet.

618
00:29:32,450 --> 00:29:33,350
İZLEYİCİ: [DUYULMAZ]
619
00:29:33,350 --> 00:29:35,430 DAVID
J. MALAN: Ve hala aptal noktalı virgüle
ihtiyacımız var.
620
00:29:35,430 --> 00:29:36,847 Ve
burada bir nevi onu tartışıyorum.
621

Machine Translated by Google
00:29:36,847 --> 00:29:39,260
Çünkü dürüst olmak gerekirse,
bunlar aptalca hatalardır.
622
00:29:39,260 --> 00:29:41,900 bugün,
yarın, bu hafta sonu, gelecek hafta
yapacaksınız,
623
00:29:41,900 --> 00:29:45,680 bundan
birkaç hafta sonra, siz bunu fark etmeye
ve tanımaya başlayana kadar
624
00:29:45,680 --> 00:29:49,640 İngilizce
yaptığınız veya konuştuğunuz dil ne
olursa olsun.
625
00:29:49,640 --> 00:29:51,127 Evet,
soru.
626
00:29:51,127 --> 00:29:51,710 Güzel
soru.
627
00:29:51,710 --> 00:29:54,230
Diyelim ki elmaları ve portakalları
karıştırıyorum, tabiri caizse,

628
00:29:54,230 --> 00:29:57,620 ve bir
dizeyi int'ye veya int'yi bir dizeye
koymaya çalışıyorum,
629
00:29:57,620 --> 00:29:59,780 derleyici
şikayet edecek.
630
00:29:59,780 --> 00:30:02,040
Bu make komutunu daha
önce yaptığım gibi çalıştırdığımda,
631
00:30:02,040 --> 00:30:06,092 hoş ve
mutluluk verici bir sessizlik olmayacak ve
bana başka bir ipucu ver.
632
00:30:06,092 --> 00:30:08,300
Bana dürüstçe çok şifreli
bir şekilde bağıracak

Machine Translated by Google

633
00:30:08,300 --> 00:30:11,550
okuma için kas hafızasını alana
kadar hata mesajı arıyoruz.
634
00:30:11,550 --> 00:30:14,300
Diğer sorular.
635
00:30:14,300 --> 00:30:16,190
Ah, ters eğik çizgiye ne oldu n.
636
00:30:16,190 --> 00:30:18.020
O halde, mümkünse birazdan
buna geri döneceğiz.
637
00:30:18.020 --> 00:30:20.978
Çünkü onu burada kasten atladım
ama daha önce yapmıştık.
638
00:30:20.978 --> 00:30:23,510
Ve farklı davranışı bir saniye
içinde göreceğiz.
639
00:30:23,510 --> 00:30:27,260
Diğer sorular.
640
00:30:27,260 --> 00:30:28,670
Evet, hiç de titiz değil.
641
00:30:28,670 --> 00:30:30,920
Bunlar sadece önemli olan
şeylerdir.
642
00:30:30,920 --> 00:30:34,910
Ve bu kas hafızasını tanımak ve
geliştirmek zaman alacak.
643
00:30:34,910 --> 00:30:39,505
Şu anda W hariç buraya yazdığım
her şey küçük harf.
644
00:30:39,505 --> 00:30:41,630
Ve W büyük harfle yazılır

Machine Translated by Google
sırf ingilizce olduğu için
645
00:30:41,630 --> 00:30:43,100
Diğer her şey küçük harf.
646
00:30:43,100 --> 00:30:45,710 Ve
bu tür dile ve bağlama göre değişir.

647
00:30:45,710 --> 00:30:49,820
Bu nedenle, birçok dilde kural, tüm küçük
harfleri kullanmaktır.

Değişken adlarınız için 648
00:30:49,820 --> 00:30:51,260.
649
00:30:51,260 --> 00:30:53,640
Diğer diller de bazı büyük harfler
kullanabilir.
650
00:30:53,640 --> 00:30:55,250 Ama
bunu çok geçmeden konuşacağız.
651
00:30:55,250 --> 00:30:57,150
Ama önemli olan bu
tür bir şey
652
00:30:57,150 --> 00:31:00,680 ve
özellikle küçük bir S öyle görünmüyorsa
başta görmek zor
653
00:31:00,680 --> 00:31:04,130
küçük dizüstü bilgisayarınızın
ekranında büyük bir S'den farklı.
654
00:31:04,130 --> 00:31:07,050
Ancak bu içgüdüleri geliştirmeye
başlayacaksınız.
655
00:31:07,050 --> 00:31:09,260
Pekala, bu özel bloğun
yanı sıra,
656

Machine Translated by Google

00:31:09,260 --> 00:31:13,380 hadi

devam edelim ve bunu şimdi kodda nasıl
uygulayabileceğimizi düşünelim.
657
00:31:13,380 --> 00:31:15,500 O halde
burada VS Koduna geri dönmeme izin verin.
658
00:31:15,500 --> 00:31:17,280 Daha
önce sahip olduğum program buydu.
659
00:31:17,280 --> 00:31:20,090 Ve
devam edip CS50 değişikliğimi geri
almama izin verin.
660
00:31:20,090 --> 00:31:21.920 Ve bu
sefer sadece tekrar çalıştırın.
661
00:31:21,920 --> 00:31:26,450 Make
on Hello'da ters eğik çizgili orijinal sürümle
yeniden çalıştırın n.
662
00:31:26,450 --> 00:31:28,430 Girin,
görünüşe göre kötü bir şey olmadı.

663
00:31:28,430 --> 00:31:31,940 Yani
nokta eğik çizgi Merhaba, Merhaba, Dünya girin.
664
00:31:31,940 --> 00:31:34,340
Şimdi, merak ediyorsanız,
bu iyi bir içgüdü.
665
00:31:34,340 --> 00:31:36,758 Bundan
kurtulursam ne olacağını anlamaya
başlamak için.
666
00:31:36,758 --> 00:31:39,050 Şey,
muhtemelen işleri çok fazla
bozmayacağım.
667
00:31:39,050 --> 00:31:39,980 Hadi
deneyelim.
668

Machine Translated by Google
00:31:39,980 --> 00:31:42,440

Şimdi devam edip Make Hello'yu yapayım.
669
00:31:42,440 --> 00:31:43,530 Hala
derleme.
670
00:31:43,530 --> 00:31:45,180 Yani
bu gerçekten kötü bir hata değil.
671
00:31:45,180 --> 00:31:47,900 Öyleyse
devam edeyim ve nokta eğik çizgi
Merhaba çalıştırayım.

672
00:31:47,900 --> 00:31:50,120
Buradaki fark nedir?
673
00:31:50,120 --> 00:31:52,760
Evet, farklı olarak ne görüyorsun?
674
00:31:52,760 --> 00:31:56,290
Evet, sözde istemim olan dolar işareti
aynı satırda kaldı.
675
00:31:56,290 --> 00:31:56,830
Neden?
676
00:31:56,830 --> 00:31:59,980
Şimdi muhtemelen ters
eğik çizginin
677
00:31:59,980 --> 00:32:03,730 n,
yeni bir satır oluştur demek için
süslü bir gösterimdir,
678
00:32:03,730 --> 00:32:06,080
İmleci deyim yerindeyse bir
sonraki satıra taşıyın.
679
00:32:06,080 --> 00:32:09,970
İmlecin terminal penceremde bir
sonraki satıra geçeceğine dikkat edin.
680
00:32:09,970 --> 00:32:11,980

Machine Translated by Google
Vurmaya devam
edersem, otomatik olarak,
681
00:32:11,980 --> 00:32:13,570
vurmanın doğası gereği girer, öyle mi?
682
00:32:13,570 --> 00:32:16,510
Ama bu dünyada bir program
çalıştırdığınızda biraz aptalca olurdu,
683
00:32:16,510 --> 00:32:19,510 sonraki
komut şimdi ise, olduğu kadar basit

684
00:32:19,510 --> 00:32:22,970 dolar
işaretiyle terminalin ortasında tuhaf bir
şekilde aralıklı,
685
00:32:22,970 --> 00:32:24,310 özensiz
görünüyor.
686
00:32:24,310 --> 00:32:26,260 Bu
gerçekten sadece estetik bir argüman.
687
00:32:26,260 --> 00:32:32,140 Ve bunu
yapmanın kabul edilebilir veya doğru
olmadığına dikkat edin, oraya enter tuşuna basın.
688
00:32:32,140 --> 00:32:34,640 Yine de
bunu kaydedip ne olacağını göreyim.

689
00:32:34,640 --> 00:32:38,200 Şimdi
devam edeyim ve Make Hello enter
komutunu çalıştırayım.
690
00:32:38,200 --> 00:32:40,360 Aman
tanrım, dört hata gibi.
691
00:32:40,360 --> 00:32:44,590 Bu, tek
satırlık bir program için 10 satırlık
hataya benzer.
692

Machine Translated by Google
00:32:44,590 --> 00:32:47,590

Ve işte burada, yine, sadece içgüdülerinizi
geliştirmeye başlayacaksınız.
693
00:32:47,590 --> 00:32:48.580 bu
şeyleri okuyor.
694
00:32:48,580 --> 00:32:51,730
Bu tür araçlar, kullandığımız
derleyici aracı gibi,
695
00:32:51,730 --> 00:32:55,060
mutlaka kullanıcı dostu olacak
şekilde tasarlanmamıştır.
696
00:32:55,060 --> 00:32:57,280
Bu on yıllar boyunca
değişti, ama kesinlikle erken
697
00:32:57,280 --> 00:33:01,010
üzerinde gerçekten sadece doğru
ve hatalarıyla kesin olması gerekiyordu.
698
00:33:01,010 --> 00:33:02,350 Peki
burada ne yaptım?
699
00:33:02,350 --> 00:33:05,140
Eksik sonlandırma
yakın alıntı karakteri,
700
00:33:05,140 --> 00:33:08,260 uzun
lafın kısası, C'de bir diziniz
olduğunda,
701
00:33:08,260 --> 00:33:11,710 çift
tırnaklarınızın aynı satırda olması
gerekiyor çünkü.
702
00:33:11,710 --> 00:33:13,248
Şimdi, hafif beyaz bir yalan var.
703
00:33:13,248 --> 00:33:14.290
Bunu aşmanın yolları var.

Machine Translated by Google
704

00:33:14,290 --> 00:33:20.830 Ancak
bunun en iyi yolu bu sözde kaçış
dizisini kullanmaktır.
705
00:33:20.830 --> 00:33:23,590
Bir şeyden kaçmak, genellikle ters eğik çizgi
koymak anlamına gelir ve sonra
706
00:33:23,590 --> 00:33:25,910 yeni
satır için n gibi özel bir sembol.
707
00:33:25,910 --> 00:33:30,710
Ve bu, insanların onlarca yıl önce
kararlaştırdığı yollardan biri.
708
00:33:30,710 --> 00:33:33,850 Tamam,
sadece enter tuşuna basmıyorsun.
709
00:33:33,850 --> 00:33:38,140
Bunun yerine ters eğik çizgi n
koyarsınız ve bu bilgisayara şunu söyler:

710
00:33:38,140 --> 00:33:40,670 imleci
yeni satıra taşımak için.
711
00:33:40.670 --> 00:33:42,177 Yani
yine, biraz şifreli.
712
00:33:42,177 --> 00:33:43,510 Ama
bir kez öğrendikten sonra, o kadar.
713
00:33:43,510 --> 00:33:46,670 Bu
sadece kelime dağarcığımızdaki
başka bir kelime.
714
00:33:46,670 --> 00:33:49,750 Şimdi
programımı biraz daha etkileşimli hale
getirmeme izin verin.
715
00:33:49,750 --> 00:33:51,340
Sadece söylemek yerine
Merhaba dünya, izin ver

Machine Translated by Google
716

00:33:51,340 --> 00:33:53,215
Merhaba, David, demek için geçen
haftaki gibi değiştirin.
717
00:33:53,215 --> 00:33:55,520 veya
programla etkileşimde bulunan kişi.

718
00:33:55,520 --> 00:33:59,050
Bu yüzden string cevap
alacağım, string alacağım,
719
00:33:59,050 --> 00:34:02,455 alıntı
alıntı değil, adın ne.
720
00:34:02,455 --> 00:34:04,330 Burada
yeni bir satırla uğraşmayacağım.

721
00:34:04,330 --> 00:34:04,930
Yapabilirim.
722
00:34:04,930 --> 00:34:06,380 Bu
şimdi sadece bir yargılama çağrısı.
723
00:34:06,380 --> 00:34:09,088
İnsanın kasten adını aynı satıra
yazmasını istiyorum
724
00:34:09,088 --> 00:34:10,150 çünkü.

725
00:34:10,150 --> 00:34:11,990 Bunu
şimdi nasıl yazdırabilirim?
726
00:34:11.990 --> 00:34:14.170 Geçen
hafta dediğimizi hatırlıyoruz.
727
00:34:14.170 --> 00:34:16,450 Ve
sonra join adlı diğer bloğu kullanırız.

728

Machine Translated by Google

00:34:16,450 --> 00:34:18,880 Yani
buradaki fikir aynı.
729
00:34:18,880 --> 00:34:21,380

Ancak bu hafta sözdizimi biraz
farklı olacak.
730
00:34:21,380 --> 00:34:25.070
Ekrana bir şeyler yazdıran printf
olacak.
731
00:34:25.070 --> 00:34:29,290
Devam edip Merhaba virgül
diyeceğim.
732
00:34:29,290 --> 00:34:34,270 Ve
bunu başlangıçta ters eğik çizgi n, noktalı
virgül ile devam edeyim.
733
00:34:34,270 --> 00:34:37,900
Devam edip kodumu yeniden derlememe izin verin.
734
00:34:37,900 --> 00:34:41,492 Hata,
kahretsin hala çalışmıyor.
735
00:34:41,492 --> 00:34:42,700 Ve
tüm bu hatalara bakın.
736
00:34:42,700 --> 00:34:45,640
Yazdığım koddan daha fazla hata var.
737
00:34:45,640 --> 00:34:47,630 Ama
burada neler oluyor?
738
00:34:47,630 --> 00:34:50,080
Şey, bu aslında bir şey,
göreceksin bir hata,
739
00:34:50,080 --> 00:34:52,330 en
azından başlangıçta biraz sık.
740
00:34:52,330 --> 00:34:54,470
Ve toplamaya başlayalım

Machine Translated by Google
Burada neler oluyor.
741
00:34:54,470 --> 00:34:58,120
Yani burada, dolar işaretinden
sonraki ilk çıktı satırına bakarsam-742
00:34:58,120 --> 00:35:01,120 yani
ekrandan oldukça hızlı atlamasına
rağmen,
743
00:35:01,120 --> 00:35:04,030 Dolar
işaretine Make Hello yazdım, istemi.

744
00:35:04,030 --> 00:35:05,560 Ve
işte ilk hata.
745
00:35:05,560 --> 00:35:08,320
Merhaba nokta C, satır 5-746
00:35:08,320 --> 00:35:12,220 teknik
olarak karakter 5, ancak genellikle satır
sizi harekete geçirmek için yeterlidir-747
00:35:12,220 --> 00:35:16,150 bir
hata var, bildirilmemiş tanımlayıcı
dize kullanımı.
748
00:35:16,150 --> 00:35:18,320
Standart olarak mı demek istediniz?
749
00:35:18,320 --> 00:35:19,300 Yani,
yapmadım.
750
00:35:19,300 --> 00:35:21.560 Ve
bu ilk başta bariz bir çözüm değil.

751
00:35:21.560 --> 00:35:25,360 Ancak
hata mesajlarında bu kalıpları
tanımaya başlayacaksınız.
752
00:35:25,360 --> 00:35:30,940

Machine Translated by Google
Görünüşe göre string kullanmak

istiyorsam, aslında bunu yapmak zorundayım.
753
00:35:30,940 --> 00:35:35,079
Buraya başka bir kitaplık eklemeliyim,
başka bir kod satırı,
754
00:35:35,079 --> 00:35:37.660 daha çok
CS50 nokta H olarak adlandırılır. Geri
döneceğiz
755
00:35:37,660 --> 00:35:39,500 bunun
ne anlama geldiğine bir an için.
756
00:35:39,500 --> 00:35:45,760
Ama şimdi geriye dönük olarak şunu
söylersem, tamam, standart G/Ç ne işe yarar?

757
00:35:45,760 --> 00:35:46,869 burada
bizim için yap.
758
00:35:46,869 --> 00:35:50,920 Bu yeni
satırı eklemeden önce, standart G/Ç
ne yapıyor?
759
00:35:50,920 --> 00:35:52,869
Eh, eğer Scratch'e geri
dönerseniz, orada
760
00:35:52,869 --> 00:35:58,960 kamera
ve konuşma ile metinden sese birkaç örnekti.

761
00:35:58,960 --> 00:36:01,480 Unutma,
uzantılar düğmesini kurcalamak zorunda
kaldım.
762
00:36:01,480 --> 00:36:03,309 Sonra
onu Scratch'e yüklemek zorunda kaldım.
763
00:36:03,309 --> 00:36:05,440 Scratch
ile doğal olarak gelmedi.
764

Machine Translated by Google

00:36:05,440 --> 00:36:07,119 C
tam olarak böyle.
765
00:36:07,119 --> 00:36:09,369 Bazı
işlevler dille birlikte gelir.
766
00:36:09,369 --> 00:36:13,360

Ancak çoğunlukla, bir işlev, eylem veya
fiil kullanmak istiyorsanız
767
00:36:13,360 --> 00:36:17,770
printf gibi, tabiri caizse o uzantıyı
yüklemeniz gerekiyor,
768
00:36:17,770 --> 00:36:20.560
buna daha geleneksel olarak
kitaplık denir.
769
00:36:20.560 --> 00:36:26,320
Yani standart bir G/Ç
kitaplığı vardır, STD G/Ç, standart G/Ç,
770
00:36:26,320 --> 00:36:28,550
burada G/Ç sadece giriş ve çıkış anlamına gelir.
771
00:36:28,550 --> 00:36:30,640
Yani, tıpkı MIT'nin
Dünyasında olduğu gibi, orada
772
00:36:30,640 --> 00:36:34,360,
metni sesli olarak yapmak veya
kameranızı kullanmak için bir uzantıydı.
773
00:36:34,360 --> 00:36:36,670 C'de
bir uzantı vardır, namı diğer
774
00:36:36,670 --> 00:36:40,430
standart giriş ve çıkış yapmak için
bir kitaplık.
775
00:36:40,430 --> 00:36:44,650
Yani standart giriş ve çıkışla ilgili herhangi
bir işlevi kullanmak istiyorsanız,

Machine Translated by Google
776

00:36:44,650 --> 00:36:49,330
klavyeden gelen metin gibi, standart
G/Ç noktası eklemeniz gerekir
777
00:36:49,330 --> 00:36:53,560 H. Ve
sonra printf kullanabilir misin?
778
00:36:53,560 --> 00:36:55,090 Aynısı
burada da geçerli.
779
00:36:55,090 --> 00:36:59,890 Get
string, anlaşılan, CS50'nin bir süre
önce yazdığı bir fonksiyon.
780
00:36:59,890 --> 00:37:02,170
Ve önümüzdeki haftalarda
göreceğimiz gibi, sadece
781
00:37:02,170 --> 00:37:05,980 bir
kullanıcıdan girdi almayı çok daha
kolay hale getirir.
782
00:37:05,980 --> 00:37:09,310 C
ekrana çıktı yazdırmada printf ile çok
iyi.
783
00:37:09,310 --> 00:37:12,610
C, birkaç hafta içinde göreceğimiz
gibi, gerçekten sinir bozucu ve zorlaştırıyor,
784
00:37:12,610 --> 00:37:14.390 sadece
kullanıcıdan girdi almak için.
785
00:37:14,390 --> 00:37:17.020
Böylece get_string adında
bir fonksiyon yazdık,
786
00:37:17,020 --> 00:37:20,440 ancak
bunu kullanmanın tek yolu uzantıyı
yüklemektir,
787
00:37:20,440 --> 00:37:23,470 aka
CS50 adlı kitaplığı yükleyin.

Machine Translated by Google
788
00:37:23,470 --> 00:37:27,040 Ve
zamanda geri döneceğiz, örneğin, neden .h,
neden bir karma sembolü.
789
00:37:27,040 --> 00:37:30,490
Ama şimdilik standart
I/O bir kütüphanedir.
790
00:37:30,490 --> 00:37:33,740 printf ve
girdi ve çıktıyla ilgili öğelere erişmenizi
sağlar.
791
00:37:33,740 --> 00:37:36,310
CS50, size aşağıdakileri
sağlayan ikinci bir kitaplıktır.
792
00:37:36,310 --> 00:37:39,640 C ile
gelmeyen işlevlere erişim ile

793
00:37:39,640 --> 00:37:42,700 get_string
gibi bir şey içerir.
794
00:37:42,700 --> 00:37:46,390
Bunu söyledikten sonra,
şimdi biraz dalga geçtik
795
00:37:46,390 --> 00:37:49,370 yüksek
düzeyde 2. ve şimdi 1. satırların ne
yaptığını.
796
00:37:49,370 --> 00:37:51,580 Devam
edeyim ve merhaba yapmak için tekrar çalışayım.
797
00:37:51,580 --> 00:37:52.810 Artık işe
yaradı.
798
00:37:52,810 --> 00:37:56,298
Böylece tüm bu çılgın hata mesajları tek
bir düzeltmeyle çözüldü,
799
00:37:56,298 --> 00:37:58,840

Machine Translated by Google
bu yüzden anahtar paket, sırf
sayı tarafından boğulmamaktır
800
00:37:58,840 --> 00:37:59,780
hata.
801
00:37:59,780 --> 00:38:04,720
Şimdi ./merhaba yapayım ve adımı
yazarsam ne diyeceğim?
802
00:38:07,720 --> 00:38:10.670 Ne
düşünüyorsun?
803
00:38:10,670 --> 00:38:15,290
Evet, merhaba cevap, çünkü
bilgisayar beni kelimenin tam anlamıyla alacak.
804
00:38:15,290 --> 00:38:17,870
Ve eğer sadece
"merhaba" yazarsanız,
805
00:38:17,870 --> 00:38:20.810
cevap" hepsi çift tırnak içinde,
gerçekten sadece geçiyorsun
806
00:38:20.810 --> 00:38:23,750
printf işlevine giriş
olarak İngilizce,
807
00:38:23,750 --> 00:38:25,670
aslında değişkeni geçmiyorsunuz.

808
00:38:25,670 --> 00:38:28,520
Ve ne yazık ki
C, pek öyle değil
809
00:38:28,520 --> 00:38:32.060
Yazdığınız diğer şeylere bir şeyler
eklemek kolaydır.
810
00:38:32.060 --> 00:38:34,310
Scratch'te unutmayın, sadece
Kaydet bloğu yoktu

Machine Translated by Google
811
00:38:34,310 --> 00:38:36,860
ama biraz güzel olan Join bloğu,

812
00:38:36,860 --> 00:38:38,660
elmaları ve portakalları birleştirebilirsiniz-813
00:38:38,660 --> 00:38:40,100
yoksa elma ve muz muydu?
814
00:38:40,100 --> 00:38:43,840
Sonra onu merhaba olarak değiştirdik
ve ardından insanın yazdığı cevap.
815
00:38:43,840 --> 00:38:45,965
C'de sözdizimi biraz farklı olacak.

816
00:38:45,965 --> 00:38:51,050
Bilgisayara, sahip olmak istediğiniz çift
tırnak işaretinin içinde söyleyin.
817
00:38:51,050 --> 00:38:56,390
orada bir yer tutucu, sözde biçim
kodu. %s demek, selam, bilgisayar,
818
00:38:56,390 --> 00:38:59,240
sonunda buraya bir dize koyun.
819
00:38:59,240 --> 00:39:03,860
Sonra alıntılarınızın dışında bir
virgül eklersiniz ve sonra yazarsınız
820
00:39:03,860 --> 00:39:09,620
bilgisayarın bu %s konumuna
takmasını istediğiniz değişkende
821
00:39:09,620 --> 00:39:10.430
sizin için.
822
00:39:10.430 --> 00:39:14.870
Yani %s bir biçim kodudur.

Machine Translated by Google
yer tutucu görevi görür.
823
00:39:14,870 --> 00:39:17,630
Ve şimdi printf işlevi, yıllar
boyunca insanlar tarafından tasarlandı.
824
00:39:17,630 --> 00:39:19,850 önce
elma ve muzun nasıl yapıldığını
bulmak için
825
00:39:19,850 --> 00:39:22,172 iki
kelimeyi birleştirme olayı.
826
00:39:22,172 --> 00:39:24,380
Scratch'teki kadar kullanıcı dostu
değil.
827
00:39:24,380 --> 00:39:26,900 ama
bu çok yaygın bir paradigma.
828
00:39:26,900 --> 00:39:30,080
Şimdi bunu tekrar deneyeyim.
merhaba yap.
829
00:39:30,080 --> 00:39:31,640 Hata
yok, bu iyi.
830
00:39:31,640 --> 00:39:32,720 ./
merhaba.
831
00:39:32,720 --> 00:39:33,830 Adım
ne David?
832
00:39:33,830 --> 00:39:36,980
Şimdi Enter yazarsam merhaba olur.
833
00:39:36,980 --> 00:39:37,550 David.

834
00:39:37,550 --> 00:39:40,010 Ve
printf, işte printf'deki F.
835

Machine Translated by Google

00:39:40,010 --> 00:39:44,780

Gibi şeyler için bu yer tutucuları
kullanarak girdisini sizin için biçimlendirir.
836
00:39:44,780 --> 00:39:49,400
dize, tekrar %s ile temsil edilir.
837
00:39:49,400 --> 00:39:53,850
O zaman hızlı bir soru, eğer burada
bir an için 7. satıra odaklanırsam
838
00:39:53,850 --> 00:40:00,680 ve
hatta burayı yakınlaştırın, printf
fonksiyon olarak kaç girdi alıyor?
839
00:40:00,680 --> 00:40:04,700
Bir an önce, "merhaba, dünya" tek bir
girdi aldığını kabul edeceğim.
840
00:40:04,700 --> 00:40:05,990
alıntı alıntı değil.
841
00:40:05,990 --> 00:40:11,180
printf'in şu anda kaç girdi aldığını
düşünebilirsiniz?
842
00:40:11,180 --> 00:40:11,720 2.

843
00:40:11,720 --> 00:40:16,400
İlkini ayıran bu virgülle ima ediliyor,

844
00:40:16,400 --> 00:40:20,510
alıntı, alıntıyı kaldır, ikincisinden
"merhaba, %s", cevap.
845
00:40:20,510 --> 00:40:23,930 Ve
burada hızlı bir güvenlik kontrolü
olarak neden 3 değil?
846
00:40:23,930 --> 00:40:26,520
Çünkü burada açıkça iki virgül
var.

Machine Translated by Google
847
00:40:26,520 --> 00:40:29,480
Neden aslında 3 argüman veya
girdi değil?
848
00:40:29,480 --> 00:40:33,200
İZLEYİCİ: [DUYULMAZ]
849
00:40:33,200 --> 00:40:34,200
DAVID J. MALAN: Kesinlikle.
850
00:40:34,200 --> 00:40:37,410
Soldaki virgül aslında İngilizce
gramerimin bir parçası.
851
00:40:37,410 --> 00:40:38,893
hepsi bu, yani sözdizimi aynı.
852
00:40:38,893 --> 00:40:41,310
Ve yine, programlamanın
kafa karıştırıcı olabileceği yer burasıdır.
853
00:40:41,310 --> 00:40:44,100
erken çünkü aynı özel noktalama
işaretini
854
00:40:44,100 --> 00:40:46,930
farklı şeyler, sadece bağlama
bağlı.
855
00:40:46,930 --> 00:40:49,170
Ve şimdi aslında belirtmek
için iyi bir zaman
856
00:40:49,170 --> 00:40:52,950
Ekranda beliren güzel renklerin tümü

857
00:40:52,950 --> 00:40:53,490
burada-858
00:40:53,490 --> 00:40:57,240 bir
formata gitmememe rağmen

Machine Translated by Google
menü, bazı şeyleri cesurca yapmıyordum,

859
00:40:57,240 --> 00:41:00,190
Kesinlikle bir şeyleri kırmızıya,
maviye ya da başka bir şeye değiştirmiyordum--

860
00:41:00,190 --> 00:41:05,100 bunun
nedeni, VS Code sözdizimi gibi bir
metin düzenleyicinin sizin için vurgulamasıdır.

861
00:41:05,100 --> 00:41:08,250
Bu, günümüzde pek çok farklı
programlama ortamının bir özelliğidir,
862
00:41:08,250 --> 00:41:09,840 VS
Kodu da bunu yapar.
863
00:41:09,840 --> 00:41:14,220
Metin düzenleyiciniz programlama
yaptığınız dili anlıyorsa-864
00:41:14,220 --> 00:41:15,520
C, bu durumda-865
00:41:15,520 --> 00:41:19,900
kodunuzdaki farklı fikir türlerini farklı
renklerde vurgular.
866
00:41:19,900 --> 00:41:23,070
Örneğin, buradaki string ve
cevap siyahtır,
867
00:41:23,070 --> 00:41:27,027
ancak get_string bu tür kötü
kahverengi-sarı renkte bir işlev
868
00:41:27,027 --> 00:41:29,610 şu
anda burada, ancak ekranda bu
şekilde görüntüleniyor.
869
00:41:29,610 --> 00:41:32,310
Yine de, burada kırmızı olan ip
bana atlıyor,

Machine Translated by Google
870

00:41:32,310 --> 00:41:33,990 ve bu
marjinal olarak faydalıdır.
871
00:41:33,990 --> 00:41:35,313 %s mavi
renktedir.
872
00:41:35,313 --> 00:41:37,480 Bu çok
hoş çünkü üzerime atlıyor.

873
00:41:37,480 --> 00:41:40,800
Ve böylece ekranda farklı şeyler yapmak için
farklı renkler kullanmaktan başka bir şey değil.
874
00:41:40,800 --> 00:41:44,220 pop,
böylece bu fikirlerin birbiriyle nasıl
ilişkili olduğuna odaklanabilirsiniz
875
00:41:44,220 --> 00:41:46,320 ve dürüst
olmak gerekirse, hata yapabileceğiniz
zaman.
876
00:41:46,320 --> 00:41:49,230 Örneğin,
bu alıntıyı yanlışlıkla burada bırakayım.

877
00:41:49,230 --> 00:41:54,210
Ve şimdi aniden, alıntıyı silersem
dikkat edin,
878
00:41:54,210 --> 00:41:56,910 renkler
biraz bozulmaya başlıyor.
879
00:41:56,910 --> 00:42:00,840 Ama
oraya geri dönersem, şimdi her şey eski
haline döner.
880
00:42:00,840 --> 00:42:02,670 Bu metin
düzenleyicinin başka bir özelliği nedir?

881
00:42:02,670 --> 00:42:06,450
İmlecimin sırada ne zaman olduğuna dikkat et

Machine Translated by Google
bu paranteze hangi
882
00:42:06,450 --> 00:42:09,310
fonksiyona girişlerin sonunu
belirler,
883
00:42:09,310 --> 00:42:12,810
Burada yeşil renkle vurgulanan
uyarı, açılış parantezidir.
884
00:42:12,810 --> 00:42:13,350
Neden?
885
00:42:13,350 --> 00:42:15,437
Bu sadece görsel olarak
faydalı bir şey, özellikle
886
00:42:15,437 --> 00:42:17,520 daha
fazla kod yazmaya başlarsınız,

887
00:42:17,520 --> 00:42:19,440
parantezlerinizin hizalandığından emin olun.
888
00:42:19,440 --> 00:42:22,590 Ve
bu soldaki ve sağdaki bu küme
parantezleri için de geçerli.
889
00:42:22,590 --> 00:42:24,210
Bunlara birazdan döneceğiz.
890
00:42:24,210 --> 00:42:28,020
İmlecimi oraya koyarsam, bunların
karşılık geldiğini görebilirsiniz.
891
00:42:28,020 --> 00:42:28,900
birbirine.
892
00:42:28,900 --> 00:42:31,800
Yani temelde kodunuzda hiçbir
şey yok, sadece editör
893
00:42:31,800 --> 00:42:34,110

Machine Translated by Google
size, insana, programa yardım etmeye çalışıyorum.
894
00:42:34,110 --> 00:42:36,450
Hatta biraz incelikli de olsa
görebilirsiniz-895
00:42:36,450 --> 00:42:39,330 Buradaki
dört noktayı ve buradaki dört noktayı
görüyor musunuz?
896
00:42:39,330 --> 00:42:40,890 Bu benim
girintim.
897
00:42:40,890 --> 00:42:44,730
VS Kodunu dört boşlukla girinti
yapacak şekilde yapılandırdım;
898
00:42:44,730 --> 00:42:45,960 çok
yaygın bir gelenektir.
899
00:42:45,960 --> 00:42:49,290
Sekme tuşuna her bastığımda, bu da
emin olmanıza yardımcı olabilir-900
00:42:49,290 --> 00:42:52,140 daha
ilginç ve daha uzun programlarımız
olduğunda-901
00:42:52,140 --> 00:42:55,320 her şey
güzel ve düzgün bir şekilde sıralanıyor.

902
00:42:55,320 --> 00:42:56,580 Vay.

903
00:42:56,580 --> 00:42:58,590 Pekala,
printf veya daha fazlası hakkında
herhangi bir sorunuz var mı?

904
00:42:58,590 --> 00:42:59,852 Evet.

905
00:42:59,852 --> 00:43:02,322

Machine Translated by Google
KİTLE: [? ?] printf
[DUYILMAZ]??
906
00:43:02,322 --> 00:43:04,030
DAVID J. MALAN: Kısa cevap, evet.
baskı
907
00:43:04,030 --> 00:43:07,330
birden fazla değişken veya değer
türünü işleyebilir.
908
00:43:07,330 --> 00:43:08,440 %s
birdir.
909
00:43:08,440 --> 00:43:11,870 Bir
tamsayı girmek için %i'nin bir başka
olduğunu göreceğiz.
910
00:43:11,870 --> 00:43:15,460
Birden çok i'niz, birden çok s'niz ve
hatta başka sembolleriniz de olabilir.
911
00:43:15,460 --> 00:43:17,350
Birazdan buna geri döneceğiz.

912
00:43:17,350 --> 00:43:21,040
printf sadece bu ikisinden çok
daha fazla argüman alabilir.
913
00:43:21,040 --> 00:43:23,350 Bu
sadece temsili amaçlıdır.
914
00:43:23,350 --> 00:43:25,390
Evet, burada.
915
00:43:25,390 --> 00:43:27,400
printf içindeki değişkenleri
bildirebilir misiniz?
916
00:43:27,400 --> 00:43:28,810
Hayır.
917

Machine Translated by Google
00:43:28,810 --> 00:43:30,850
Şu anda kullandığım tek
değişken cevap,
918
00:43:30,850 --> 00:43:34,450 ve bu
durumda printf bağlamı dışında
yapılması gerekiyor.
919
00:43:34,450 --> 00:43:37,510 Güzel
soru, çok geçmeden daha fazlasını
göreceğiz.
920
00:43:37,510 --> 00:43:39,152 Evet,
arkada.
921
00:43:39,152 --> 00:43:40,943
İZLEYİCİ: [DUYULMAZ]
922
00:43:40,943 --> 00:43:43,110 DAVID
J. MALAN: CS50 kitaplığını nasıl
indirebiliriz?
923
00:43:43,110 --> 00:43:46,290 Bu
yüzden size problem seti 1'de bunun
tam olarak nasıl yapılacağını göstereceğiz.
924
00:43:46,290 --> 00:43:49,620 Buluttaki
VS Code versiyonumuzda sizin için
otomatik olarak yapılır.
925
00:43:49,620 --> 00:43:53,010
Sonunda, kendi başınıza programlarsanız
Mac veya PC, başlangıçta veya daha sonra
926
00:43:53,010 --> 00:43:54,900
tarihinde, çevrimiçi olarak da kurulabilir.
927
00:43:54,900 --> 00:43:58,273
Ama bunu internetten veya daha
sonra sormak isterseniz,
928
00:43:58,273 --> 00:43:59,940 sizi
doğru yöne yönlendirebiliriz.

Machine Translated by Google
929

00:43:59,940 --> 00:44:01,590 Ancak
PSet 1 kendisi yapacak.
930
00:44:01,590 --> 00:44:02,431 Evet.

931
00:44:02,431 --> 00:44:04,540
İZLEYİCİ: [DUYULMAZ]
932
00:44:04,540 --> 00:44:08,170 DAVID
J. MALAN: Dize, değişkenin türüdür veya
daha doğrusu,
933
00:44:08,170 --> 00:44:10,300
değişkenin veri türü.
934
00:44:10,300 --> 00:44:13,480 int
daha önce bahsettiğim başka bir
anahtar kelimedir, henüz kullanmadım.
935
00:44:13,480 --> 00:44:17,390 int,
tamsayı için, değişkenin başka bir
türü veya veri türü olacaktır.
936
00:44:17,390 --> 00:44:18,640
İZLEYİCİ: Tamam. [? Teşekkürler. ?]
937
00:44:18,640 --> 00:44:19,515
DAVID J. MALAN: Evet.
938
00:44:19,515 --> 00:44:20.890
İZLEYİCİ: [DUYULMAZ]
939
00:44:20.890 --> 00:44:22,307
DAVID J. MALAN: Oh, güzel soru.
940
00:44:22,307 --> 00:44:26,170
Devam edip bu işlevi takabilir
miyim?
941
00:44:26,170 --> 00:44:30,460
Scratch'te yaptığımız gibi,

Machine Translated by Google
değişkenden tamamen kurtulmak
942
00:44:30,460 --> 00:44:33,670 ve
sadece şunu yapın, hatırlatan şey,
neyi anımsatır
943
00:44:33,670 --> 00:44:37,120
Scratch'te bloğu blok üzerine blok
üstüne koyarak mı yaptım?
944
00:44:37,120 --> 00:44:39,470 Bunu
doğru mu yanıtlıyorum?
945
00:44:39,470 --> 00:44:41.430
get_string'in önüne string koyabilir miyim?
946
00:44:41.430 --> 00:44:41.930 Hayır.

947
00:44:41,930 --> 00:44:44,900
Kelime dizesini yalnızca bir
değişkenin önüne koyarsınız
948
00:44:44,900 --> 00:44:46,400 dize
yapmak istediğiniz.
949
00:44:46,400 --> 00:44:49,070
Ve görünüşe göre yanlış soruyu
cevaplıyor olsam da,
950
00:44:49.070 --> 00:44:52.910 devam
edip uzaklaştırmama izin verin,
bunu kaydedin, tekrar merhaba yapın.
951
00:44:52,910 --> 00:44:54,650
Derleme tamam gibi görünüyor.
952
00:44:54,650 --> 00:44:57,380 ./
hello'yu çalıştırırsam, David yazın, işte.
953
00:44:57,380 --> 00:44:58,650 Bu da
işe yarıyor.

Machine Translated by Google
954

00:44:58,650 --> 00:45:01,590 Ve
aslında, bir anlığına bu tavşan
deliğinden aşağı inelim.
955
00:45:01,590 --> 00:45:03,410
Açıkçası, hala doğru...
956
00:45:03,410 --> 00:45:05,810, en
azından sınırlı testlerime dayanarak.
957
00:45:05,810 --> 00:45:09,200 Bu daha
mı iyi tasarlanmış yoksa daha mı kötü
tasarlanmış?
958
00:45:09,200 --> 00:45:11,330 Bu
soruyu geçen hafta yaptığımız gibi
açalım.
959
00:45:11,330 --> 00:45:12,680 Evet?

960
00:45:12,680 --> 00:45:15,020 Evet,
buna biraz katılıyorum.
961
00:45:15,020 --> 00:45:17,210
Makul insanlar aynı fikirde
olmayabilir, ama ben
962
00:45:17,210 --> 00:45:21,170 bunun
okunmasının daha zor göründüğüne
katılıyorum çünkü burada okumaya başlıyorum,

963
00:45:21,170 --> 00:45:23,637 ama bir
dakika bekleyin. get_string önce
alışacak,
964
00:45:23,637 --> 00:45:25,470 ve sonra
bana bir değer verecek.

965
00:45:25,470 --> 00:45:28,700
Yani, evet, yukarıdan aşağıya
okumak daha hoşmuş gibi geldi,

Machine Translated by Google
966
00:45:28,700 --> 00:45:29,360
diyebilirim.
967
00:45:29,360 --> 00:45:29,990
Düşünceleriniz?
968
00:45:29,990 --> 00:45:30,940
İZLEYİCİ: [DUYULMAZ]
969
00:45:30,940 --> 00:45:31,815
DAVID J. MALAN: Evet.
970
00:45:31,815 --> 00:45:35,810 Bu,
kişinin adını yalnızca bir kez yazdırmak
istiyorsam kullanışlıdır.
971
00:45:35,810 --> 00:45:38,973
Daha sonra daha uzun bir
programda kullanmak istersem, şansım kalmadı,

972
00:45:38,973 --> 00:45:40,640 ve
bu yüzden onu bir değişkene kaydetmedim.
973
00:45:40,640 --> 00:45:44,240 Yani,
uzun lafın kısası, bunu bütün gün
tartışabiliriz.
974
00:45:44,240 --> 00:45:47,350
Ama bu durumda, eh, eğer makul
bir argüman sunabilirseniz
975
00:45:47,350 --> 00:45:50,440 ya
da diğer, üzerinde durmak için
oldukça sağlam bir zemin.
976
00:45:50,440 --> 00:45:52,300
Ancak, her zaman,
makul insanlar gidiyor
977
00:45:52,300 --> 00:45:56,840, ilk
kez programcılar mı yoksa ondan
yıllar sonra mı katılmıyorum.

Machine Translated by Google
978
00:45:56,840 --> 00:46:00,940
Şimdi bu son örneği aynı süreç
bağlamında çerçeveleyelim.
979
00:46:00,940 --> 00:46:02,580 giriş
çıkış alma.
980
00:46:02,580 --> 00:46:04,330
Bahsettiğimiz işlevler

981
00:46:04,330 --> 00:46:08,920
girdileri alır, aksi halde artık argümanlar
veya parametreler olarak bilinir, hemen hemen
982
00:46:08,920 --> 00:46:09,730
eşanlamlı.
983
00:46:09,730 --> 00:46:12,940 Bu
sadece bir fonksiyona giriş için
süslü kelime.
984
00:46:12,940 --> 00:46:16,245
Ve bazı işlevlerin yan etkileri de var,
gördüğümüz gibi-985
00:46:16,245 --> 00:46:18,370 bir
şey yazdırıyor, ekranda bir şey
söylüyor,
986
00:46:18,370 --> 00:46:20,110
görsel veya işitsel olarak-987
00:46:20,110 --> 00:46:25,120 veya
ad veya yanıt gibi yeniden
kullanılabilir bir değer olan bir değer döndürürler,
988
00:46:25,120 --> 00:46:26,450 bu
durumda.
989
00:46:26,450 --> 00:46:30,460
En son ne yaptığımıza bakarsak

Machine Translated by Google
geçen hafta Scratch dünyasında geçen zaman,

990
00:46:30,460 --> 00:46:33.010
giriş, adınız ne idi, fonksiyon
soruyordu,
991
00:46:33.010 --> 00:46:35,980
ve dönüş değeri yanıtlandı.
992
00:46:35,980 --> 00:46:40,720
Şimdi dürüstçe daha kullanıcı dostu
olan bu bloğa bir göz atalım.
993
00:46:40,720 --> 00:46:42,466
%s ile yaptığımızın versiyonu.
994
00:46:42,466 --> 00:46:46,120 Geçen
hafta kaydet dedik, sonra katıl,
sonra merhaba ve cevapla dedik.

995
00:46:46,120 --> 00:46:49,780
Ama oradaki ilginç paket, nasıl
merhaba diyeceğimiz değildi.
996
00:46:49,780 --> 00:46:54,220
Scratch 2'de bir fonksiyonun
çıktısının,
997
00:46:54,220 --> 00:46:59,350
yeşil birleştirme gibi, başka bir
işlevin girdisi olabilir,
998
00:46:59,350 --> 00:47:00,700
mor diyor.
999
00:47:00,700 --> 00:47:03,670
C'deki sözdizimi
kuşkusuz oldukça farklıdır,
1000
00:47:03,670 --> 00:47:05,680
ama fikir aslında aynı.
1001
00:47:05,680 --> 00:47:09,580

Machine Translated by Google
Burada, yine de, merhaba,
bir yer tutucumuz var,
1002
00:47:09,580 --> 00:47:13.090 ama
bu C dünyasında şunu söylemeliyiz
printf
1003
00:47:13,090 --> 00:47:16,310 bu
yer tutucu için eklemek istediğimiz
şey.
1004
00:47:16,310 --> 00:47:17,180
Sadece farklı.
1005
00:47:17,180 --> 00:47:18,347 Ama
bunu yapmanın yolu bu.
1006
00:47:18,347 --> 00:47:20.890
Dönemin ilerleyen kısımlarında Python
ve diğer dillere geldiğimizde,
1007
00:47:20.890 --> 00:47:22,720 Bunu
yapmanın aslında daha kolay yolları var.
1008
00:47:22,720 --> 00:47:25,510
Ancak bu çok yaygın bir
paradigmadır, özellikle
1009
00:47:25,510 --> 00:47:28,690
verilerinizi bir şekilde biçimlendirmek
istiyorsunuz.
1010
00:47:28,690 --> 00:47:31,250
Pekala, o zaman başladığımız
yere bir adım geri gidelim,
1011
00:47:31,250 --> 00:47:34,900 tüm
programla birlikteydi,

1012
00:47:34,900 --> 00:47:38,830 ve int
main(void) ve tüm bu diğer şifreli
sözdizimine sahipti.

Machine Translated by Google
1013

00:47:38,830 --> 00:47:42,550
Geçen haftaki bu Scratch
parçası, gidilecek yer gibiydi.
1014
00:47:42,550 --> 00:47:45,068
programınızın ana parçası olmak
istediğinizde.
1015
00:47:45,068 --> 00:47:47,110 Bir
Scratch programını başlatmanın
tek yolu bu değildir.
1016
00:47:47,110 --> 00:47:50,380
Yalnızca yeşil bayrağı değil, tıklamaları
veya başka şeyleri de dinleyebilirsiniz.
1017
00:47:50,380 --> 00:47:55,030 Ama
burası muhtemelen Scratch'te bir program
başlatmak için en popüler yerdi.
1018
00:47:55,030 --> 00:47:58,678 C'de
en yakın analog bunu tam
anlamıyla yazmaktır.
1019
00:47:58,678 --> 00:48:01,720
Yani tıpkı geçen hafta olduğu gibi,
eğer sürükleyip bırakma alışkanlığınız olsaydı
1020
00:48:01,720 --> 00:48:04,300 C
programcısı olarak yeşil bayrak
tıklandığında,
1021
00:48:04,300 --> 00:48:06,970 Boş
bir dosya oluşturduktan sonra
yapacağınız ilk şey,
1022
00:48:06,970 --> 00:48:09,820
merhaba.c ile yaptığım gibi,
muhtemelen int yazardınız
1023
00:48:09,820 --> 00:48:13,240
main(void) açık kaşlı ayraç, kapalı
kaşlı ayraç,

Machine Translated by Google
1024

00:48:13,240 --> 00:48:17,300 ve
ardından tüm kodunuzu bu küme
parantezlerinin içine koyabilirsiniz.
1025
00:48:17,300 --> 00:48:20.410
Yani Scratch'in bu tür bir
manyetik doğası olduğu gibi
1026
00:48:20,410 --> 00:48:24,730 yapboz
parçalarının birleşeceği yere, metin tabanlı bir
dil olarak C,
1027
00:48:24,730 --> 00:48:29,440 biri açık
diğeri kapalı bu küme parantezlerini
kullanma eğilimindedir.
1028
00:48:29,440 --> 00:48:32,680
Ve bu diş tellerinin içindeki
herhangi bir şey, tabiri caizse,
1029
00:48:32,680 --> 00:48:35,770 bu
yapboz parçasının bir parçasıdır, namı diğer
1030
00:48:35,770 --> 00:48:37.090 ana.

1031
00:48:37.090 --> 00:48:38,650 Peki
onların tepesinde ne vardı?
1032
00:48:38,650 --> 00:48:42,040
Bu tavşan deliğinden bir an önce başlık dosyaları
denen şeylerle aşağı indik,
1033
00:48:42,040 --> 00:48:43,873 onlara
bu isimle hitap etmeme rağmen.

1034
00:48:43,873 --> 00:48:48,055 Ama
gerçekten de, Scratch'te bütün bir
programımız olduğunda, süper kolay.
1035
00:48:48,055 --> 00:48:50,680
Sadece bir yeşil bayrağa sahip ol

Machine Translated by Google
tıkla ve sonra merhaba de, dünya.
1036
00:48:50,680 --> 00:48:51,880 Özel
bir sözdizimi yoktur.
1037
00:48:51,880 --> 00:48:54,550
Sonuçta, çok kullanıcı dostu ve
grafiksel olması gerekiyordu.
1038
00:48:54,550 --> 00:49:00,730 C'de
teknik olarak int main(void) printf merhaba,
world yazamazsınız.
1039
00:49:00,730 --> 00:49:01,900 Buna
da ihtiyacınız var.
1040
00:49:01,900 --> 00:49:07,540
Çünkü yine derleyiciye kitaplığı
yüklemesini söylemelisiniz-1041
00:49:07,540 --> 00:49:13,240 başka
birinin yazdığı kod-- böylece derleyici printf'in
ne olduğunu bile bilir.
1042
00:49:13,240 --> 00:49:16,180
yüklemek zorundasın
CS50 kitaplığı her zaman
1043
00:49:16,180 --> 00:49:19,480
get_string veya get_int gibi diğer
işlevleri kullanmak istiyorsunuz,
1044
00:49:19,480 --> 00:49:20.830
yakında göreceğimiz gibi.
1045
00:49:20.830 --> 00:49:23,890 Aksi
takdirde, derleyici get_string'in ne
olduğunu bilemez.
1046
00:49:23,890 --> 00:49:26,210 Bunu
bu şekilde yapmanız yeterlidir.
1047
00:49:26,210 --> 00:49:28,540

Machine Translated by Google
Belirli dosya adı
burdan bahsediyorum,
1048
00:49:28,540 --> 00:49:35,510
stdio.h, cs50.h, C programcılarının başlık
dosyası olarak adlandırdıkları şeydir.
1049
00:49:35,510 --> 00:49:38,030
Sonunda bu dosyaların içinde ne
olduğunu göreceğiz.
1050
00:49:38,030 --> 00:49:42,260
Ancak uzun lafın kısası, mevcut tüm
fonksiyonların bir menüsü gibidir.
1051
00:49:42,260 --> 00:49:45,760 Yani
cs50.h'de get_string, get_int,

1052
00:49:45,760 --> 00:49:47,350 ve
bir sürü başka şey.
1053
00:49:47,350 --> 00:49:52.990 Ve
stdio.h'de, aralarında printf de
bulunan bir işlevler menüsü vardır.
1054
00:49:52,990 --> 00:49:55,840
Ve bu menü derleyiciyi
hazırlayan şeydir.
1055
00:49:55,840 --> 00:50:00,145 aynı
işlevlerin nasıl uygulanacağını
bilmek.
1056
00:50:00,145 --> 00:50:01,510
Pekala, burada biraz ara vereyim.
1057
00:50:01,510 --> 00:50:02,571 Soru.

1058
00:50:02,571 --> 00:50:07,077
İZLEYİCİ: [DUYULMAZ]
1059

Machine Translated by Google

00:50:07,077 --> 00:50:08,160 DAVID

J. MALAN: Pek sayılmaz.
1060
00:50:08,160 --> 00:50:11,760 Bir
kitaplık, bahsettiğimiz tüm işlevleri
sağlar.
1061
00:50:11,760 --> 00:50:16,920 Bir
başlık dosyası, onu dahil ettiğiniz çok
özel mekanizmadır.
1062
00:50:16,920 --> 00:50:18,970 Ve
bunu gelecek hafta daha fazla tartışacağız.
1063
00:50:18,970 --> 00:50:21,360
Şimdilik, temelde aynılar, ancak
tartışacağız
1064
00:50:21,360 --> 00:50:24.000 nüans
önümüzdeki hafta ikisi arasında.
1065
00:50:24.000 --> 00:50:27,660 Evet,
kitaplık standart G/Ç olacaktır. Kütüphane
CS50 olur.
1066
00:50:27,660 --> 00:50:32.920
Karşılık gelen başlık dosyası stdio.h,
cs50.h'dir.
1067
00:50:32,920 --> 00:50:33,420
Gerçekten de.
1068
00:50:33,420 --> 00:50:34,140 Diğer
sorular.
1069
00:50:34,140 --> 00:50:34,876 Evet.

1070
00:50:34,876 --> 00:50:37,060
İZLEYİCİ: [DUYULMAZ]
1071
00:50:37,060 --> 00:50:38,090 DAVID
J. MALAN: Gerçekten.

Machine Translated by Google
1072
00:50:38,090 --> 00:50:39,280 Bu
da menüde.
1073
00:50:39,280 --> 00:50:40,280
Buna geri döneceğiz.
1074
00:50:40,280 --> 00:50:41,680
Ama kelime dizisi-1075
00:50:41,680 --> 00:50:45,430
programlama dünyasında inanılmaz
derecede yaygın, bu bir CS50 fikri değil-1076
00:50:45,430 --> 00:50:50,500
ama C'de teknik olarak varsayılan
olarak string diye bir veri tipi yoktur.
1077
00:50:50,500 --> 00:50:53,415 İlk
birkaç haftayı basitleştirmek için
bir nevi uydurduk.
1078
00:50:53,415 --> 00:50:56,290
Bu, birkaç hafta içinde çok kasıtlı
olarak yapacağımız bir eğitim çarkı.
1079
00:50:56,290 --> 00:51:00,610 alıp
götürün ve neden get_string ve string
kullandığımızı göreceğiz.
1080
00:51:00,610 --> 00:51:05,360
Aksi takdirde C, işleri erkenden
oldukça zorlaştırdığı için,
1081
00:51:05,360 --> 00:51:07,390 bu
da bizim için asıl noktayı aşıyor.

1082
00:51:07,390 --> 00:51:08,656 Evet.

1083
00:51:08,656 --> 00:51:10.937
İZLEYİCİ: [DUYULMAZ]

Machine Translated by Google
1084
00:51:10.937 --> 00:51:11.770 DAVID
J. MALAN: Evet.
1085
00:51:11,770 --> 00:51:14,680
Başlangıçta, spesifikasyonda ne yazıyorsa onu
kullanmanız gerekecek.
1086
00:51:14,680 --> 00:51:16,150 Bu,
CS50'nin işlevlerini içerecektir.
1087
00:51:16,150 --> 00:51:19,390
Uzun lafın kısası, sanırım bir an önce
başka bir işleve atıfta bulundunuz.
1088
00:51:19,390 --> 00:51:22,180 scanf
denir, birkaç hafta konuşmayacağız.

1089
00:51:22,180 --> 00:51:27,910 Uzun
lafın kısası, C'de bir kullanıcıdan girdi almak
oldukça kolay ve mümkündür.
1090
00:51:27,910 --> 00:51:31,510 İşin püf
noktası, bunu tehlikeli bir şekilde
yapmanın gerçekten kolay olmasıdır.

1091
00:51:31,510 --> 00:51:36,310
Ve C, çünkü daha eski, daha
düşük seviyeli bir dil, tabiri caizse,
1092
00:51:36,310 --> 00:51:40,630 bu,
bilgisayarınızın donanımı üzerinde hemen
hemen tam kontrol sağlar.
1093
00:51:40.630 --> 00:51:42,820 Hata
yapmak çok kolaydır.
1094
00:51:42,820 --> 00:51:46,300
Ve gerçekten de bu yüzden
kütüphaneyi kullanıyoruz,
1095
00:51:46,300 --> 00:51:49,740

Machine Translated by Google
böylece kodunuz istenmeden çökmez.
1096
00:51:49,740 --> 00:51:52,820
Pekala, bunu göz önünde
bulundurarak, şimdi bu haritalamamız var.
1097
00:51:52.820 --> 00:51:54,570 Scratch
versiyonu ile diğeri arasında.

1098
00:51:54,570 --> 00:51:57,737
Size diğer yer tutuculardan ve verilerden
bazılarına hızlı bir tur atmama izin verin
1099
00:51:57,737 --> 00:52:01,440 daha
ilginç programlar bir araya getirdikçe
öğrencilerin görmeye başlayacağı türler.
1100
00:52:01,440 --> 00:52:04,710
Linux dünyasında, işte kapsamlı
olmayan bir liste
1101
00:52:04,710 --> 00:52:08,010
önümüzdeki birkaç hafta içinde aşina
olacağınız komutlar
1102
00:52:08,010 --> 00:52:09,240 problem
setleri ile oynayarak.
1103
00:52:09,240 --> 00:52:13,983 Şu ana
kadar bunlardan sadece ikisini gördük,
liste için ls, diğerleri için rm.
1104
00:52:13,983 --> 00:52:15,900
Ama şimdi onlardan
bahsediyorum ki, öyle olmasın.
1105
00:52:15,900 --> 00:52:21.540 onları
ekranda veya çevrimiçi bir problem setinde
gördüğünüzde kendinizi çok yabancı hissedin.
1106
00:52:21.540 --> 00:52:23,610 cp kopya
anlamına gelecek.

Machine Translated by Google
1107

00:52:23,610 --> 00:52:26,910
mkdir make dizini için kullanılacak.
mv
1108
00:52:26,910 --> 00:52:29,670 taşıma
veya yeniden adlandırma için geçerli olacak.

1109
00:52:29,670 --> 00:52:35,670
rmdir dizini kaldırılacak ve cd değişiklik
için olacak /
1110
00:52:35,670 --> 00:52:38,160 ve
önce size bu sonuncuyu göstereyim,

1111
00:52:38,160 --> 00:52:40,710
sadece çok sık kullanacağınız bir
şey olduğu için.
1112
00:52:40,710 --> 00:52:44,880
Ekrandaki koduma geri dönersem,
devam edeceğim
1113
00:52:44,880 --> 00:52:49,290 ve
sol taraftaki küçük GUI'yi yeniden
açın, sözde Explorer,
1114
00:52:49,290 --> 00:52:52,650 iki
dosyam olduğunu gösteriyor,
merhaba ve merhaba.c
1115
00:52:52,650 --> 00:52:54,150 yani
o zamandan beri hiçbir şey değişmedi.
1116
00:52:54,150 --> 00:52:57.000
Şimdi derse birkaç
hafta kaldığını varsayalım.
1117
00:52:57.000 --> 00:52:58,860 ve
ben kodu düzenlemeye başlamak
istiyorum
1118
00:52:58,860 --> 00:53:01,710

Machine Translated by Google
bu hafta veya gelecek hafta için bir
klasörüm olsun diye yazıyorum,
1119
00:53:01,710 --> 00:53:04,620 veya
problem seti 1, problem seti 2 için
bir klasör olabilir.
1120
00:53:04,620 --> 00:53:06,330 Bunu
birkaç şekilde yapabilirim.
1121
00:53:06,330 --> 00:53:09,390
GUI'de, buraya gidebilir ve
çoğunuzun yaptığını yapabilirim.
1122
00:53:09,390 --> 00:53:11,160 Mac
veya PC'de içgüdüsel olarak işe yarar.
1123
00:53:11,160 --> 00:53:13,650
Bir klasör simgesi gibi
ararsınız, tıklarsınız,
1124
00:53:13,650 --> 00:53:17,160 ve
ardından PSet1, Enter gibi bir klasöre
isim verin.
1125
00:53:17,160 --> 00:53:19,890 İşte,
PSet1 adında bir klasörünüz var.
1126
00:53:19,890 --> 00:53:25,900 Hangi
komutu yazarak komut satırı arayüzümle bu
kadarını onaylayabilirim?
1127
00:53:25,900 --> 00:53:28,090
Klasörümdekileri nasıl listeleyebilirim?
1128
00:53:28,090 --> 00:53:29,590 Evet,
liste için ls.
1129
00:53:29,590 --> 00:53:30,703
Ve şimdi merhaba görüyorum--

1130
00:53:30,703 --> 00:53:32,620 ve yeşil

Machine Translated by Google
yıldız işareti çünkü bu
1131
00:53:32,620 --> 00:53:34,780
çalıştırılabilir, çalıştırılabilir programım-1132
00:53:34,780 --> 00:53:37,900 kaynak
kodum olan merhaba.c ve şimdi eğik
çizgi ile PSet1
1133
00:53:37,900 --> 00:53:41,230 sonunda,
bu onun gerçekten bir klasör olduğu
anlamına gelir.
1134
00:53:41,230 --> 00:53:43,520 Pekala,
gerçekten bu şekilde yapmak
istemedim.
1135
00:53:43,520 --> 00:53:45,070 Bunu
daha ileri düzeyde yapmak istiyorum.
1136
00:53:45,070 --> 00:53:48,730 Şimdi
devam edeyim ve PSet1'e sağ tıklayın,
kalıcı olarak silin.
1137
00:53:48,730 --> 00:53:50,910 Geri
dönüşü olmayan korkunç bir hata
mesajı alıyorum.
1138
00:53:50,910 --> 00:53:52.660 Ama
içinde hiçbir şey yok, yani sorun değil.

1139
00:53:52,660 --> 00:53:54,760 Şimdi
GUI kullanarak sildim.
1140
00:53:54,760 --> 00:54:000,050 Ama
şimdi devam edeyim ve aynı şeyi komut satırından
yapmaya başlayayım.
1141
00:54:000,050 --> 00:54:02,260
Ve işlerin nasıl ortadan kaybolduğunu
merak ediyorsanız,
1142

Machine Translated by Google
00:54:02,260 --> 00:54:06,490

Terminal pencerenizde Control-L'ye
basarsanız veya açıkça clear yazarsanız,
1143
00:54:06,490 --> 00:54:09,670
sadece bir şeyleri temizlemek için daha önce
yazdığınız her şeyi siler.
1144
00:54:09,670 --> 00:54:11.795
Pratikte bunu sık sık yapmanıza
gerek yok.
1145
00:54:11,795 --> 00:54:14.680
Sadece son komutlarıma
odaklanmak için yapıyorum.
1146
00:54:14,680 --> 00:54:18,162
Yaparsam-- yeni bir dizin oluşturma
komutu neydi?
1147
00:54:18,162 --> 00:54:19,520
İZLEYİCİ: [DUYULMAZ]
1148
00:54:19,520 --> 00:54:21.740 DAVID
J. MALAN: Evet, yani mkdir, dizin
oluştur.
1149
00:54:21,740 --> 00:54:23,450 PSet1'i
oluşturmama izin verin, Girin.
1150
00:54:23,450 --> 00:54:25,820 Ve
soldaki dikkat edin, benim PSet1'im var.
1151
00:54:25,820 --> 00:54:28,410
Biraz fazla heveslenmek
istersem, gelecek haftayı planla,
1152
00:54:28,410 --> 00:54:30,320 işte
benim PSet2 dizinim.
1153
00:54:30,320 --> 00:54:35,922
Şimdi bu klasörleri bir Mac veya PC'de
veya bu GUI'de açmak istediğimi varsayalım.

Machine Translated by Google
1154

00:54:35,922 --> 00:54:37,880
Bunun üzerine çift
tıklayabilirdim ve sen
1155
00:54:37,880 --> 00:54:39,607 bu
küçük okun hareket ettiğini görün.
1156
00:54:39,607 --> 00:54:42.690 Hiçbir
şey yapmıyor çünkü orada hiçbir şey yok,
ama sorun değil.
1157
00:54:42,690 --> 00:54:46,250 Ama
yine de komut satırımda daha rahat olmak
istediğimi varsayalım.
1158
00:54:46,250 --> 00:54:50,330 Şimdi
ls yazarsam, dört şeyi de aynı
şekilde görüyorum.
1159
00:54:50,330 --> 00:54:57.020
Dizinleri cd alanı ile değiştirmeme
izin ver PSet1 Enter.
1160
00:54:57,020 --> 00:54:59,660 Ve
şimdi iki şeyin gerçekleştiğine
dikkat edin.
1161
00:54:59,660 --> 00:55:05,270
Birincisi, uyarım nerede olduğumu
hatırlatmak için biraz değişti,
1162
00:55:05,270 --> 00:55:08,930
sadece aklımı başımda tutmak için
aslında hangi klasörde olduğumu unutmayayım.
1163
00:55:08,930 --> 00:55:12,810 İşte
şu anda hangi klasörde olduğumun
görsel bir hatırlatıcısı.
1164
00:55:12,810 --> 00:55:18,110 Şimdi
ls yazarsam Enter'a bastıktan sonra
ne görmeliyim?
1165

Machine Translated by Google

00:55:18,110 --> 00:55:20.790 Hiçbir

şey, çünkü şimdiye kadar yalnızca boş
klasörler oluşturdum.
1166
00:55:20.790 --> 00:55:22,250 Ve
gerçekten de hiçbir şey görmüyorum.
1167
00:55:22,250 --> 00:55:26,690
adlı bir klasör oluşturmak isteseydim
Mario olabilecek bir program için
1168
00:55:26,690 --> 00:55:29,090 bu hafta
Mario'yu aradı, bunu yapabilirim.
1169
00:55:29,090 --> 00:55:31,730 Şimdi ls
yazarsam Mario var.
1170
00:55:31,730 --> 00:55:34,070
Şimdi Mario'yu cd
yaparsam, istemimin gittiğini fark edin
1171
00:55:34,070 --> 00:55:35,720 biraz
daha kesin olarak değiştirmek için.
1172
00:55:35,720 --> 00:55:38,390 Şimdi
PSet1/Mario'dayım.
1173
00:55:38,390 --> 00:55:40,250 Ve sol
üstte neler olduğuna dikkat edin.
1174
00:55:40,250 --> 00:55:42,350 Bu
klasörler daraltıldığı için şimdi hiçbir
şey yok.
1175
00:55:42,350 --> 00:55:45.590 Ama
küçük üçgene tıklarsam orada
Mario'yu görüyorum.
1176
00:55:45,590 --> 00:55:48,110 Orada
hiçbir şey olmuyor çünkü henüz
dosya yok.
1177
00:55:48,110 --> 00:55:52.010

Machine Translated by Google
Ama şimdi mario.c adında bir
dosya oluşturmak istediğimi varsayalım.

1178
00:55:52.010 --> 00:55:55,970 Buraya
gidebilirim, küçük artı simgesine
tıklayabilir ve GUI'yi kullanabilirim.
1179
00:55:55,970 --> 00:55:58,790 Veya
mario.c kodunu yazabilirim.
1180
00:55:58,790 --> 00:55:59,420 İşte.

1181
00:55:59,420 --> 00:56:01,282 Bu
benim için yeni bir sekme oluşturuyor.
1182
00:56:01,282 --> 00:56:04,490 Buraya
henüz kod yazmayacağım ama dosyayı
kaydedeceğim.
1183
00:56:04,490 --> 00:56:08,150 Ve
şimdi sol üstte mario.c'nin
göründüğünü göreceksiniz.
1184
00:56:08,150 --> 00:56:10.692
Böylece bir noktada, sonunda
Explorer'ı kapatabilirsiniz.
1185
00:56:10.692 --> 00:56:13,358 Çünkü
yine size yeni bir bilgi sağlamıyor.

1186
00:56:13,358 --> 00:56:15,170
Belki daha kullanıcı
dostudur, ancak
1187
00:56:15,170 --> 00:56:19,160 GUI
ile yapabileceğiniz komut satırında
yapamayacağınız hiçbir şey.
1188
00:56:19,160 --> 00:56:21,080
Tamam, ama şimdi biraz sıkışıp kaldım.
1189

Machine Translated by Google
00:56:21,080 --> 00:56:23,420 Bu
klasörden nasıl çıkarım?
1190
00:56:23,420 --> 00:56:25,220
Mac veya PC dünyamda,
muhtemelen tıklardım

1191
00:56:25,220 --> 00:56:28,520 Geri
düğmesi veya bunun gibi bir şey ya da sadece
kapatın ve baştan başlayın.
1192
00:56:28,520 --> 00:56:33,380 Terminal
penceresinde cd dot dot yapabilirim.

1193
00:56:33,380 --> 00:56:37,850 Nokta
nokta, isterseniz üst dizin için bir
takma addır.
1194
00:56:37,850 --> 00:56:39,300 Yani
önceki dizin.
1195
00:56:39,300 --> 00:56:43,800
Şimdi Enter'a basarsam, Mario
klasörünü kapatacağıma dikkat edin,
1196
00:56:43,800 --> 00:56:47,330 aka
dizin ve şimdi PSet1'e geri döndüm.

1197
00:56:47,330 --> 00:56:51,440 Veya
havalı olmak istiyorsam geçici olarak
Mario'ya geri döneyim.
1198
00:56:51,440 --> 00:56:54,500 Eğer ls
yazarsam, sadece bizi yönlendirmek
için mario.c var.
1199
00:56:54,500 --> 00:56:57,658 Aynı
anda birden fazla şey yapmak
istersem cd../.. yapabilirim.
1200
00:57:00,470 --> 00:57:04,220
ebeveynime gidiyor

Machine Translated by Google
büyükbaba hepsi bir nefeste.
1201
00:57:04,220 --> 00:57:07,740 Ve
işte, şimdi varsayılan klasörüme geri
döndüm, eğer istersen.
1202
00:57:07,740 --> 00:57:12,110
Ve eğer benim gibi PSet1/
Mario'daysam, ticaretin son bir küçük numarası
1203
00:57:12,110 --> 00:57:15,380 bir an
önceydi ve tüm navigasyonlardan
bıktınız,
1204
00:57:15,380 --> 00:57:18,080 cd
yazıp Enter'a basarsanız sizi çakar

1205
00:57:18.080 --> 00:57:20,270
varsayılan klasörünüze geri dönün
ve
1206
00:57:20,270 --> 00:57:22,520 oraya
manuel olarak gitme konusunda endişelenmek için.

1207
00:57:22,520 --> 00:57:29,720 Biraz
önce merhaba, ./hello olarak
koştuğumu hatırlayın.
1208
00:57:29,720 --> 00:57:33,950
Nokta benim ebeveynime atıfta
bulunuyorsa, belki buradan sözdizimsel olarak çıkarsama yapın,

1209
00:57:33,950 --> 00:57:37,920 bunun
yerine tek bir nokta ne anlama geliyor?
1210
00:57:37,920 --> 00:57:40,680 Bu
dizin, mevcut dizininiz anlamına
gelir.
1211
00:57:40,680 --> 00:57:42,100 Bu
neden gerekli?
1212

Machine Translated by Google
00:57:42,100 --> 00:57:44,192
Sadece bilgisayara
süper açık hale getirir
1213
00:57:44,192 --> 00:57:46,650
Burada yüklenen merhaba adlı
programı istiyorum,
1214
00:57:46,650 --> 00:57:50,700
sabit diskimdeki rastgele başka bir
klasörde değil, tabiri caizse.
1215
00:57:50,700 --> 00:57:53,625
Onun yerine tam burada olanı
istiyorum.
1216
00:57:53,625 --> 00:57:55,500
Pekala, bu komutların
yanı sıra,
1217
00:57:55,500 --> 00:57:57,652
zamanla karşılaşacağımız
başkaları olacak.
1218
00:57:57,652 --> 00:57:58,860
Bunlar bir nevi temel bilgiler.
1219
00:57:58,860 --> 00:58:02,910
Bu, kendinizi bir GUI'den, Grafik Kullanıcı
Arayüzü'nden ayırmanıza izin verir,
1220
00:58:02,910 --> 00:58:05,670
pratik ve zamanla daha rahat
kullanmaya başlayın,
1221
00:58:05,670 --> 00:58:07,560
bunun yerine bir komut satırı arayüzü.
1222
00:58:07,560 --> 00:58:10.830
Peki, şimdi C dünyasındaki diğer
türler ne olacak?
1223
00:58:10.830 --> 00:58:15,150 Bu
komutlar C değildi. Bunlar

Machine Translated by Google

sadece komut satırına özel komut
1224
00:58:15,150 --> 00:58:19,500,
Linux'ta olduğu gibi, yine bulutta
kullanıyoruz.
1225
00:58:19,500 --> 00:58:21,510 Mac
OS ve Windows'a bir alternatiftir.

1226
00:58:21,510 --> 00:58:26,010 C
dünyasına geri döndüğümüzde,
kelimeler olan dizeleri gördük.
1227
00:58:26,010 --> 00:58:29,550 int
veya tamsayıdan bahsettim ama
başkaları da var.
1228
00:58:29,550 --> 00:58:33.780 C
dünyasında string gördük, int'yi
göreceğiz.
1229
00:58:33,780 --> 00:58:37,230 Daha
büyük bir tamsayı istiyorsanız, kelimenin
tam anlamıyla uzun denen bir şey var.
1230
00:58:37,230 --> 00:58:40,650 Tek
bir karakter istiyorsanız, char diye
bir şey var.
1231
00:58:40,650 --> 00:58:44,880 Doğru
veya yanlış bir Boole değeri
istiyorsanız, bir bool var.
1232
00:58:44,880 --> 00:58:47,310
Ve kayan noktalı bir değer istiyorsanız-1233
00:58:47,310 --> 00:58:50,980 Gerçek
bir sayıyı söylemenin süslü bir yolu, ondalık
noktası olan bir şey-1234
00:58:50,980 --> 00:58:54,400 C ve
diğer dillerin kayan nokta dediği
şey budur.

Machine Translated by Google
1235
00:58:54,400 --> 00:58:57,810
Ve ondalık noktadan sonra daha fazla
sayı istiyorsanız,
1236
00:58:57,810 --> 00:59:01,410
daha kesindir, double denen bir
şey kullanabilirsiniz.
1237
00:59:01,410 --> 00:59:05,220
Yani, işte yine programlamada
bir örnek
1238
00:59:05,220 --> 00:59:08,880
burada bilgisayara ipuçları sağlamak
artık size kalmış, aslında,
1239
00:59:08,880 --> 00:59:12,840 bu
sıfırlar ve birler modelinin ne
olduğunu bilmek için güvenecektir.
1240
00:59:12,840 --> 00:59:14.530
Bir sayı mı, bir harf mi?
1241
00:59:14,530 --> 00:59:17,820 Bir ses
mi, bir görüntü mü, bir renk mi,
yoksa benzeri mi?

1242
00:59:17,820 --> 00:59:22,170
Bunlar, tam olarak bu ipuçlarını
sağlayan veri türleridir.
1243
00:59:22,170 --> 00:59:27,000
CS50 kütüphanesi olan menüde
gelen fonksiyonlar nelerdir?
1244
00:59:27.000 --> 00:59:30,450
Standart I/O'dan bahsettik ve bu
şimdiye kadar sadece bir fonksiyon, printf.
1245
00:59:30,450 --> 00:59:34,110
CS50 kitaplığında bir desen
izlediğini görebilirsiniz.

Machine Translated by Google
1246

00:59:34,110 --> 00:59:36,780
C50 kitaplığı, büyük ölçüde ilk
birkaç hafta için mevcuttur
1247
00:59:36,780 --> 00:59:42,197 sınıfın
sadece kullanıcı girdisi almak istediğinizde
hayatımızı kolaylaştırmak için.
1248
00:59:42,197 --> 00:59:45,030
Yani bir kelime veya insandan
gelen kelimeler gibi bir dize almak istiyorsanız,
1249
00:59:45,030 --> 00:59:45,900
get_string kullanıyorsunuz.
1250
00:59:45,900 --> 00:59:48,942 Eğer
kullanıcıdan bir tamsayı almak
istiyorsanız get_int kullanacaksınız.
1251
00:59:48,942 --> 00:59:52,290
Çoğunlukla bu diğer veri türlerinden
herhangi birini almak istediğinizde,
1252
00:59:52,290 --> 00:59:55,060 get_
başka bir şey kullanırsınız.
1253
00:59:55,060 --> 00:59:57,420 Ve
gerçekten de hepsi geleneksel olarak
küçük harflidir.
1254
00:59:57,420 --> 00:59:58,530 Peki
ya printf?
1255
00:59:58,530 --> 01:00:01,830
Şimdi farklı veri türlerini saklama
yeteneğimiz varsa
1256
01:00:01,830 --> 01:00:04,950 ve
farklı veri türlerini almak için
fonksiyonlarımız var,
1257
01:00:04,950 --> 01:00:08,040
yazdırma konusunda nasıl bir yol izleyebilirsin

Machine Translated by Google
farklı veri türleri?
1258
01:00:08,040 --> 01:00:15,000
Dizi için %s, tamsayı için %i, karakter
için %c gördük,
1259
01:00:15,000 --> 01:00:21,330 %f bir
kayan nokta veya bir çift için, daha
önce tanımladığım gerçek sayılar,
1260
01:00:21,330 --> 01:00:24,960 ve
ardından uzun bir tamsayı için %li.
1261
01:00:24,960 --> 01:00:27,480 İşte
tutarsızlıkların ilk örneği.

1262
01:00:27,480 --> 01:00:30,180 İdeal
bir dünyada bu sadece %l olur ve
devam ederiz.
1263
01:00:30,180 --> 01:00:34,140 Bu
durumda bunun yerine %li olur.
1264
01:00:34,140 --> 01:00:36,900 Bu
printf ve format kodlarından bazıları.

1265
01:00:36,900 --> 01:00:38,460 Daha
ne yapabiliriz?
1266
01:00:38,460 --> 01:00:40,710
Pekala, C'de, göreceğimiz gibi--

1267
01:00:40.710 --> 01:00:43.057
herhangi bir kelime oyunu
amaçlanmamıştır-- bir sürü operatör vardır.
1268
01:00:43,057 --> 01:00:45,390
Ve gerçekten de bilgisayarlar,
yaptıkları ilk şeylerden biri
1269
01:00:45,390 --> 01:00:49,140

Machine Translated by Google

çok fazla matematik ve hesaplama vardı,
bu yüzden bunun gibi birçok operatör var.
1270
01:00:49,140 --> 01:00:52,360
Bilgisayarlar ve sırayla C, toplama,
çıkarmada gerçekten iyi,
1271
01:00:52,360 --> 01:00:55,390
çarpma, bölme ve hatta yüzde
işareti,
1272
01:00:55,390 --> 01:00:56,940 kalan
operatördür.
1273
01:00:56,940 --> 01:00:59,850
C ve diğer dillerde özel bir
sembol var
1274
01:00:59,850 --> 01:01:04,360

sadece bir sayıyı diğerine böldüğünüzde
kalanı almak için.
1275
01:01:04,360 --> 01:01:10,110
Gördüğümüz gibi, C dünyasında
değişkenler gibi başka özellikler de var.
1276
01:01:10,110 --> 01:01:14,130
Ve ayrıca şakacı bir şekilde
sözdizimsel şeker denilen şey var.
1277
01:01:14,130 --> 01:01:18.570
zamanla daha az karakter yazmayı
kolaylaştırır
1278
01:01:18,570 --> 01:01:20.290 ama
düşüncelerinizi aynı şekilde ifade edin.
1279
01:01:20.290 --> 01:01:24,670
Yani bunun tek bir örneği
olarak, tek bir örnek olarak,
1280
01:01:24,670 --> 01:01:28,530 Geçen
hafta bir değişkenin bu kullanımını
düşünün.

Machine Translated by Google
1281
01:01:28,530 --> 01:01:32,940 Burada
Scratch'te sayaç adlı bir değişkeni 0'a
nasıl ayarlayabileceğiniz anlatılmaktadır.
1282
01:01:32.940 --> 01:01:35,160 C'de
benzer olacak.
1283
01:01:35,160 --> 01:01:37,440
Değişkenin sayaç olarak
adlandırılmasını istiyorsanız,
1284
01:01:37,440 --> 01:01:40,740 Kelime
sayacını kelimenin tam anlamıyla yazarsınız
ya da nasıl çağrılmasını istiyorsanız.
1285
01:01:40,740 --> 01:01:44,550 Daha
sonra eşittir işareti olan atama
operatörünü kullanırsınız,
1286
01:01:44,550 --> 01:01:48,130 ve ilk
değeri burada sağda olması gereken neyse
onu atayın.
1287
01:01:48,130 --> 01:01:52,200
Yani, yine 0 değişkene sağdan sola
kopyalanacak
1288
01:01:52,200 --> 01:01:54,190 çünkü
o tek eşittir işareti.
1289
01:01:54,190 --> 01:01:57,030 Ama
C'de bu yeterli değil. Başka ne var?

1290
01:01:57,030 --> 01:02:000,090 şimdi
içgüdüsel olarak sağ tarafta mı kayıp?

1291
01:02:00,090 --> 01:02:02,685 Bunu
daha önce hiç programlamamış
olsanız bile.
1292

Machine Translated by Google

01:02:02,685 --> 01:02:03,310 Evet,

önde.
1293
01:02:03,310 --> 01:02:04,350
İZLEYİCİ: Noktalı virgül.

1294
01:02:04,350 --> 01:02:05,975
DAVID J. MALAN: Sonunda noktalı virgül.
1295
01:02:05,975 --> 01:02:08,140 Ve
sanırım bir şey daha eksik.

1296
01:02:08,140 --> 01:02:08,640
Tekrar.
1297
01:02:08,640 --> 01:02:09,613
İZLEYİCİ: Bir veri türü.
1298
01:02:09,613 --> 01:02:10.780
DAVID J. MALAN: Bir veri türü.
1299
01:02:10.780 --> 01:02:13,870
Yani burada ileri geri
gitmeye devam edebilirsek,
1300
01:02:13,870 --> 01:02:17,520
Counter için sezgisel olarak hangi
veri türü uygun görünüyor?
1301
01:02:17,520 --> 01:02:18,630
tamsayı için int.
1302
01:02:18,630 --> 01:02:21,060
Yani, gerçekten, bilgisayara
ne zaman söylememiz gerekiyor?

1303
01:02:21,060 --> 01:02:23,730 bir
değişken yaratarak ne tür bir veri
istediğimizi,
1304
01:02:23,730 --> 01:02:26,920 ve
işimizi bitirmemiz gerekiyor

Machine Translated by Google
noktalı virgül ile düşündüm.
1305
01:02:26,920 --> 01:02:29,340 Yani
orada bir karşılığı olabilir.
1306
01:02:29,340 --> 01:02:34,470 Bu
sayaç değişkenini artırmak istersek
Scratch'ta ne olacak?
1307
01:02:34,470 --> 01:02:36,870
Geçen sefer bu çok kullanıcı dostu
yapboz parçasına sahiptik
1308
01:02:36,870 --> 01:02:40.940 bu,
sayacı 1 değiştirir veya sayaca 1
ekler.
1309
01:02:40,940 --> 01:02:45,320 C'de
işler biraz daha ilginç hale geliyor.

1310
01:02:45,320 --> 01:02:49,310 Ve
oldukça sık yapılır, bunu yapabilirsiniz. sayaç
= sayaç + 1;
1311
01:02:49,310 --> 01:02:50,510 noktalı
virgülle.
1312
01:02:50,510 --> 01:02:53,420
Ve burada, yine, eşittir işaretine
dikkat etmek önemlidir,
1313
01:02:53,420 --> 01:02:54,560 bu
eşitlik değil.
1314
01:02:54,560 --> 01:02:56,540 Aksi
takdirde bu hiçbir anlam ifade etmez.
1315
01:02:56,540 --> 01:02:59,450 sayaç,
sayaç artı 1'e eşit olamaz, değil mi?

1316
01:02:59,450 --> 01:03:02,370

Machine Translated by Google

Burada tamsayılardan
bahsediyorsak bu işe yaramaz.
1317
01:03:02,370 --> 01:03:04,610
Bunun nedeni eşittir işaretinin
atama olmasıdır.
1318
01:03:04,610 --> 01:03:06,950
Yani kesinlikle hesapladığınız
durum olabilir
1319
01:03:06,950 --> 01:03:11,120
sayaç artı 1, ne ise o zaman sayacın
değerini güncellersiniz
1320
01:03:11,120 --> 01:03:14,070
sağdan sola bu yeni değer olsun.
1321
01:03:14,070 --> 01:03:16,400
Bu, göreceğimiz
gibi, çok yaygın bir şey
1322
01:03:16,400 --> 01:03:20,300
Hangi nedenle olursa olsun sadece
yukarı doğru saymak için programlama yapmak.
1323
01:03:20,300 --> 01:03:22,130

Bunu daha kısa ve öz yazabilirsiniz.
1324
01:03:22,130 --> 01:03:25,910
Buradaki kod, sözdizimsel
şeker diyeceğimiz şeydir, sırala
1325
01:03:25,910 --> 01:03:30,740 aynı
şeyi daha az kelime veya daha az karakterle
söylemenin süslü bir yolu
1326
01:03:30,740 --> 01:03:31,520
ekranda.
1327
01:03:31,520 --> 01:03:35,420
Bu aynı zamanda 1 veya buraya
yazdığınız sayıyı da ekler.

Machine Translated by Google
1328
01:03:35,420 --> 01:03:37,280
soldaki değişkene.
1329
01:03:37,280 --> 01:03:40,970
Ve görmeye başlayacağımız başka bir
sözdizimsel şeker türü daha var,
1330
01:03:40.970 --> 01:03:42,800 ve
bundan daha kısa.
1331
01:03:42,800 --> 01:03:48.050 Bu
da, değerini tam anlamıyla 1
değiştirerek sayacı 1 artıracaktır.
1332
01:03:48,050 --> 01:03:50,900
Veya eksi eksi olarak
değiştirirseniz, ondan 1 çıkarırsanız.
1333
01:03:50,900 --> 01:03:53,510
Bunu 2 ve 3 ve 4 ile
yapamazsınız, ancak
1334
01:03:53,510 --> 01:03:59,060
bunu varsayılan olarak artı artı veya
eksi eksi 1 ekleyerek veya çıkararak yapabilir.
1335
01:03:59,060 --> 01:03:59,961
Evet.
1336
01:03:59,961 --> 01:04:03,810
İZLEYİCİ: [DUYULMAZ]
1337
01:04:03,810 --> 01:04:06,840
DAVID J. MALAN: Ah, yani zaten

1338
01:04:06,840 --> 01:04:11,400
şuna benzeyen kodda yaptığımız
gibi oluşturuldu,
1339
01:04:11,400 --> 01:04:14,790
Artık bilgisayara veri türünün ne
olduğunu hatırlatmanıza gerek yok.

Machine Translated by Google
1340
01:04:14,790 --> 01:04:18,420
Neyse ki bilgisayar en az bu kadar
akıllı.
1341
01:04:18,420 --> 01:04:23,190
İstediğiniz verinin türünü
hatırlayacaktır.
1342
01:04:23,190 --> 01:04:26,140 Bununla
ilgili başka sorularınız veya yorumlarınız var mı?

1343
01:04:26,140 --> 01:04:27,390
Pekala, bu oldukça fazla.
1344
01:04:27,390 --> 01:04:29,770
Neden devam edip burada 10
dakikalık bir mola vermiyoruz?
1345
01:04:29,770 --> 01:04:32.970 Ve
geri döneceğiz, biraz kod yazmaya
başlayacağız.
1346
01:04:32.970 --> 01:04:36,180
Pekala, geri döndük.
1347
01:04:36,180 --> 01:04:39,780
Derlemenin bazı temellerine
az önce baktık,
1348
01:04:39,780 --> 01:04:41.535 o
kadar basit hissetmese bile.

1349
01:04:41.535 --> 01:04:43.410
Ama şimdi, gerçekten
odaklanmaya başlayalım
1350
01:04:43,410 --> 01:04:46,710 daha
fazla kod yazmak üzerine, giderek
daha ilginç
1351
01:04:46,710 --> 01:04:49,900

Machine Translated by Google
kod, geçen hafta Scratch'e
daldığımız gibi.
1352
01:04:49,900 --> 01:04:51,810 İşte
bu kodları açıyorum.
1353
01:04:51,810 --> 01:04:52.770
GUI'yi kapattım.
1354
01:04:52,770 --> 01:04:55,560
Daha çok terminal pencereme ve
kod düzenleyicilerime odaklanacağım.
1355
01:04:55,560 --> 01:04:58,643
Yeni dosyalar oluşturabilmemin birçok farklı
yolu var, ancak bir şeyler oluşturmak istiyorum

1356
01:04:58,643 --> 01:04:59,710
hesap makinesi denir.
1357
01:04:59,710 --> 01:05:02,700
Yani, yine, bu VS Kodu
ortamında,
1358
01:05:02,700 --> 01:05:06,780
VS Code'a özgü olan code
komutunu tam anlamıyla yazabilirim,
1359
01:05:06,780 --> 01:05:09,570 ve
benim için otomatik olarak yeni
bir dosya oluşturuyor.
1360
01:05:09,570 --> 01:05:11,610 Veya
bunu GUI'de yapabilirim.
1361
01:05:11,610 --> 01:05:14,582
Devam edeceğim ve hesap
makinesi.c adlı bu dosyayı oluşturacağım.
1362
01:05:14,582 --> 01:05:17,040 ve
ben devam edip bazı tanıdık şeyler
ekleyeceğim.
1363

Machine Translated by Google
01:05:17,040 --> 01:05:22,050 Şimdi
devam edeceğim ve proaktif olarak
cs50.h, stdio.h'yi dahil edeceğim.
1364
01:05:22,050 --> 01:05:25,110
Hafızadan devam edeceğim ve int
void main-1365
01:05:25,110 --> 01:05:29,448
önümüzdeki hafta, neden int, neden
void vb. hakkında daha fazla bilgi.
1366
01:05:29,448 --> 01:05:31,740 Ve şimdi
çok basit bir hesap makinesi
uygulayayım.
1367
01:05:31,740 --> 01:05:35,560 Plus ve
benzerleri gibi bazı matematiksel
operatörler gördük.
1368
01:05:35,560 --> 01:05:37.060 Şimdi
bunu gerçekten kullanalım.
1369
01:05:37.060 --> 01:05:39,870
Öyleyse devam edeyim ve
önce kendime bir değişken vereyim
1370
01:05:39,870 --> 01:05:43.680 x olarak
adlandırılır, bir tür ilkokul matematiği
veya cebir gibidir.
1371
01:05:43.680 --> 01:05:46,770
O zaman devam edeyim ve yeni
olan bir int alayım,
1372
01:05:46,770 --> 01:05:48,450 ama
bunun varlığından bahsetmiştim.
1373
01:05:48,450 --> 01:05:51,840 Ve sonra
kullanıcıya x değerleri ne olursa olsun
sormama izin verin.
1374
01:05:51,840 --> 01:05:55,183
Alıntılarda olan şey

Machine Translated by Google
sadece İngilizce veya dize
1375
01:05:55,183 --> 01:05:57,850 ekrana
yazdırıyorum. yani istediğim her
şeyi söyleyebilirdim.
1376
01:05:57,850 --> 01:06:01,130
Kullanıcıyı buna göre yönlendirmek
için sadece iki nokta üst üste diyeceğim.
1377
01:06:01,130 --> 01:06:03,630 Şimdi
devam edeceğim ve y adında başka
bir değişken alacağım.
1378
01:06:03,630 --> 01:06:04,830 Tekrar
int alacağım.
1379
01:06:04,830 --> 01:06:07,470 Ve
şimdi kullanıcıdan y'yi isteyeceğim.

1380
01:06:07,470 --> 01:06:09,750
Ve ben sadece çok titiz bir şekilde
bir boşluk kullanıyorum

1381
01:06:09,750 --> 01:06:13,230
ekranda fazla dağınık görünmemesi
için imleci hareket ettirmek için.
1382
01:06:13,230 --> 01:06:18,420 Ve
son olarak, devam edip x ve y'nin toplamını
yazdırayım.
1383
01:06:18,420 --> 01:06:22,920 İdeal
bir dünyada printf x + y gibi bir şey
söyleyebilirim.
1384
01:06:22,920 --> 01:06:27,840 Ama
bu C'de geçerli değil. İlk argüman,
printf'de hatırlama
1385
01:06:27,840 --> 01:06:30,460 çift
tırnak içinde bir dize olmalıdır.

Machine Translated by Google
1386

01:06:30,460 --> 01:06:34,260
Yani bir tamsayının
değerini yazdırmak istersem,
1387
01:06:34,260 --> 01:06:38,520
Buraya tırnak içine bir şey koymam
gerekiyor, belki ardından yeni bir satır,
1388
01:06:38,520 --> 01:06:40,420
imleci de hareket ettirmek istersem.
1389
01:06:40,420 --> 01:06:42,840
Yani, yine, sadece kısa bir bakış
attık, ama ne
1390
01:06:42,840 --> 01:06:46,680 Bir
tamsayı için yer tutucu istersem bu soru
işaretlerini değiştirelim mi?
1391
01:06:46,680 --> 01:06:47,770
İZLEYİCİ: [DUYULMAZ]
1392
01:06:47,770 --> 01:06:49,180
DAVID J. MALAN: Evet, yani %i.
1393
01:06:49,180 --> 01:06:51,790
Tıpkı %s dizge olduğu gibi, %i de tamsayıdır.
1394
01:06:51,790 --> 01:06:53,560 Bu
%i'yi değiştiriyorum.
1395
01:06:53,560 --> 01:06:57,550
Ve şimdi x ve y'yi eklemek istersem,
örneğin, süper basit hesap makinesi,
1396
01:06:57,550 --> 01:07:00,970 iki
tam sayının eklenmesinden başka
pek bir şey yapmaz-1397
01:07:00,970 --> 01:07:02,540 Bunun işe
yaradığını düşünüyorum.

1398

Machine Translated by Google

01:07:02,540 --> 01:07:05,290 Ve

yine ilk bakışta kesinlikle gizemli
görünüyor.
1399
01:07:05,290 --> 01:07:07,690
Programlama bu kadar şifreli
olmasaydı böyle olurdu.
1400
01:07:07,690 --> 01:07:09,710
Diğer diller bunu bizim için
temizleyecektir.
1401
01:07:09,710 --> 01:07:13,390
Ancak, yine, temellere
odaklanırsanız, printf önce bir girdi alır-1402
01:07:13,390 --> 01:07:17,350
İngilizce ya da herhangi bir dil,
1403
01:07:17,350 --> 01:07:18,790 bazı
yer tutucular, belki-1404
01:07:18,790 --> 01:07:22,750 o
zaman virgülden sonra potansiyel
olarak daha fazla argüman alır,
1405
01:07:22,750 --> 01:07:25,120 x
artı y değeri gibi.
1406
01:07:25,120 --> 01:07:28.000
Pekala, şimdi devam edeyim
ve hesap makinesi yapayım,
1407
01:07:28,000 --> 01:07:32,500, yine
kaynak kodumu C'de derler,

1408
01:07:32,500 --> 01:07:35,680
yukarıda resmedilmiştir ve onu
ilgili makineye dönüştürür
1409
01:07:35,680 --> 01:07:37.630 kod
veya sıfırlar ve birler.

Machine Translated by Google
1410
01:07:37,630 --> 01:07:38,680 Hata
mesajı yok.
1411
01:07:38,680 --> 01:07:39,970 yani bu
zaten iyi.
1412
01:07:39,970 --> 01:07:41.920 Şimdi ./
hesap makinesi yapıyorum.
1413
01:07:41.920 --> 01:07:45,040 1 artı 1
yapıp Enter yapalım.
1414
01:07:45,040 --> 01:07:45,880 İşte.

1415
01:07:45,880 --> 01:07:48,730 Artık bir
hesap makinesi yapımına sahibim.
1416
01:07:48,730 --> 01:07:51,620 Şimdi
bununla biraz kurcalamaya başlayalım.

1417
01:07:51,620 --> 01:07:53,470 Ya bunun
yerine bunu yapsaydım?
1418
01:07:53,470 --> 01:07:59,350 int z = x
+ y ve ardından buraya z eklentisi.
1419
01:07:59,350 --> 01:08:06,040 make
hesap makinesini yeniden çalıştırırsam,
Enter, yeniden çalıştır ./hesaplayıcı, 1 artı 1 yazın,
1420
01:08:06,040 --> 01:08:11,990 hala 2'ye
eşittir ve diğer değerler için de işe
yarayacağını iddia edeyim-1421
01:08:11,990 --> 01:08:14,020 Bu
sürümlerden hangisi daha iyi
tasarlanmış?
1422
01:08:14,020 --> 01:08:18,850

Machine Translated by Google
İlk bakışta her ikisi de doğru
görünüyorsa, bu sürüm daha mı iyi?
1423
01:08:18,850 --> 01:08:21.910 yoksa
önceki z'siz mi?
1424
01:08:21,910 --> 01:08:25,390
Tamam, bu muhtemelen daha iyi çünkü
artık yeniden kullanılabilir bir
1425
01:08:25,390 --> 01:08:27,700 z
adındaki değişken
sadece yazdıramaz, ama, heck,
1426
01:08:27,700 --> 01:08:30,500 Eğer
programım daha uzunsa başka bir
yerde kullanabilirim.
1427
01:08:30,500 --> 01:08:31,722 Karşı
düşünceler?
1428
01:08:31,722 --> 01:08:32,597
İZLEYİCİ: [DUYULMAZ]
1429
01:08:32,597 --> 01:08:33,472 DAVID
J. MALAN: Evet.
1430
01:08:33,472 --> 01:08:35,880 Daha
önce olduğu gibi tartışmalı, çünkü bu
benim niyetime bağlı.
1431
01:08:35,880 --> 01:08:37,755
Ve dürüst olmak gerekirse,
bence oldukça iyi bir argüman

1432
01:08:37,755 --> 01:08:39,200 ilk
versiyon için yapılabilir.
1433
01:08:39,200 --> 01:08:42,050
Çünkü eğer hiç niyetim
yoksa-- sizin de belirttiğiniz gibi-1434
01:08:42.050 --> 01:08:45.000

Machine Translated by Google
bu değişkeni tekrar

kullanarak, biliyor musun?
1435
01:08:45.000 --> 01:08:47.000
Belki bunu ben de yapabilirim,
çünkü sadece
1436
01:08:47.000 --> 01:08:48.530
Düşünecek bir şey daha az.
1437
01:08:48,530 --> 01:08:49,640
Dikkati dağıtan bir şey daha az.
1438
01:08:49,640 --> 01:08:52,100
Anlaşılması gereken bir kod satırı
daha az.
1439
01:08:52,100 --> 01:08:53,240
Sadece biraz daha sıkı.
1440
01:08:53,240 --> 01:08:55,970 Yani
burada yine niyetinize bağlı.

1441
01:08:55,970 --> 01:08:58,220
Ancak bu alan oldukça makul.
1442
01:08:58,220 --> 01:09:00,500
Ve sanırım, daha önce de
belirtildiği gibi,
1443
01:09:00,500 --> 01:09:04,610
Aynı şeyi get_string ile yaptım, evet, belki
biraz çarpık
1444
01:09:04,610 --> 01:09:07,535 s
satırı çünkü get_string ve içindeki
adınız ne,
1445
01:09:07,535 --> 01:09:08,660 çok
daha uzundu.
1446
01:09:08,660 --> 01:09:12.050

Machine Translated by Google
Ama x + y, eh, aklımızı neler
olduğuna sarmak o kadar da zor değil.
1447
01:09:12,050 --> 01:09:14,260
printf argümanının içinde devam ediyor.
1448
01:09:14,260 --> 01:09:17.030
Yani, yine, bunlar umarız ki
düşünce türleridir.
1449
01:09:17,030 --> 01:09:19,730
Ulaşmanın gerekmediği
içgüdüsünü kazanmak
1450
01:09:19,730 --> 01:09:22,190 bir
başkasıyla aynı cevap, ama yine,
düşünce
1451
01:09:22,190 --> 01:09:24,420
Burada önemli olan süreç.
1452
01:09:24,420 --> 01:09:27,380
Pekala, bu programı biraz nasıl
geliştirebilirim?
1453
01:09:27,380 --> 01:09:29,670 Bir
an için stilden bahsedelim.

1454
01:09:29,670 --> 01:09:34,190
Yani x ve y, en azından bu
durumda oldukça makul değişken isimleridir.
1455
01:09:34,190 --> 01:09:34,699
Neden?
1456
01:09:34,699 --> 01:09:36,949
Çünkü matematikte goto değişken isimleri
1457
01:09:36,949 --> 01:09:38,574 iki
şeyi birbirine eklediğinizde.
1458

Machine Translated by Google
01:09:38,574 --> 01:09:40,109 Yani
x ve y oldukça makul görünüyor.
1459
01:09:40,109 --> 01:09:44,359
Şöyle bir şey yapabilirdim, belki ilk
değişkenim
1460
01:09:44,359 --> 01:09:47,930 ilk
numaram ve sonraki değişkenim
olarak adlandırılmalı
1461
01:09:47,930 --> 01:09:49,752 ikinci
numara olarak adlandırılmalıdır.
1462
01:09:49,752 --> 01:09:51,710
Ve sonra burada, bunu
değiştirmek zorunda kalırdım
1463
01:09:51,710 --> 01:09:55,529 ilk
sayı artı ikinci sayıya.
1464
01:09:55,529 --> 01:09:58,250
Mesela, eh, bu gerçekten
anlamsal olarak bir şey eklemiyor
1465
01:09:58,250 --> 01:09:59,540
anlamama yardımcı olması için.
1466
01:09:59,540 --> 01:10:02,430 Ama
bu, bir şeyleri alabileceğimiz başka
bir yön olurdu.
1467
01:10:02,430 --> 01:10:05,960
Yani geleneksel olarak çok
basit fikirleriniz varsa
1468
01:10:05,960 --> 01:10:09,989 x ve
y gibi ortak değişken adlarıyla ifade edildi,
burada tamamen iyi.
1469
01:10:09,989 --> 01:10:13,790 Bu
programa açıklama eklemek ve ne işe
yaradığını kendime hatırlatmak istersem ne olur?

Machine Translated by Google
1470

01:10:13,790 --> 01:10:16,580 C'ye
yorum denilen şeyleri ekleyebilirim.

1471
01:10:16,580 --> 01:10:21,230
Bir eğik çizgi, iki eğik çizgi ile kendinize bir not
yazabilirsiniz,
1472
01:10:21,230 --> 01:10:23,779 x için
komut istemi kullanıcısı gibi.
1473
01:10:23,779 --> 01:10:26,600
Ve sonra burada, komut istemi
kullanıcısı gibi bir şey yapabilirim
1474
01:10:26,600 --> 01:10:28,819 y için,
sadece orada ne yaptığımı kendime
hatırlatmak için.
1475
01:10:28,819 --> 01:10:31,370 Ve
burada toplama işlemini gerçekleştirin.
1476
01:10:31,370 --> 01:10:34,190
Şimdi, bu durumda, bu
komutların gerçekten olduğundan emin değilim.

1477
01:10:34,190 --> 01:10:35,300 hepsi
bu kadar.
1478
01:10:35,300 --> 01:10:39,020
Çünkü bu yorumları yazmam ve sonunda
okumam zaman aldı,
1479
01:10:39.020 --> 01:10:41,150 Sadece
üç satırlık kodu okuyabilirdim.

1480
01:10:41,150 --> 01:10:44,090
Ancak programlarımız
daha karmaşık hale geldikçe
1481
01:10:44,090 --> 01:10:46,748 ve
daha fazla sözdizimi öğrenmeye başlarsınız--

Machine Translated by Google
1482
01:10:46,748 --> 01:10:49,290
Dürüst olmak gerekirse, ertesi
günü, sonraki haftayı unutabilirsiniz,
1483
01:10:49,290 --> 01:10:53.090
önümüzdeki ay-- bu notları
kendinize almak faydalı olabilir.
1484
01:10:53.090 --> 01:10:55,880 size
kodunuzun ne yaptığını hatırlatır,
hatta belki de
1485
01:10:55,880 --> 01:10:57.620 o
şeyi nasıl yapıyor.
1486
01:10:57,620 --> 01:11:00,529
Bu erken programlarla,
gerçekten gerekli değil,
1487
01:11:00,529 --> 01:11:02,870,
anlayışımıza pek bir şey katmıyor,

1488
01:11:02,870 --> 01:11:05,359
ancak bu, sahip olduğunuz bir
mekanizmadır.
1489
01:11:05,359 --> 01:11:09,260
kendinize veya birine
hatırlatmanıza gerçekten yardımcı olabilir
1490
01:11:09,260 --> 01:11:11,478
başka neler oluyor.
1491
01:11:11,478 --> 01:11:14,270
Pekala, devam edeyim ve bunu bu
güncel sürümde tekrar çalıştırayım,
1492
01:11:14,270 --> 01:11:15,630
hesap makinesi yap.
1493
01:11:15,630 --> 01:11:18,200

Machine Translated by Google
Ve burada da çok hızlı
yazdığımı düşünebilirsiniz-1494
01:11:18,200 --> 01:11:18,890 pek
değil.
1495
01:11:18,890 --> 01:11:19,970 Tab'a
çok fazla basıyorum.
1496
01:11:19,970 --> 01:11:23,400
Yani ortaya çıkıyor
Linux, işletim sistemi
1497
01:11:23,400 --> 01:11:24,710 burada
bulutta kullanıyoruz-1498
01:11:24,710 --> 01:11:28,160 ama
aslında Windows ve Mac
İşletim sistemi günümüzde bunu da destekliyor--

1499
01:11:28,160 --> 01:11:30,000
otomatik tamamlamayı destekler.
1500
01:11:30,000 --> 01:11:33,500
Yani CAL ile başlayan tek bir
programınız varsa,
1501
01:11:33,500 --> 01:11:36,410 Hesap
makinesi yazmayı bitirmeniz
gerekmez, sadece Sekme tuşuna basabilirsiniz,
1502
01:11:36,410 --> 01:11:38,970 ve
bilgisayar sizin yerinize düşüncenizi
tamamlayacaktır.
1503
01:11:38,970 --> 01:11:43,130
Yapabileceğiniz diğer şey, Yukarı
tuşuna basarsanız ve devam ederseniz,
1504
01:11:43,130 --> 01:11:45,623 tüm
komut geçmişinizi gözden
geçireceksiniz.
1505

Machine Translated by Google
01:11:45,623 --> 01:11:47,540
Yani orada da, bazı tuş
vuruşlarını kaydediyorum
1506
01:11:47,540 --> 01:11:50,373
Aynı lanet şeyi tekrar yazmak yerine
hızlıca Yukarı tuşuna basarak
1507
01:11:50,373 --> 01:11:51,030 ve
tekrar.
1508
01:11:51,030 --> 01:11:53,330
Yani, yine, sadece başka
bir küçük kolaylık
1509
01:11:53,330 --> 01:11:57,110
komut satırı arabirimiyle programlamayı ve
etkileşimi daha da hızlı hale getirmek için.
1510
01:11:57,110 --> 01:12:00,480
Pekala, devam edeyim ve mevcut biçimde
derlendiğinden emin olun.
1511
01:12:00,480 --> 01:12:02,330
Yorumların işlevsel bir etkisi yoktur.
1512
01:12:02,330 --> 01:12:04,430 Bu
yeşil şeyler sadece kendi kendime
notlardır.
1513
01:12:04,430 --> 01:12:06,620
Hesap makinesini belki ile
çalıştırayım-- buna ne dersin?
1514
01:12:06,620 --> 01:12:10,640
1 artı 1 yerine,
yaklaşık 1 milyar-1515
01:12:13,203 --> 01:12:14,370 dur,
hadi bunu tekrar yapalım.
1516
01:12:14,370 --> 01:12:15,660 Wa,
da, da.

Machine Translated by Google
1517

01:12:15,660 --> 01:12:21.375 1
milyon, 1 milyar ve 1 milyar daha
ve bu cevap 2 milyar.
1518
01:12:21,375 --> 01:12:22,750
Pekâlâ, bu doğru görünüyor.
1519
01:12:22,750 --> 01:12:24,292 Bu
programı bir kez daha çalıştıralım.
1520
01:12:24,292 --> 01:12:30,480 2
milyar artı 2 milyara ne dersiniz?

1521
01:12:30,480 --> 01:12:33,320
Bunu biliyor muydunuz?
1522
01:12:33,320 --> 01:12:36,320
Yani görünüşe göre pek doğru değil.
1523
01:12:36,320 --> 01:12:40,790
Ve açıkçası, 1 artı 1'i çalıştırmak,
kodumun en sağlam testi değildi.
1524
01:12:40,790 --> 01:12:41,750
burada.
1525
01:12:41,750 --> 01:12:44,435 Ne
yanlış gitmiş olabilir?
1526
01:12:44,435 --> 01:12:45,560 Ne
yanlış gitmiş olabilir?
1527
01:12:45,560 --> 01:12:46,445
Evet.
1528
01:12:46,445 --> 01:12:48,665
İZLEYİCİ: [DUYULMAZ]
1529
01:12:48,665 --> 01:12:49,540
DAVID J. MALAN: Evet.

Machine Translated by Google
1530

01:12:49,540 --> 01:12:51,710
Bilgisayarda muhtemelen bitlerle dolu
alan kalmadı.
1531
01:12:51,710 --> 01:12:56,470
Bu veri tipleriyle ortaya çıkıyor-- string ve int
hakkında konuşuyorduk
1532
01:12:56,470 --> 01:13:00,850 ve ayrıca
float ve char ve diğer şeyler-- hepsi belirli
kullanır,
1533
01:13:00,850 --> 01:13:04,480 ve en
önemlisi bunları temsil edecek sonlu
sayıda bit.
1534
01:13:04,480 --> 01:13:06,160
Bilgisayara göre değişiklik gösterebilir.
1535
01:13:06,160 --> 01:13:10,090 Daha
yeni bilgisayarlar daha fazla bit kullanır, eski
bilgisayarlar daha az bit kullanma eğilimindeydi.
1536
01:13:10,090 --> 01:13:13.040 Tüm bu
veri türleri için standart hale getirilmiş
olması gerekmez.
1537
01:13:13,040 --> 01:13:19,360 Ancak
bu durumda, bu ortamda bir tamsayı için 32
bit kullanıyor.
1538
01:13:19,360 --> 01:13:20,035 Bu çok
fazla.
1539
01:13:20,035 --> 01:13:22,180 Yani 32
bit ile oldukça yüksek sayabilirsiniz.

1540
01:13:22,180 --> 01:13:25,360 Bu
sahnedeki 64 ampul ve daha da
yüksek sayılabilir.
1541
01:13:25,360 --> 01:13:29,530

Machine Translated by Google
Bir int bunların sadece yarısını kullanıyor
veya burada sahnede iki tamsayımız var.
1542
01:13:29,530 --> 01:13:33,550 Şimdi,
geçen haftaya dönerseniz, bir noktada 8
bitten bahsetmiştik.
1543
01:13:33,550 --> 01:13:38,570
Ve 8 bit, 8 sıfır ve biriniz varsa, 256'ya
kadar sayabilirsiniz-1544
01:13:38,570 --> 01:13:40,900
genellikle önemsiz şeyler olarak
hatırlanması gereken iyi bir sayı.
1545
01:13:40,900 --> 01:13:44,740 8 bit
size 256 sıfır ve bir permütasyonu
verir.
1546
01:13:44,740 --> 01:13:48,640 32,
bilen varsa, kabaca kaç tane verir?

1547
01:13:48,640 --> 01:13:51,040 2
üzeri 32.
1548
01:13:51,040 --> 01:13:53,710 Yani
kabaca 4 milyar, 2 üzeri 32.
1549
01:13:53,710 --> 01:13:55,510 Bunu
bilmiyorsanız, sorun değil.
1550
01:13:55,510 --> 01:13:58,510 Ancak
çoğu programcı sonunda bu tür buluşsal
yöntemleri hatırlar.
1551
01:13:58,510 --> 01:14:000,010 Yani
kabaca 4 milyar.
1552
01:14:00,010 --> 01:14:01,990 Yani
bu yeterli gibi.
1553
01:14:01,990 --> 01:14:05,080

Machine Translated by Google
2 milyar artı 2 milyar tam
olarak 4 milyar eder.
1554
01:14:05,080 --> 01:14:09,160 Ve
bu aslında 32 bitlik bir tam sayıya
sığmalıdır.
1555
01:14:09,160 --> 01:14:11,950
Sorun şu ki, Mac'im, PC'niz
ve benzerleri
1556
01:14:11,950 --> 01:14:13,990
ayrıca negatif sayıları desteklemeyi sever.
1557
01:14:13,990 --> 01:14:17,350
Hem pozitif hem de negatif sayıları
desteklemek istiyorsanız, teknik olarak bu
1558
01:14:17,350 --> 01:14:20.470, 32bit tam sayılarla yüksek
sayabilirsiniz anlamına gelir
1559
01:14:20.470 --> 01:14:24,742
kabaca 2 milyar pozitif veya 2
milyar negatif
1560
01:14:24,742 --> 01:14:25,700 diğer
yönde.
1561
01:14:25,700 --> 01:14:29,260
Bu hala 4 milyar, al ya da ver,
ama sadece yarısı kadar
1562
01:14:29,260 --> 01:14:30,860 bir
yönde veya diğerinde.
1563
01:14:30,860 --> 01:14:35,410 Peki
burada doğru bir hesap makinesini nasıl
uygulayabilirim?
1564
01:14:35,410 --> 01:14:38,800
Çözüm ne olabilir?
1565

Machine Translated by Google
01:14:38,800 --> 01:14:41,380 Evet,
yani uzun tamsayı için olan sadece
li değil.
1566
01:14:41,380 --> 01:14:45,830 Veri
türünün kendisinde bir değişiklik
daha yapmam gerekiyor.
1567
01:14:45,830 --> 01:14:50,290
Buraya geri döneyim ve x'i int'den long'a
çevireyim, aka
1568
01:14:50,290 --> 01:14:51,430 uzun
tamsayı.
1569
01:14:51,430 --> 01:14:53,600 Sonra
y'yi de değiştirmeme izin verin.
1570
01:14:53,600 --> 01:14:57,100
Ve sonra elimizdeki küçük hile sayfasına göre
format kodunu değiştirmeme izin verin.
1571
01:14:57,100 --> 01:14:59,170 birkaç
dakika önce li'ye.
1572
01:14:59,170 --> 01:15:01,780
Hesap makinesini yeniden derlememe izin ver--

1573
01:15:01,780 --> 01:15:02,770 iyi
çalışıyor gibi görünüyor.
1574
01:15:02,770 --> 01:15:03,830
Tekrar çalıştıralım.
1575
01:15:03,830 --> 01:15:05,260 Şimdi
1 artı 1 yapalım.
1576
01:15:05,260 --> 01:15:06,800 Bu
kesinlikle aynı olmalı.
1577
01:15:06,800 --> 01:15:11,900
Şimdi 2 milyar ve 2 milyar
daha yapalım

Machine Translated by Google
1578
01:15:11,900 --> 01:15:13,530 ve bu
sefer parmaklarımızı çarpın.
1579
01:15:13,530 --> 01:15:15,920 Şimdi
4 milyara kadar sayıyoruz.
1580
01:15:15,920 --> 01:15:19,070
4 milyardan çok daha yükseğe
çıkabiliriz, ama biz sadece
1581
01:15:19,070 --> 01:15:20.960
konserveyi sokakta biraz tekmelemek.
1582
01:15:20.960 --> 01:15:22.460
Şu anda kullanıyor olmamıza rağmen--

1583
01:15:22,460 --> 01:15:23,630 uzun--

1584
01:15:23,630 --> 01:15:28,980 64
bit, şu an bu aşama kadar uzun, bu
hala sonlu bir değer.
1585
01:15:28,980 --> 01:15:31,580
Gerçekten büyük bir değer olabilir
ama yine de sonlu.
1586
01:15:31,580 --> 01:15:34,010
Ve bugünün sonunda bu
türlere geri döneceğiz
1587
01:15:34,010 --> 01:15:35,240 temel
sınırlamalar.
1588
01:15:35,240 --> 01:15:39,510
Çünkü tartışmalı olarak şimdi, hesap
makinem milyonlarca kişi için doğru,
1589
01:15:39,510 --> 01:15:42,480
milyarlarca olası girdi ama hepsi değil.
1590

Machine Translated by Google
01:15:42,480 --> 01:15:44,600
Ve eğer gerçekten
istiyorsan bu sorunlu
1591
01:15:44,600 --> 01:15:49,940

1592
01:15:49,940 --> 01:15:54,500 Bu
durumda olduğu gibi kabaca 2
milyardan az olanlar.
1593
01:15:54,500 --> 01:15:56,492 Pekala, o
zaman bununla ilgili herhangi bir sorunuz var mı?

1594
01:15:56,492 --> 01:15:58,700
Ama gerçekten tüm
problemlerin habercisi
1595
01:15:58,700 --> 01:16:01,705
bununla daha sonra uğraşmak
zorunda kalacağız.
1596
01:16:01,705 --> 01:16:06,887
İZLEYİCİ: [DUYULMAZ]
1597
01:16:06,887 --> 01:16:08,220
DAVID J. MALAN: Güzel bir soru.
1598
01:16:08,220 --> 01:16:08,460
Evet.
1599
01:16:08,460 --> 01:16:11,550 Eğer
hala z kullanıyor olsaydık, onu da uzun
olarak değiştirmek zorunda kalırdık.

1600
01:16:11,550 --> 01:16:14,670
Aksi takdirde, bu bitlerin
32'sini yok sayardık.
1601
01:16:14,670 --> 01:16:17,190
long'lar aracılığıyla birbirine eklendi.
1602

Machine Translated by Google

01:16:17,190 --> 01:16:19,030 Güzel

soru.
1603
01:16:19,030 --> 01:16:23,550
Pekala, o zaman buraya sadece eklemeyle
değil de biraz renk katsak nasıl olur?
1604
01:16:23,550 --> 01:16:26,910 Bazı
koşullara sahip bir şeye ne dersiniz?

1605
01:16:26,910 --> 01:16:28,830 Bazı
gerçek sorular sormaya başlayalım.

1606
01:16:28,830 --> 01:16:35,290 Bir
an önce, sadece değişkenlerin
bildirilmesine sahip olduğumuzu hatırlayın.
1607
01:16:35,290 --> 01:16:37,290
Şimdi Scratch'te geriye
dönük bir şeye bakalım.
1608
01:16:37,290 --> 01:16:39,832 biraz
buna benziyordu, bir grup yapboz
parçası
1609
01:16:39,832 --> 01:16:41.910 bu
koşullu ifadelerle soru sorma

1610
01:16:41,910 --> 01:16:44,910 ve
sonra buradaki yeşil Boole ifadeleri, belki
bir şeyler söylüyor
1611
01:16:44,910 --> 01:16:46,440 x'in
y'den küçük olması gibi.
1612
01:16:46,440 --> 01:16:49,500 C'de
bu aslında oldukça temiz bir şekilde eşlenir.
1613
01:16:49,500 --> 01:16:53,490
Soldan sağa printf ve join ile olduğundan
çok daha temiz.

Machine Translated by Google
1614
01:16:53,490 --> 01:16:56,190
Burada sadece şuna benzeyen
bir kodumuz var.
1615
01:16:56,190 --> 01:17:00,450
Bir boşluk, iki parantez ve
ardından x, y'den küçükse,
1616
01:17:00,450 --> 01:17:03,423 ve
sonra ortada printf gibi bir şey var.

1617
01:17:03,423 --> 01:17:05,340
Yani burada aslında güzel bir
haritalama var.
1618
01:17:05,340 --> 01:17:07,710
Dikkat edin, tıpkı
Scratch'teki sarı yapboz parçası gibi
1619
01:17:07,710 --> 01:17:09,843 bir
nevi mor yapboz parçasına
sarılmak,
1620
01:17:09,843 --> 01:17:12,510 Bu
küme parantezlerinin oynadığı
rol aslında budur.
1621
01:17:12,510 --> 01:17:15,900
İçerideki tüm kodu kapsıyor
gibiler.
1622
01:17:15,900 --> 01:17:19,050
Parantezler Boole ifadesini
temsil eder
1623
01:17:19,050 --> 01:17:23,610 Bu
şeyi yapıp yapmamaya karar vermek için
sorulması ve cevaplanması gereken şey.
1624
01:17:23,610 --> 01:17:26,040 Ve
burada daha önce bahsettiğim
şeyin bir istisnası var.

Machine Translated by Google
1625
01:17:26,040 --> 01:17:30,090
Genellikle, bir kelime ve ardından bir
parantez gördüğünüzde, bir şey,
1626
01:17:30,090 --> 01:17:33,330 ve
ardından kapalı parantez, bunun
genellikle bir fonksiyon olduğunu iddia ettim.

1627
01:17:33,330 --> 01:17:35,520 Ve
bu iddia hakkında hâlâ oldukça
iyi hissediyorum.
1628
01:17:35,520 --> 01:17:36,960
Ancak istisnalar da vardır.
1629
01:17:36,960 --> 01:17:39,480 Ve
if sözcüğü bir işlev değildir.
1630
01:17:39,480 --> 01:17:41,700 Bu
sadece bir programlama yapısıdır.
1631
01:17:41,700 --> 01:17:46,620
Benzer şekilde parantez kullanan
C dilinin bir özelliğidir, sadece
1632
01:17:46,620 --> 01:17:49,200
Boole ifadesi için farklı amaçlar
için.
1633
01:17:49,200 --> 01:17:50,610
Bunun gibi bir şeye ne dersiniz?
1634
01:17:50,610 --> 01:17:53,700
Geçen hafta, iki yönlü bir yol
ayrımına sahip olmak istiyorsanız,
1635
01:17:53,700 --> 01:17:56,700 şu
ya da bu şekilde git, if ve else
alabilirsin.
1636
01:17:56,700 --> 01:17:59,290
C'de, bu bir

Machine Translated by Google
küçük bir şey böyle.
1637
01:17:59,290 --> 01:18:02,310
Ve printf'leri eklersek, şimdi
tamamen aynı görünüyor,
1638
01:18:02,310 --> 01:18:06,240 ama
tabii ki else sözcüğünü ve ardından
birkaç küme parantezini ekler.
1639
01:18:06,240 --> 01:18:12,390
Bir kenara, C'de, kaşlı ayraçlara
sahip olmak kesinlikle gerekli değildir.
1640
01:18:12,390 --> 01:18:16,980 eğer
altına girintili tek bir kod satırınız
varsa.
1641
01:18:16,980 --> 01:18:21,267
Yine de en iyi uygulama için, yine de yapın,
çünkü bu sizin için çok nettir
1642
01:18:21,267 --> 01:18:23,100 ve
nihayetinde kodunuzu okuyan
herhangi biri
1643
01:18:23,100 --> 01:18:26,610
sadece bir veya daha fazla kod
satırının yürütülmesini amaçladığınızı.
1644
01:18:26,610 --> 01:18:28,260
Geçen haftadan buna ne dersiniz?
1645
01:18:28,260 --> 01:18:29,880
Burada üç yönlü bir yol ayrımı vardı.
1646
01:18:29,880 --> 01:18:36,272 x,
y'den küçükse, yoksa x y'den
büyükse, yoksa x y'ye eşitse.
1647
01:18:36,272 --> 01:18:38,730
Şimdi, burada Scratch arasında bazı
eşitsizlikler var.

Machine Translated by Google
1648

01:18:38,730 --> 01:18:43,950 ve
C. Scratch, iki değeri karşılaştırmak
için eşitlik için bir eşittir işareti kullanır.
1649
01:18:43,950 --> 01:18:47,040
C, sağdan atama için tek bir
eşittir işareti kullanır
1650
01:18:47,040 --> 01:18:49,810
sola, iki dünya arasındaki küçük
fark.
1651
01:18:49,810 --> 01:18:54,030
C'de, bunun gibi aynı kodu
uygulayabiliriz, ekleme şu şekildedir:
1652
01:18:54,030 --> 01:18:55,530
sadece bu ek başka ise.
1653
01:18:55,530 --> 01:18:59,895 Ve
printf'leri eklersek, şimdi biraz
böyle görünüyor.
1654
01:18:59,895 --> 01:19:03,660 Bu
hem Scratch dünyasında hem de
C dünyasında doğrudur.
1655
01:19:03,660 --> 01:19:07,620
Ancak birisi bunun yine iyi tasarlanmadığını
iddia edebilir mi?
1656
01:19:07,620 --> 01:19:08,340
Kesinlikle.
1657
01:19:08,340 --> 01:19:09,780 Son
if'ye ihtiyacımız yok.
1658
01:19:09,780 --> 01:19:12,930 En
azından else'e ihtiyacımız var
ama son if'ye ihtiyacımız yok.
1659
01:19:12,930 --> 01:19:15,420
Çünkü, en azından

Machine Translated by Google
tamsayıları karşılaştırma dünyası,
1660
01:19:15,420 --> 01:19:18,420 ya
küçüktür, ya büyüktür ya da eşittir.

1661
01:19:18,420 --> 01:19:19,930 Başka
bir durum yok.
1662
01:19:19,930 --> 01:19:22,530
Böylece birkaç saniye
tasarruf edebilirsiniz, isterseniz,

1663
01:19:22,530 --> 01:19:26.580
programınız çalışıyor-- göz açıp kapayıncaya
kadar-- sadece iki soru sorarak
1664
01:19:26,580 --> 01:19:29,070 ve
ardından üçüncünün cevabının ne
olduğunu çıkarsama
1665
01:19:29,070 --> 01:19:32,680
burada kendi insan mantığınızın
doğası gereği adil olmalıdır.
1666
01:19:32.680 --> 01:19:34,020 Peki
bu neden iyi bir şey?
1667
01:19:34,020 --> 01:19:37,770
Örneğin, x ve y birbirine
eşitse-1668
01:19:37,770 --> 01:19:42,540
Her iki değer için de Scratch veya C
dünyasında 1 ve 1 yazıyorum-1669
01:19:42,540 --> 01:19:46,770 bu
versiyonda biraz aptalsın

1670
01:19:46,770 --> 01:19:50,220 hepsi
sorulacak olan üç soru sormak

Machine Translated by Google
1671

01:19:50,220 --> 01:19:53,520 cevap
hayır, hayır, evet olsa da.
1672
01:19:53,520 --> 01:19:57.000 Bu
yanlış, yanlış, doğru.
1673
01:19:57.000 --> 01:20:00,840
Bu gereksiz görünüyor çünkü bunun yerine
bu kodu optimize edersek,
1674
01:20:00,840 --> 01:20:04,650
Gereksiz olanlardan kurtul ve
mantıklı olarak önerdiğin gibi yap-1675
01:20:04,650 --> 01:20:07,680
yoksa x'in y'ye eşit olduğunu yazdırın-1676
01:20:07,680 --> 01:20:12,160 şimdi
x gerçekten de y'ye eşitse, çünkü ikisi
de 1 veya başka bir değerdir,
1677
01:20:12,160 --> 01:20:17,400 şimdi
sadece iki soru soracaksınız, yani 2/3
kadar soru,
1678
01:20:17,400 --> 01:20:20.680 ve
sonra aynı doğru sonucu alacaksınız.

1679
01:20:20.680 --> 01:20:23.340
Yani, yine küçük bir ayrıntı,
ama yine, bu tür şeyler
1680
01:20:23,340 --> 01:20:25.048

1681
01:20:25,048 --> 01:20:27,630
kodunu doğru yazıyorsun ama
aynı zamanda yazıyorsun
1682
01:20:27,630 --> 01:20:30,030 aynı
zamanda iyi tasarlanmış olmalıdır.

Machine Translated by Google
1683
01:20:30,030 --> 01:20:32,280
Pekala, neden devam edip
bunu çevirmiyoruz?
1684
01:20:32,280 --> 01:20:35,850
burada gerçek bir program
bağlamında?
1685
01:20:35,850 --> 01:20:37,770
Burada boş bir pencere oluşturacağım.
1686
01:20:37,770 --> 01:20:41,640
Ve puanlarla bir şeyler yapalım, kendi
ilk CS50'mdeki puanlar gibi
1687
01:20:41,640 --> 01:20:42,720
problem seti.
1688
01:20:42,720 --> 01:20:45,840
Devam edeyim ve point.c kodunu
çalıştırayım.
1689
01:20:45,840 --> 01:20:47,910 Bu
bana yeni bir metin dosyası verecek.

1690
01:20:47,910 --> 01:20:51,960 Ve
sonra burada, her zamanki gibi
yapacağım, cs50.h'yi dahil edeceğim.
1691
01:20:51,960 --> 01:20:54,360
stdio.h'yi içerir.
1692
01:20:54,360 --> 01:20:55,980 int
ana boşluk.
1693
01:20:55,980 --> 01:20:59,430 Bu
ilk programlarda tabiri caizse pek
çok ortak kural var.
1694
01:20:59,430 --> 01:21:00,720 Şimdi
bakalım.

Machine Translated by Google
1695
01:21:00,720 --> 01:21:04,020
Kullanıcıya soralım kaç
puan vermişler
1696
01:21:04,020 --> 01:21:06,260 en
son CS50 PS Set'lerinde kaybettiler mi?
1697
01:21:06,260 --> 01:21:10,240
Bu yüzden geçen hafta kendi ilk
PSet'imin fotoğrafımı çağrıştırıyor
1698
01:21:10,240 --> 01:21:11,890
burada birkaç puan kaybettim.
1699
01:21:11,890 --> 01:21:15,000
Yani int puan = get_int.
1700
01:21:15,000 --> 01:21:18,940
Sonra İngilizce bir soru soracağım,
kaç puan kaybettin,
1701
01:21:18,940 --> 01:21:20,500
soru işareti, boşluk mu?
1702
01:21:20,500 --> 01:21:24,800 Ve
bu cevabı aldıktan sonra, şimdi
bununla ilgili bazı sorular soralım.
1703
01:21:24,800 --> 01:21:28,060
Yani puanlar 2'den küçükse-1704
01:21:28.060 --> 01:21:31.720 az
önce ekranda gördüğümüz söz
dizimini ödünç alarak-1705
01:21:31,720 --> 01:21:34,120
hadi devam edelim ve açıklayıcı
bir şeyler yazdıralım
1706
01:21:34,120 --> 01:21:40,390 gibi
benden daha az puan kaybettin,
ters eğik çizgi n.

Machine Translated by Google
1707
01:21:40,390 --> 01:21:43,420 2'den
büyük puanlar varsa
1708
01:21:43,420 --> 01:21:45,190 yani yine
kaç tane kaybettim-1709
01:21:45,190 --> 01:21:50.860 Devam
edeceğim ve benden daha fazla puan kaybettiğinizi
yazdıracağım, ters eğik çizgi n.
1710
01:21:50.860 --> 01:21:55,047 else if-bir dakika, aksi mantıklı olarak burada
yeterli görünüyor.
1711
01:21:55,047 --> 01:21:57,130
Sadece devam edeceğim ve bir
şeyler yazdıracağım
1712
01:21:57,130 --> 01:22:03,820 tıpkı
benimle aynı sayıda puan kaybettiğiniz
gibi, ters eğik çizgi n.
1713
01:22:03,820 --> 01:22:07,990
Yani, gerçekten, bu basit fikrin basit bir
uygulaması
1714
01:22:07,990 --> 01:22:10,160 ama
burada somut bir senaryo var.
1715
01:22:10,160 --> 01:22:12,290 Öyleyse
devam edip bunu kaydetmeme izin verin.
1716
01:22:12,290 --> 01:22:15,340 Devam
edeyim ve puan kazan, Gir'i çalıştırayım.

1717
01:22:15,340 --> 01:22:17,230 Hata
yok, bu iyi.
1718
01:22:17,230 --> 01:22:18,220 Koşu
puanları.

Machine Translated by Google
1719

01:22:18,220 --> 01:22:20.530 Ve
sonra kaç puan kaybettiniz?
1720
01:22:20.530 --> 01:22:22,302 Peki
ya 1 puan?
1721
01:22:22,302 --> 01:22:24,010
Pekala, benden daha az puan
kaybettin.
1722
01:22:24,010 --> 01:22:25,540 0
puana ne dersiniz?
1723
01:22:25,540 --> 01:22:26,140 Daha
da iyisi.
1724
01:22:26,140 --> 01:22:27,370 3
puana ne dersiniz?
1725
01:22:27,370 --> 01:22:28,280 Ve
benzeri.
1726
01:22:28,280 --> 01:22:32,050
Yani, yine, şimdi oldukça basit bir
fikri C ile ifade etme yeteneğine sahibiz.
1727
01:22:32.050 --> 01:22:36,040
gerçekte geçen haftadan itibaren, bu
koşul ve soru kavramıdır
1728
01:22:36,040 --> 01:22:37,310 soru.

1729
01:22:37,310 --> 01:22:42,010
Burada incelikli bir şey var ama bu belki de
çok iyi tasarlanmamıştır.
1730
01:22:42.010 --> 01:22:44,590
birinin sihirli bir numarayı araması.
1731
01:22:44,590 --> 01:22:47,780
Bu programlama konuşması

Machine Translated by Google
burada yaptığım bir şey için.
1732
01:22:47,780 --> 01:22:53,080 if ve
else ve else ile ilgisi olmayan biraz fazlalık
var.
1733
01:22:53,080 --> 01:22:58,670 Ama
belki de bariz olanı sormak için iki kez
yazdığım bir şey var mı?
1734
01:22:58,670 --> 01:23:02,630
Aynen, sabit kodladım, tabiri caizse, elle 2
rakamını yazdım-1735
01:23:02,630 --> 01:23:04,970 iki
yerde, bu durumda--

Kullanıcıdan gelmeyen 1736
01:23:04,970 --> 01:23:06,900.
1737
01:23:06,900 --> 01:23:09,800 Yani,
görünüşe göre, bunu bir kez
derlediğimde, bu kadar.

1738
01:23:09,800 --> 01:23:12,870
1996'da hep kendini benimle
karşılaştırıyorsun,
1739
01:23:12,870 --> 01:23:15,830
hangisi daha iyi ya da daha kötü,
programın yapabileceği tek şey bu.
1740
01:23:15,830 --> 01:23:19,130
Ama bu anlamda da sihirli bir
sayının bir örneğidir.
1741
01:23:19,130 --> 01:23:22,890 gibi,
bekle, bu 2 nereden geldi ve neden
iki yerde?
1742
01:23:22,890 --> 01:23:26,450
Sadece daha yüksek bir olasılık
için zemin hazırlıyormuşuz gibi geliyor

Machine Translated by Google
1743

01:23:26,450 --> 01:23:27,680 yolu
mahvetme.
1744
01:23:27,680 --> 01:23:31,130
Bu kod ne kadar uzarsa, 2 puanla
karşılaştırdığımı varsayalım.
1745
01:23:31,130 --> 01:23:31,880 başka
yerde-1746
01:23:31,880 --> 01:23:34,100 2, 3,
4, 5 sıra-1747
01:23:34,100 --> 01:23:36,230 2
rakamını yazmaya devam mı edeceğim?
1748
01:23:36,230 --> 01:23:37.490 Evet,
sorun değil.
1749
01:23:37,490 --> 01:23:38,180 Doğru.

1750
01:23:38,180 --> 01:23:39,110 İşe
yarayacak.
1751
01:23:39,110 --> 01:23:41,060
Ama dürüst olmak gerekirse,
sonunda, batıracaksın,
1752
01:23:41,060 --> 01:23:43.610 ve
2'lerden birini kaçıracaksınız, 3 olarak
değiştireceksiniz,
1753
01:23:43,610 --> 01:23:46,110 çünkü
belki gelecek yıl daha kötüsünü
yaptım ya da 1, daha iyisini yaptım.
1754
01:23:46,110 --> 01:23:48,750 Ve bu
sayıların senkronizasyondan
çıkmasını istemezsiniz.
1755
01:23:48,750 --> 01:23:52,250

Machine Translated by Google
Peki bu tasarımda mantıklı bir
gelişme ne olurdu,
1756
01:23:52,250 --> 01:23:55,310 Aynı
sayıyı sihirli bir şekilde kodlamak
yerine
1757
01:23:55,310 --> 01:23:58,210 iki
veya daha fazla yerde mi?
1758
01:23:58,210 --> 01:24:00,888 Evet,
neden orada kullanabileceğim bir
değişken yapmıyorum?
1759
01:24:00,888 --> 01:24:02,680
Örneğin, bir
değişken oluşturabilirim
1760
01:24:02,680 --> 01:24:05,740 bunun
gibi başka bir tam sayı benimki olarak adlandırıldı.

1761
01:24:05,740 --> 01:24:07,570 Ve
onu sadece 2 olarak başlatacağım.

1762
01:24:07,570 --> 01:24:10.570 Ve
sonra 2'nin sözlerini bununla
değiştireceğim.
1763
01:24:10.570 --> 01:24:14,200
Ve benimki şu ana kadar bir değişken
için oldukça makul bir isim
1764
01:24:14,200 --> 01:24:18,460 tam
olarak kimin puanlarının söz konusu
olduğunu ifade eder.
1765
01:24:18,460 --> 01:24:20.980
Burada küçük de olsa bir risk var.

1766
01:24:20.980 --> 01:24:23,560 Bir
noktada yanlışlıkla benimkini
değiştirebilirim.

Machine Translated by Google
1767
01:24:23,560 --> 01:24:27,650 Belki
benimkinin neyi temsil ettiğini unutuyorum
ve biraz toplama veya çıkarma yapıyorum.
1768
01:24:27,650 --> 01:24:30,220
Yani bilgisayara "bana
güvenme," demenin bir yolu var.
1769
01:24:30,220 --> 01:24:31,930 çünkü
eninde sonunda işi batıracağım"

1770
01:24:31,930 --> 01:24:34,510
değişkeni de sabit yaparak.
1771
01:24:34,510 --> 01:24:36,980
Yani bir programlama
dilinde bir sabit-1772
01:24:36,980 --> 01:24:38,620
Scratch'te bu yoktu-1773
01:24:38,620 --> 01:24:41,740
bilgisayara yalnızca ek bir ipucudur.

1774
01:24:41,740 --> 01:24:43,330 daha
defansif programlamak için.
1775
01:24:43,330 --> 01:24:46,540
Kendinize
güvenmiyorsanız mutlaka
1776
01:24:46,540 --> 01:24:48,850 daha
sonra ya da dürüst olmak gerekirse,
pratikte,
1777
01:24:48,850 --> 01:24:52,360 Eğer
bu sayının asla değişmemesi
gerektiğini biliyorsanız, sabit yapın
1778
01:24:52,360 --> 01:24:54,020

Machine Translated by Google
ve bir daha asla düşünme.
1779
01:24:54,020 --> 01:24:59,290
Bu, derleyiciye, kodunuzda daha sonra sizin
bile yapamadığınızdan emin olmasını söyler.
1780
01:24:59,290 --> 01:25:00,940 2
sayısını değiştirin.
1781
01:25:00,940 --> 01:25:05,440
Ve bir sabitiniz olduğunda, C ve diğer dillerdeki
başka bir kural,
1782
01:25:05,440 --> 01:25:07,892
Değişkeni sadece büyük harf yapmak
genellikle yaygındır.
1783
01:25:07,892 --> 01:25:09,850
Bağırıyormuşsun gibi,
ama gerçekten sadece
1784
01:25:09,850 --> 01:25:11,202 görsel
olarak öne çıkıyor.
1785
01:25:11,202 --> 01:25:12,910
Yani bu bir nevi güzel
bir başparmak kuralı gibi

1786
01:25:12,910 --> 01:25:15,790 Bu, ah,
bunun bir sabit olması gerektiğini
anlamanıza yardımcı olur.
1787
01:25:15,790 --> 01:25:18.490 Tek
başına büyük harf kullanımı onu sabit
yapmaz.
1788
01:25:18,490 --> 01:25:20,080 const
kelimesi yapar.
1789
01:25:20,080 --> 01:25:22,330
Ancak büyük harf kullanımı
yalnızca görsel bir hatırlatmadır

1790

Machine Translated by Google
01:25:22,330 --> 01:25:26,240 bu
bir yerde, bir şekilde sabit.

1791
01:25:26,240 --> 01:25:28,690
Yani sadece küçük bir
iyileştirme, ama yine, biz
1792
01:25:28,690 --> 01:25:32,650
Sadece aşılayarak programlamada
daha iyi hale geliyor
1793
01:25:32,650 --> 01:25:34,900 bu
tür buluşsal yöntemler.
1794
01:25:34,900 --> 01:25:39,220 O
halde, C'deki koşullu ifadeler mi
yoksa bu sabitler mi?
1795
01:25:39,220 --> 01:25:39,956 Evet.

1796
01:25:39,956 --> 01:25:45,010
İZLEYİCİ: Neden 9. ve 13. satırlardan
sonra noktalı virgül kullanmıyorsunuz?
1797
01:25:45,010 --> 01:25:49,960
DAVID J. MALAN: Evet, neden 9, 13.
satırlarda noktalı virgül kullanmıyorsunuz?
1798
01:25:49,960 --> 01:25:50,560
Sadece çünkü.
1799
01:25:50,560 --> 01:25:52,600 Dil
bu şekilde tasarlandı.

1800
01:25:52,600 --> 01:25:54,700 Ve
erkenden kafa karıştırıcı.
1801
01:25:54,700 --> 01:25:58,420
Genel olarak konuşursak, koşul
cümlelerini kullanırken-- ve sonunda,

Machine Translated by Google
1802

01:25:58,420 --> 01:25:59,380
döngüler göreceğiz-1803
01:25:59,380 --> 01:26:01,060 noktalı
virgül yok.
1804
01:26:01,060 --> 01:26:05,980
Şimdilik, noktalı virgüllerin genellikle bir işlevden
sonra düşüncenizi bitirdiğini varsayalım.
1805
01:26:05,980 --> 01:26:09,610
Bu, bir buluşsal yöntemin %100 güvenilir
değildir, ancak sizi yolun çoğunu alacaktır
1806
01:26:09,610 --> 01:26:11,140 orada.

1807
01:26:11,140 --> 01:26:11,920 Ve sırf
bu yüzden.
1808
01:26:11,920 --> 01:26:14.920
Bu dillerden bazılarında sol el sağ el ile
konuşmuyordu.
1809
01:26:14,920 --> 01:26:16,390
tasarlandı.
1810
01:26:16,390 --> 01:26:18,590 Pekâlâ,
hadi başka bir şey yapalım.
1811
01:26:18,590 --> 01:26:19,880 Buna
ne dersin?
1812
01:26:19,880 --> 01:26:22,960
Şartlı bir şey sorma yeteneğim
varsa-1813
01:26:22,960 --> 01:26:24,940 bu şey
doğru mu yoksa bu başka bir şey
mi-1814
01:26:24,940 --> 01:26:27,850

Machine Translated by Google
basit bir şey yapan çok basit bir program
yazabilir miyim,
1815
01:26:27,850 --> 01:26:31,180 bana
insan türlerinin bir sayının çift mi
yoksa tek mi olduğunu söylüyor?

1816
01:26:31,180 --> 01:26:33,590
Pekala, bunun için gerekli çerçeveyi
oluşturayım.
1817
01:26:33,590 --> 01:26:36,190
Devam edeyim ve bir
paritenin kodunu yazayım-1818
01:26:36,190 --> 01:26:38,260 çift
veya tek demenin süslü bir yoludur.
1819
01:26:38,260 --> 01:26:44,710 Ve
devam edeyim ve cs50.h, include stdio.h, int
main void-1820
01:26:44,710 --> 01:26:46,720
tekrar, daha fazlası yolda.
1821
01:26:46,720 --> 01:26:50,980
Ama şimdilik, devam edeceğim ve
kullanıcıdan bir n sayısı alacağım.
1822
01:26:50,980 --> 01:26:54,550
get_int'i arayarak ve onlardan
n'nin ne olduğunu sorarak.
1823
01:26:54,550 --> 01:26:58,370 Ve
şimdi biraz sözde kod tanıtacağım.

1824
01:26:58,370 --> 01:27:00,130
İşte bir programın
ilk örneği,
1825
01:27:00,130 --> 01:27:03,200 dürüst
olmak gerekirse, nasıl devam
edeceğimden gerçekten emin değilim.

Machine Translated by Google
1826
01:27:03,200 --> 01:27:05,890 O halde
yorumları kullanarak bazı sözde kodlara
başvurmama izin verin.
1827
01:27:05,890 --> 01:27:08,420 Sonunda
bundan kurtulup gerçek kodu yazacağım.

1828
01:27:08,420 --> 01:27:13,875
Ama eğer n çift ise, o zaman yazdır-1829
01:27:13,875 --> 01:27:15,250 aslında,
bunu yazdırmama izin verin.
1830
01:27:15,250 --> 01:27:18,610
Devam edeyim ve printf, alıntısız
alıntı, "eşit" dememe izin verin,
1831
01:27:18,610 --> 01:27:20.830 çünkü
printf kullanmayı biliyorum.
1832
01:27:20.830 --> 01:27:24,430 başka-tamam, nasıl tek sayı yazdırılacağını
biliyorum,
1833
01:27:24,430 --> 01:27:27,100 o yüzden
printf, alıntısız alıntı, "garip" dememe
izin verin.
1834
01:27:27,100 --> 01:27:30,830 Yani
burada, eğer istersen, problemden bir
nevi ısırık aldım.
1835
01:27:30,830 --> 01:27:33,880 Ve devam
edeyim ve küçük yer tutucularımı
koyayım.
1836
01:27:33,880 --> 01:27:35,780 Bir tür
koşul yapmak istiyorum.
1837
01:27:35,780 --> 01:27:40,600
Yani şimdi soru işaretleri varsa bırak gideyim

Machine Translated by Google

ileri ve buradaki boşlukları doldurun.
1838
01:27:40,600 --> 01:27:42,710 yoksa
bunu buraya koyacağım.
1839
01:27:42,710 --> 01:27:44,740 Sanırım
artık iyiyim.
1840
01:27:44,740 --> 01:27:46,840 Bunu

çözmeye yaklaşıyorum.
1841
01:27:46,840 --> 01:27:50,570 Ama
burada hala bu soru işareti var.

1842
01:27:50,570 --> 01:27:57,290
Gördüğümüz sözdizimini kullanarak n'nin çift
mi yoksa tek mi olduğunu nasıl belirleyebilirim?
1843
01:27:57,290 --> 01:27:58,820 Ne
düşünüyorsun?
1844
01:27:58,820 --> 01:27:59,320 Güzel.

1845
01:27:59,320 --> 01:28:03,250
Daha önce adından bahsettiğim
bu küçük operatör var, geri kalanı
1846
01:28:03,250 --> 01:28:05,300
operatörü, tam olarak bunu yapmanıza
izin verecektir.
1847
01:28:05,300 --> 01:28:07,862
Herhangi bir sayıyı 2'ye bölerseniz,
bu matematiksel buluşsal yöntem
1848
01:28:07,862 --> 01:28:10.570 size çift
mi yoksa tek mi olduğunu söyleyecektir.

1849
01:28:10.570 --> 01:28:12.490 0 veya
1'in kalanı.

Machine Translated by Google
1850
01:28:12,490 --> 01:28:16,240
Ve bu güzel çünkü alternatif aptalca bir
şey yapıyor gibi görünüyor
1851
01:28:16,240 --> 01:28:24,640 n
== 0 ise veya n 2'ye eşitse veya n
4'e eşitse gibi
1852
01:28:24,640 --> 01:28:28,270
Tüm olası soruları sormanız gerekseydi
kodunuz sonsuz uzunlukta olurdu.
1853
01:28:28,270 --> 01:28:35,110
Ama eğer 2'ye bölersem ve
kalana bakarsam-1854
01:28:35,110 --> 01:28:38,480
biraz şifreli ama bu gerçekten işe
yarayacak.
1855
01:28:38,480 --> 01:28:42,670
Yani yüzde işareti kalan
operatördür.
1856
01:28:42,670 --> 01:28:47,990
Pay bölü payda yapar ve bunun sonucunu
değil
1857
01:28:47,990 --> 01:28:50,180
değil, daha çok bunun geri kalanı.
1858
01:28:50,180 --> 01:28:53,710
Yani herhangi bir şeyi 2'ye
bölerseniz, kalan 0 veya 1 olur.
1859
01:28:53,710 --> 01:28:57,880
Ve gerçekten 2, n'ye eşit
olarak bölünürse, size 0 verirse,
1860
01:28:57,880 --> 01:28:59,260 o
zaman bile yazdıracaksınız.
1861

Machine Translated by Google

01:28:59,260 --> 01:29:01,270

Aksi takdirde, garip olmalı.
1862
01:29:01,270 --> 01:29:05,950
Ama bu vurgulanan satırda tuhaf
bir şey var-- kelime oyunu amaçlı--.
1863
01:29:05,950 --> 01:29:11,840
Görünüşe göre yüzde işaretinin yanı
sıra başka bir yeni sözdizimi parçası nedir?
1864
01:29:11,840 --> 01:29:13,100
Orada biraz ne var?
1865
01:29:13,100 --> 01:29:15,210
Evet.
1866
01:29:15,210 --> 01:29:16,740
Evet, bu bir yazım hatası değil.
1867
01:29:16,740 --> 01:29:19,290
Hatta bir an önce kendimi
sözlü olarak söylerken yakaladım,
1868
01:29:19,290 --> 01:29:20.670 sırf
çok kök salmış olduğu için.
1869
01:29:20.670 --> 01:29:24,180
Bunun burada anlamı ne olmalı?
1870
01:29:24,180 --> 01:29:24,905
Evet.
1871
01:29:24,905 --> 01:29:25,780
İZLEYİCİ: [DUYULMAZ]
1872
01:29:25,780 --> 01:29:27,530
DAVID J. MALAN: Evet, eğer bir
şey diğerine denkse.
1873
01:29:27,530 --> 01:29:29,680
Şimdi bu eşitlik operatörü.

Machine Translated by Google
1874

01:29:29,680 --> 01:29:31,480
Sağdan sola atama değil.
1875
01:29:31,480 --> 01:29:33,760
Ve bu da tam anlamıyla
bir örnek,
1876
01:29:33,760 --> 01:29:36,640
insanlar gerçekten ileriyi
planlamıyor, belki de sol taraf
1877
01:29:36,640 --> 01:29:38,740
birinin sağ eli ile konuşmamaya
karar vermesi,
1878
01:29:38,740 --> 01:29:40,360
atama için eşittir işaretini
kullanalım.
1879
01:29:40,360 --> 01:29:43,235
Ve birkaç dakika veya gün sonra,
insanlar, lanet olsun,
1880
01:29:43,235 --> 01:29:45,040
Şimdi eşitlik açısından nasıl karşılaştıracağız?
1881
01:29:45,040 --> 01:29:46,253
Peki, iki tane kullanalım.
1882
01:29:46,253 --> 01:29:49,420
Ve bunun JavaScript gibi bazı dillerde
biraz garip olduğunu düşünüyorsanız,
1883
01:29:49,420 --> 01:29:52,250 Üç
eşittir işareti kullandığınız üçüncü
bir versiyon var.
1884
01:29:52,250 --> 01:29:54,530
Yani, bu dilleri tasarlayan yine
insanlar.
1885
01:29:54,530 --> 01:29:57,727
Yani eğer onlar tarafından hayal kırıklığına uğradıysan,

Machine Translated by Google
kafaları karıştı, eh, kuşkusuz,
1886
01:29:57,727 --> 01:29:59,560 en iyi
tasarım olmayabilirdi.

1887
01:29:59,560 --> 01:30:02,390 Ama o
zamandan beri onunla yaşamak
zorundayız.
1888
01:30:02,390 --> 01:30:04,090 Öyleyse
devam edip burayı uzaklaştırmama izin verin.
1889
01:30:04,090 --> 01:30:06,950 Şimdi
devam edeyim ve burada eşitlik kuralım.
1890
01:30:06,950 --> 01:30:11,770 Öyleyse
parite yap-- ve yine parite sadece
dosyamın adıdır, parity.c.
1891
01:30:11,770 --> 01:30:14,500 ./parity,
2 gibi bir sayı yazın.
1892
01:30:14,500 --> 01:30:15,580 Bu
gerçekten de eşit.
1893
01:30:15,580 --> 01:30:17,620 4, bu
gerçekten eşit.
1894
01:30:17,620 --> 01:30:20.920 3, bu
gerçekten tuhaf ve böyle devam ediyor.
1895
01:30:20.920 --> 01:30:24,070 Test
etmeye devam edersek, muhtemelen aynı
türden cevaplar alacağız.
1896
01:30:24,070 --> 01:30:25,370 Başka
bir şeye ne dersiniz?
1897
01:30:25,370 --> 01:30:28,900
Şimdi devam edeyim ve bu kodun bir kısmını
kopyalayıp yapıştırmaya başlayayım

Machine Translated by Google
1898

01:30:28,900 --> 01:30:31,960 çünkü
kabul etmek gerekirse, yazmaya
devam etmek biraz sıkıcı olmaya başladı
1899
01:30:31,960 --> 01:30:33,880 tüm
bu genel bilgiler üstte.
1900
01:30:33,880 --> 01:30:37,210 Kabul.c
adında bir program oluşturmama
izin verin, bu
1901
01:30:37,210 --> 01:30:39,310 sahip
olduğunuz formlardan herhangi
birini anımsatıyor
1902
01:30:39,310 --> 01:30:43.490 Bir onay
kutusuyla veya evet veya hayır veya benzeri
bir şey yazarak çevrimiçi olarak kabul etmek için.

1903
01:30:43,490 --> 01:30:46,660
Bu ana programın tüm cesaretini
atmama izin verin
1904
01:30:46,660 --> 01:30:48,980 ve
şimdi şöyle bir şey sor.
1905
01:30:48,980 --> 01:30:52.820 Devam
edeyim ve kullanıcıdan bir şeyi kabul
etmesini isteyeyim.
1906
01:30:52.820 --> 01:30:58.000
Devam edeceğim ve şunu söyleyeceğim,
get_string'e ne dersiniz?
1907
01:30:58.000 --> 01:31:03,310 Soru
ne olursa olsun-- ve insanın y veya n
yazmasını istiyorum
1908
01:31:03,310 --> 01:31:05,150
sırasıyla evet veya hayır için.
1909
01:31:05,150 --> 01:31:08,170
Yani eğer sadece tek

Machine Translated by Google
karakter aslında ben
1910
01:31:08,170 --> 01:31:09,810 aslında
sadece get_char ile idare edebilir.
1911
01:31:09,810 --> 01:31:11.560
Daha önce kullanmadım
ama menümüzde vardı
1912
01:31:11,560 --> 01:31:13,540 CS50
kitaplığından işlevler.
1913
01:31:13,540 --> 01:31:16,630
Ve eğer kullanıcının
cevabını almak istersem,
1914
01:31:16,630 --> 01:31:19,700 Dönüş
değeri de sol tarafta bir karakter
olmalıdır.
1915
01:31:19,700 --> 01:31:22,480
Şimdi stringleri, int'leri ve şimdi
de karakterleri gördük,
1916
01:31:22,480 --> 01:31:24,370 eğer
sadece tek bir harfi önemsiyorsak.
1917
01:31:24,370 --> 01:31:29,350 Şimdi
devam edelim, kullanıcının kabul edip
etmediğini kontrol edelim.
1918
01:31:29,350 --> 01:31:38,950
Peki ya c == "y" ise, devam etmeme izin verin
ve küme parantezlerimin içinde,
1919
01:31:38,950 --> 01:31:43,100
kararlaştırılan çıktı veya buna benzer
bir cümle.
1920
01:31:43,100 --> 01:31:45,760 eğer c
yazmamışlarsa-- ya da ne biliyor
musunuz?
1921

Machine Translated by Google
01:31:45,760 --> 01:31:47,590

Burada açık olalım,
böylece yapamazlar
1922
01:31:47,590 --> 01:31:50,260 z veya
b yazın veya rastgele bir harf.
1923
01:31:50,260 --> 01:31:58,210 else
eğer c=="n" n hayır ise, o zaman devam
edeyim ve kararlaştırılmamış bir çıktı alın,
1924
01:31:58,210 --> 01:31:59,178 veya
buna benzer bir şey.
1925
01:31:59,178 --> 01:32:01,720
Ve eğer işbirliği yapmazlarsa
kullanıcıyı görmezden geleceğim.
1926
01:32:01,720 --> 01:32:05,980 ve z
veya b veya y veya n olmayan bir
şey yazarlar.
1927
01:32:05,980 --> 01:32:12,340 Pekala,
şimdi devam edip bu kodu derlememe
izin verin, katılıyorum, ./agree.
1928
01:32:12,340 --> 01:32:13,270 Pekala,
katılıyor muyum?
1929
01:32:13,270 --> 01:32:13,770 Evet.

1930
01:32:13,770 --> 01:32:16,450
Varsayılan ile devam edelim.
Tamam, bu işe yarıyor gibi görünüyor.

1931
01:32:16,450 --> 01:32:18,400 Hayır,
bu sefer aynı fikirde değilim.
1932
01:32:18,400 --> 01:32:19,610 Bu işe
yarıyor gibi görünüyor.
1933
01:32:19,610 --> 01:32:25,120

Machine Translated by Google
Büyük harf kilidi anahtarım açık mı yoksa
gerçekten bağırıyorum, büyük Y?
1934
01:32:25,120 --> 01:32:26,110 Beni
görmezden geliyor.
1935
01:32:26,110 --> 01:32:29,172 Büyük
N, beni görmezden geliyor.
1936
01:32:29,172 --> 01:32:32,380
Yani, açıkçası, bir hata, en azından büyük ve
küçük harfleri tolere etmek istiyorsam,
1937
01:32:32,380 --> 01:32:34,220 bu biraz
mantıklı.
1938
01:32:34,220 --> 01:32:39,680 Peki
burada olası çözümler neler olabilir
sizce?
1939
01:32:39,680 --> 01:32:42.820 Bunu nasıl
çözerim ve hem büyük harfe hem de
küçük harfe nasıl tahammül edebilirim?

1940
01:32:42.820 --> 01:32:45.535 Belki
de en basit, en saf uygulama nedir?

1941
01:32:45.535 --> 01:32:47,690
İZLEYİCİ: [DUYULMAZ]
1942
01:32:47,690 --> 01:32:50,190 DAVID
J. MALAN: Evet, neden iki soru sormuyorum?

1943
01:32:50,190 --> 01:32:54,750
Ya da biliyor musunuz, daha önce gördüklerimize
dayanarak daha da basite indirgemek-1944
01:32:54,750 --> 01:32:58,110 izin
verirseniz, bu kodun bir kısmını
kopyalayıp yapıştırmama izin verin.
1945

Machine Translated by Google

01:32:58,110 --> 01:33:02,980 Bunu
bir else olarak değiştirin-- whoops,

büyük harflerle değil-- yoksa "Y" ise.
1946
01:33:02,980 --> 01:33:04,980 Ve
bahse girerim aynı şeyi n ile de
yapabilirim.
1947
01:33:04,980 --> 01:33:06,840
Ama burada da, tıpkı
Scratch'ta olduğu gibi, en kısa sürede

1948
01:33:06,840 --> 01:33:08,923 kendinizi
kopyalayıp yapıştırırken bulmaya
başlayınca,
1949
01:33:08,923 --> 01:33:10.680
muhtemelen yanlış bir şey yapıyorsun.
1950
01:33:10,680 --> 01:33:14,010 Ve sözlü
olarak söyledikleriniz, eğer izin
verirseniz, aslında daha iyiydi.
1951
01:33:14,010 --> 01:33:20,700
Çünkü OR c == "Y" gibi bir şey söyleyebileceğimi
ima ediyorsun
1952
01:33:20,700 --> 01:33:24,040 veya
burada, c == "N".
1953
01:33:24,040 --> 01:33:30,910 Sorun
şu ki, OR kelimesini C'de kullanamazsınız. Aslında
bu iki dikey çubuktur.
1954
01:33:30,910 --> 01:33:34,380 Böylece
bir soruyu veya diğerini ifade
edebilirsiniz.
1955
01:33:34,380 --> 01:33:37,500
Evet veya doğru olmak için
cevaplardan sadece birine ihtiyacınız var,

1956
01:33:37,500 --> 01:33:39,420 ve iki
dikey çubuk kullanıyorsunuz.

Machine Translated by Google
1957
01:33:39,420 --> 01:33:42,180
Tam tersine,
görmüşsünüzdür,
1958
01:33:42,180 --> 01:33:45,540 bir
şeyin VE başka bir şeye eşit olup olmadığını
kontrol etmek istedi,
1959
01:33:45,540 --> 01:33:48.090 iki
ve işareti kullanabilirsiniz.
1960
01:33:48,090 --> 01:33:50,610 Bu
mantıklı olsa da burada hiçbir
anlam ifade etmeyecektir.
1961
01:33:50,610 --> 01:33:53,850
Elbette insanın yazdıkları hem küçük hem
de büyük olamaz.
1962
01:33:53,850 --> 01:33:55,120 Bu
hiç mantıklı değil.
1963
01:33:55,120 --> 01:33:56,910 Yani
bu durumda VEYA istiyoruz.
1964
01:33:56,910 --> 01:33:58,675
Ancak bu, kodumu sıkılaştırmamı
sağlıyor.
1965
01:33:58,675 --> 01:34:01,050 Tüm
dalları kopyalayıp yapıştırmaya
başlamam gerekmiyor.
1966
01:34:01,050 --> 01:34:04,760 Artık
aynı anda iki soru sorabiliyorum.
1967
01:34:04,760 --> 01:34:08,070 Peki
bu varyasyon hakkında sorular?
1968
01:34:08,070 --> 01:34:09,068
Gerçekten güzel bir soru.

Machine Translated by Google
1969

01:34:09,068 --> 01:34:10.860
Girdiyi tamamen küçük harfe
dönüştürebilir misiniz?

1970
01:34:10.860 --> 01:34:12.030
Kesinlikle yapabilirsin.
1971
01:34:12,030 --> 01:34:13,680
Henüz yeteneğimiz yok.
1972
01:34:13,680 --> 01:34:16,140
Görünüşe göre bu-1973
01:34:16,140 --> 01:34:18,365
kolay olsun, başka bir kütüphane,
yine de yapabilsek
1974
01:34:18,365 --> 01:34:21,240
geçen haftadan beri ASCII veya
Unicode hakkında biraz bilgi sahibiyiz.
1975
01:34:21,240 --> 01:34:25,313
Ama, evet, bu bir alternatif olurdu, ama
daha fazlası farklı bir zamanda.
1976
01:34:25,313 --> 01:34:25,980
Başka sorular?
1977
01:34:25,980 --> 01:34:28,340
İZLEYİCİ: [DUYULMAZ]
1978
01:34:28,340 --> 01:34:29,590
DAVID J. MALAN: Güzel soru.
1979
01:34:29,590 --> 01:34:33,187 Ne
yazık ki, C'de açık olmak zorundasınız.
Bunu öylece söyleyemezsiniz,
1980
01:34:33,187 --> 01:34:35,520
gerçi sen böyle düşünebilirsin.

1981

Machine Translated by Google
01:34:35,520 --> 01:34:40,440
Eşitlik işaretini iki kez kullanarak tam bir
soru sormalısınız.
1982
01:34:40,440 --> 01:34:41.430 bu
durumda.
1983
01:34:41.430 --> 01:34:43,140
Şimdi ben de bir soru sorayım.
1984
01:34:43,140 --> 01:34:44,250 Bu bir
yazım hatası değil.

1985
01:34:44,250 --> 01:34:48,960
Buradaki tüm harflerimin etrafında
kasıtlı olarak tek tırnak işaretleri kullandım.
1986
01:34:48,960 --> 01:34:50,550
Neden olabilir?
1987
01:34:50,550 --> 01:34:54,720
Önceden, metne benzeyen her şey
için çift tırnak kullanırdık.
1988
01:34:54,720 --> 01:34:57,110 Evet.

1989
01:34:57,110 --> 01:35:00,170
Doğru, dize birden çok karakter için
çift tırnaktır-- hatta bir tane,
1990
01:35:00,170 --> 01:35:01,250
teknik olarak, ama evet.
1991
01:35:01,250 --> 01:35:05,410 Ve
tek karakterler için tek tırnak.
1992
01:35:05,410 --> 01:35:07.000
Çünkü veri tipim farklı.
1993
01:35:07.000 --> 01:35:09,970 Tek
bir karakter kullanarak basit yolu
seçtim.

Machine Translated by Google
1994
01:35:09,970 --> 01:35:12,550
Aslında, bu program
YES ile çalışmayacak
1995
01:35:12,550 --> 01:35:16,240 veya
NO. Bu şu anda desteklenmiyor-- daha
fazlası için başka bir zaman.
1996
01:35:16,240 --> 01:35:19,030 Tek
tırnak kullanmak zorunda kaldım
çünkü C böyle yapıyor.
1997
01:35:19,030 --> 01:35:20.990
Tek karakterlerle
uğraşıyorsanız,
1998
01:35:20.990 --> 01:35:23.050 aka
karakter, tek tırnak kullanın.
1999
01:35:23,050 --> 01:35:23,980
Eğer bu bir ipse-2000
01:35:23,980 --> 01:35:27,790 bir
dizgede tek bir karakter olsa bile

2001
01:35:27,790 --> 01:35:30,823 sanki
daha uzun bir kelime veya cümle
yazmaya başlıyormuşsun gibi-2002
01:35:30,823 --> 01:35:31,990 bu çift
tırnak olur.
2003
01:35:31.990 --> 01:35:34,060 Ve
bunun neden olduğunu da çok
geçmeden göreceğiz.
2004
01:35:34,060 --> 01:35:37,750
Ancak yine de, kod yazarken akılda
tutulması gereken şeyler
2005
01:35:37,750 --> 01:35:39,940

Machine Translated by Google
bu özel dilde.
2006
01:35:39,940 --> 01:35:42,170 Evet,
burada.
2007
01:35:42,170 --> 01:35:47,260 Yani
kısa cevap, eğer doğru anlıyorsam bu
yanlış olur.
2008
01:35:47,260 --> 01:35:49,470 Ve
bu daha da yanlış olur.
2009
01:35:49,470 --> 01:35:51,970
Ama sakıncası yoksa, birkaç
hafta tenekeyi tekmelememe izin ver.
2010
01:35:51,970 --> 01:35:53.680
bunun neden işe yaramadığına dair.
2011
01:35:53,680 --> 01:35:58,052
Bunu yapmanın en keyifli yolu gerçekten de
böyle bir şey yapmak olabilir.
2012
01:35:58,052 --> 01:36:000,010
Ama bu bile kaygan bir eğim,
çünkü ne
2013
01:36:00,010 --> 01:36:03,378
Kullanıcı garip bir şey yaparsa, sanki
sadece Y'yi büyük harf kullanıyormuş gibi?

2014
01:36:03,378 --> 01:36:05,170
Bunun hızla dağıldığını hayal
edebilirsiniz.
2015
01:36:05,170 --> 01:36:07,510
Her şeyi zorlamak
hakkındaki fikrini beğendim
2016
01:36:07,510 --> 01:36:09,760
sadece işleri standartlaştırmak için küçük harfe.
2017
01:36:09,760 --> 01:36:13,900

Machine Translated by Google
Ne yazık ki, böyle eşitlik için dizeleri
karşılaştıramazsınız
2018
01:36:13,900 --> 01:36:15,980
çünkü yine çok geçmeden
sebepler ortaya çıkacak.
2019
01:36:15,980 --> 01:36:18,880
Bugün için, her ne kadar
tartışmaya açık olsa da, basit tutuyoruz.
2020
01:36:18,880 --> 01:36:22,840
sadece tek tek harfleri tolere
edecek kadar kullanıcı dostu değil.
2021
01:36:22,840 --> 01:36:26,020 Ve
burada bir soru var.
2022
01:36:26,020 --> 01:36:28,180
ABD İngilizcesi klavyesinde
vardiya ve sonra
2023
01:36:28,180 --> 01:36:31,280
Return üzerindeki ters eğik çizgi
tuşu, ancak klavyenize bağlı olarak,
2024
01:36:31,280 --> 01:36:33,520 değişiklik
gösterecektir.

2025
01:36:33,520 --> 01:36:36,340
Pekala, şimdi
aslında geriye bakalım
2026
01:36:36,340 --> 01:36:38,380
geçen hafta biraz yaptığımız bir
şeyde.
2027
01:36:38,380 --> 01:36:41,170
Devam edeyim ve miyav.c adlı bir
dosya açayım,
2028
01:36:41,170 --> 01:36:43.660
çünkü hatırlayın, Scratch'e
başlangıçta bunu yaptırmıştık.

Machine Translated by Google
2029
01:36:43,660 --> 01:36:46,450
dahil etmeme izin ver
Bu sefer C50 kütüphanesi,
2030
01:36:46,450 --> 01:36:50,350 ama
sadece stdio.h çünkü bu demo için
sadece printf istiyorum.
2031
01:36:50,350 --> 01:36:53,920 Şimdi
devam edip miyav yazdırayım.

2032
01:36:53,920 --> 01:36:57,610
Ve eğer kedinin geçen hafta yaptığı gibi üç
kez miyavlamasını istersem,
2033
01:36:57,610 --> 01:36:58,990
miyav miyav miyav.

2034
01:36:58,990 --> 01:36:59,830 Kaydedin.

2035
01:36:59,830 --> 01:37:01,910 miyav
yap, ./miyav.
2036
01:37:01,910 --> 01:37:02,410 İşte.

2037
01:37:02,410 --> 01:37:05,320 Program
yazıldı-- doğru, iddia ediyorum.

2038
01:37:05,320 --> 01:37:05,950 Çalıştı.

2039
01:37:05,950 --> 01:37:06,790 Tamam
derlendi.
2040
01:37:06,790 --> 01:37:09,040
Ama yine de, bu
konuşmamızın başlangıcıydı.

Machine Translated by Google
2041

01:37:09,040 --> 01:37:11,740
geçen hafta özellikle iyi
tasarlanmamıştı.
2042
01:37:11,740 --> 01:37:14.830
Ve eğer biri şimdi bariz olana işaret
etmek isterse,
2043
01:37:14,830 --> 01:37:19,580 Bu
neden iyi tasarlanmış değil?

2044
01:37:19,580 --> 01:37:21,020
Evet, sadece tekrar, değil mi?
2045
01:37:21,020 --> 01:37:23,093 Yine, kelimenin
tam anlamıyla kopyala-yapıştır yöntemine
başvurdum.

2046
01:37:23,093 --> 01:37:25,010
Muhtemelen olduğun
sinyal bu olmalı
2047
01:37:25,010 --> 01:37:29,070 bu
durumda yanlış bir şey yapmak ya da
en iyi ihtimalle tembellik etmek.
2048
01:37:29,070 --> 01:37:31,395
Çözüm, geçen haftadan
anlayabileceğiniz gibi,
2049
01:37:31,395 --> 01:37:33,770
muhtemelen döngü denen
şeylerden biri olacak.
2050
01:37:33,770 --> 01:37:36,470
Şimdi C'deki döngüler için bazı
sözdizimlerine bir göz atalım.
2051
01:37:36,470 --> 01:37:39,283
Ama yine, yeni fikir yok,
sadece yeni bir sözdizimi
2052

Machine Translated by Google
01:37:39,283 --> 01:37:40,700

buna alışmak biraz zaman alacak.
2053
01:37:40,700 --> 01:37:44,330
Scratch'te, bunun gibi bir şeyle
sonsuza kadar miyavlamak istiyorsanız,
2054
01:37:44,330 --> 01:37:49.080 C'de
sonsuza kadar anahtar kelime yoktur, bu
yüzden buna bakmak biraz garip.
2055
01:37:49.080 --> 01:37:50,420 Ama
yapabileceğimizin en iyisi bu.
2056
01:37:50,420 --> 01:37:54,530 C'de
while adında bir anahtar kelime
olduğu ortaya çıktı.
2057
01:37:54,530 --> 01:37:56,750
Ve bu tür doğru
anlambilime sahip,
2058
01:37:56,750 --> 01:37:59,940
çünkü sanki bir şeyi tekrar tekrar
yapıyormuşum gibi,
2059
01:37:59,940 --> 01:38:01,430
yapabileceğimin en iyisi bu.
2060
01:38:01,430 --> 01:38:05,990
Ama tıpkı bir if koşulu veya
başka bir if koşulu gibi,
2061
01:38:05,990 --> 01:38:09,260
parantez içinde Boole ifadesi
alanlar,
2062
01:38:09,260 --> 01:38:12,330 bir
while döngüsü ayrıca parantez içinde
bir Boole ifadesi alır.
2063
01:38:12,330 --> 01:38:13,730 Bir
soru sormam gerekiyor.

Machine Translated by Google
2064

01:38:13,730 --> 01:38:17,240
Şimdi, eğer sonsuza kadar bir şey
yapmak istersem, aptalca bir şekilde
2065
01:38:17,240 --> 01:38:21.740 2'nin
1'den büyük olduğunu, 3'ün ise 2'den
büyük olduğunu söyleyin,
2066
01:38:21,740 --> 01:38:23,630 veya
tamamen keyfi bir şey.
2067
01:38:23,630 --> 01:38:27,440 Ama
bu seni yanlış anlamalı, çünkü neden 2'ye
1?
2068
01:38:27,440 --> 01:38:32,330 Neden
3-- doğru istiyorsanız doğru deyin.
2069
01:38:32,330 --> 01:38:36,980
Görünüşe göre C'de doğru ve
yanlış özel anahtar kelimeler var,

Sırasıyla kelimenin tam anlamıyla
doğru ve yanlış olan 2070 01:38:36,980
--> 01:38:40,100.
2071
01:38:40,100 --> 01:38:44,540
Ayrıca 1 sayısını doğru, 0 sayısını da
yanlış olarak koyabilirim.
2072
01:38:44,540 --> 01:38:47,280 ama
çoğu insan açık olmak için doğru
diyebilir.
2073
01:38:47,280 --> 01:38:50,630 Yani
biraz kaba, ama çok geleneksel.

2074
01:38:50,630 --> 01:38:54,980 C
dilinde sonsuza kadar anahtar kelime yok.
Eğer sonsuza kadar miyav yazdırmak istersem,
2075
01:38:54,980 --> 01:38:57,390

Machine Translated by Google
Burada sadece printf
gibi bir şey kullanacağım.
2076
01:38:57,390 --> 01:38:59,930
Yani, yine, birinden
mükemmel çeviri değil
2077
01:38:59,930 --> 01:39:02,907
diğerine, ancak C'de kesinlikle
mümkün. Peki ya bu?
2078
01:39:02,907 --> 01:39:05,240
Bir şey yapmak istiyorsanız bu
biraz daha yaygın
2079
01:39:05,240 --> 01:39:08,480
sonlu sayıda, tekrar 3 gibi.
2080
01:39:08,480 --> 01:39:13,100
Bunu C'de yapmanın birkaç farklı yolu
var. İşte bir yaklaşım.
2081
01:39:13,100 --> 01:39:16,670
Ve işte burada C-- birçok
metin tabanlı dil gibi,
2082
01:39:16,670 --> 01:39:20,120
Tüm temel binalardan oluşan o araç
setini bir nevi kırbaçlamanız gerekiyor.
2083
01:39:20,120 --> 01:39:22,370
bloklar ve bir düşünün, tamam,
nasıl yapabilirim
2084
01:39:22,370 --> 01:39:27,080
Yazılımda birkaç kez bir şeyler yapan
küçük bir makine mi inşa ediyorsunuz?
2085
01:39:27,080 --> 01:39:31,580
Peki, kendime sayaç adında bir
değişken vereyim, onu 0'a eşitle.
2086
01:39:31,580 --> 01:39:37,940
Boolean olan bir döngü oluşturmama izin verin

Machine Translated by Google
ifade 3'ten küçük bir sayaçtır,
2087
01:39:37,940 --> 01:39:41,510
Buradaki fikir, neden sadece 1, 2,
3 saymıyorum?
2088
01:39:41,510 --> 01:39:44,990 Peki
bu fizikselliği kodda nasıl uygularım?

2089
01:39:44,990 --> 01:39:48,380 Kendime
bir değişken veriyorum, onu 0, 0
parmak yukarıya ayarladım.

2090
01:39:48,380 --> 01:39:51,200 Şimdi
soruyorum, sayaç 3'ten küçük mü?

2091
01:39:51,200 --> 01:39:54,170
Öyleyse devam edin ve miyav yazdırın.
2092
01:39:54,170 --> 01:39:57,530
Ve sadece sezgisel olarak, hiç C
kodunu veya herhangi bir kodu görmemiş olsanız bile

2093
01:39:57,530 --> 01:40:00,680
Scratch'ten önce, daha ne yapmam
gerekiyor?
2094
01:40:00,680 --> 01:40:03,620
Burada bir satır daha mantık için
yer bıraktım.
2095
01:40:03,620 --> 01:40:05,190 Evet.

2096
01:40:05,190 --> 01:40:06,420
Sayacı artırmamız gerekiyor.
2097
01:40:06,420 --> 01:40:10,350 Yani
daha önce gösterdiğim gibi bir koda
ihtiyacım var, sayıcı eşittir sayaç artı 1 gibi.
2098

Machine Translated by Google
01:40:10,350 --> 01:40:12,600
Ve işte burada bazen

programlama
2099
01:40:12,600 --> 01:40:14,120 biraz
daha sıhhi tesisat gibi oluyor.
2100
01:40:14,120 --> 01:40:16,620 Ne
demek istediğinizi Scratch
yapamıyormuş gibi söyleyemezsiniz.
2101
01:40:16,620 --> 01:40:19,200
Küçük bir çeşit yazılım
makinesi yapmalısın

2102
01:40:19,200 --> 01:40:22,380 bir
değeri başlatır, bir şey yapar,
artırır, kontrol eder.
2103
01:40:22,380 --> 01:40:25,290
Ve bu bir nevi yazılımtabanlı makine gibi,
2104
01:40:25,290 --> 01:40:28,410 ama
birlikte, bu sadece bazı tanıdık
yapı taşlarını kullanıyor.
2105
01:40:28,410 --> 01:40:29,580 Ama
bu oldukça yaygın.
2106
01:40:29,580 --> 01:40:31,872
Tıpkı Scratch'ta olduğu gibi,
döngüleri bir demet kullanmış olabilirsiniz.

2107
01:40:31,872 --> 01:40:33,360 kez,
C dilinde oldukça yaygın.
2108
01:40:33,360 --> 01:40:35,250 Bu
kodu biraz daha sıkılaştırabilir miyiz?
2109
01:40:35,250 --> 01:40:39,780 Bu
doğru, ancak burada popüler olan
bazı kurallar var.

Machine Translated by Google
2110

01:40:39,780 --> 01:40:42,225 Eğer
sayacaksanız i demeniz yeterli.
2111
01:40:42,225 --> 01:40:44,100
Programlamada
bir gelenek-- en azından,
2112
01:40:44,100 --> 01:40:48,690 C
gibi diller-- tüm amacı şuysa i'yi
bir tamsayı olarak kullanmaktır.
2113
01:40:48,690 --> 01:40:50,850,
0'dan yukarıya doğru saymaktır.
2114
01:40:50,850 --> 01:40:52,240
Sayaç yanlış değil.
2115
01:40:52,240 --> 01:40:53,100 Fena
değil.
2116
01:40:53,100 --> 01:40:55,980
Sadece olması gerekenden daha
ayrıntılı.
2117
01:40:55,980 --> 01:40:56,940
Sadece i deyin.
2118
01:40:56,940 --> 01:40:58,732
Bundan daha fazla anlambilime ihtiyacınız yok.
2119
01:40:58,732 --> 01:41:00,190
Pekala, burada başka ne yapabilirim?
2120
01:41:00,190 --> 01:41:03,377 Bu
kodu sıkılaştırmak için başka bir
fırsat daha var.
2121
01:41:03,377 --> 01:41:03,960
Hatırlıyor musunuz?
2122
01:41:03,960 --> 01:41:05,920 Evet.

Machine Translated by Google
2123
01:41:05,920 --> 01:41:08,920
Evet, yeni hiçbir şey yapmayan
sözdizimsel şeker,
2124
01:41:08,920 --> 01:41:10,720 ama
bunu daha özlü bir şekilde yapıyor.
2125
01:41:10,720 --> 01:41:15,190
Bunu ara formata veya daha sıkı
bir şekilde değiştirebilirim
2126
01:41:15,190 --> 01:41:16,900 biçimi
sadece i++.
2127
01:41:16,900 --> 01:41:19,120 Şimdi,
bu oldukça kanonik.
2128
01:41:19,120 --> 01:41:23,140
Çoğu insan bir şeyi bu
şekilde uygular
2129
01:41:23,140 --> 01:41:25,810 C'de
bir döngü kullanarak üç kez-2130
01:41:25,810 --> 01:41:27,535 while
döngüsü kullanarak yani.
2131
01:41:27,535 --> 01:41:30,550
C ve diğer dillerde çok yaygın
olduğu ortaya çıktı
2132
01:41:30,550 --> 01:41:34,360 Bir
şeyi sonlu sayıda yapmak için, bunu
yapmanın birkaç yolu vardır.
2133
01:41:34,360 --> 01:41:37,220
Bu modelde, açık
olmak gerekirse, mantık,
2134
01:41:37,220 --> 01:41:40,420
Burada vurguladığım gibi değişkeni
başlatarak başlıyoruz.

Machine Translated by Google
2135
01:41:40,420 --> 01:41:43,510 Daha
sonra şu soruyu soruyoruz: 0'dan
küçük mü?
2136
01:41:43,510 --> 01:41:47,230
Eğer öyleyse, küme
parantezlerinin içine girintili olan her şey
2137
01:41:47,230 --> 01:41:50,440
çalıştırılır-- yani, miyav ve ardından
güncelleme.
2138
01:41:50,440 --> 01:41:54,130
Sonra bilgisayar durumu yeniden
kontrol etmek zorunda kalacak
2139
01:41:54,130 --> 01:41:57,730 3'ten
büyük olmayacak kadar
büyümediğimden emin olmak için.
2140
01:41:57,730 --> 01:42:00,820 Ama
değilse, bunu tekrar yapar ve bunu
tekrar yapar.
2141
01:42:00,820 --> 01:42:03,245
Ve sonra durumu sürekli kontrol
ederek tekrar eder.
2142
01:42:03,245 --> 01:42:05,620 ve
blokta olanı yürütür, durumu
kontrol eder
2143
01:42:05,620 --> 01:42:07,037 ve
blokta olanı yürütmek.
2144
01:42:07,037 --> 01:42:11.590
Bundan üç kez sonra, koşul yanlış olacak
veya cevap yok,
2145
01:42:11.590 --> 01:42:12,820 ve
kod bu kadar.
2146

Machine Translated by Google
01:42:12,820 --> 01:42:15,940

Scratch'ta olduğu gibi burada ne
varsa ona gider.
2147
01:42:15,940 --> 01:42:18,590
Aşağıdaki sonraki bloklara atlar.
2148
01:42:18,590 --> 01:42:21,380
Pekala, bunu yapmanın başka bir
yolu nedir?
2149
01:42:21,380 --> 01:42:23,380
Şey, ben bilerek 0'dan
sayıyorum-2150
01:42:23,380 --> 01:42:25,172 ve bu
bir programlama kuralı, değil mi?

2151
01:42:25,172 --> 01:42:27,887 Geçen
haftaya 0 olan tüm ampuller
kapalıyken başladık.
2152
01:42:27,887 --> 01:42:30,220
Bu yüzden 0'lardan saymaya
başlamak oldukça mantıklı, sadece

2153
01:42:30,220 --> 01:42:31,053
burada yaptığınız gibi.
2154
01:42:31,053 --> 01:42:33,070
Sanki, parmaklar havada değil, bu 0-2155
01:42:33.070 --> 01:42:34,760
parmaklar elinizde.
2156
01:42:34,760 --> 01:42:39,040 Ama
isterseniz, saymaya i eşittir 1'den
başlayabilirsiniz.
2157
01:42:39,040 --> 01:42:42,340
Ama o zaman ben 3'ten
küçükken bunu yapmak istemezsin.

Machine Translated by Google
2158

01:42:42,340 --> 01:42:45,400
yapmak istediğiniz i, 3'ten küçük
veya eşittir.
2159
01:42:45,400 --> 01:42:49,840
Çoğu klavyede, küçüktür veya eşittir veya
büyüktür için bir sembol yoktur.
2160
01:42:49,840 --> 01:42:53.890 veya
eşittir, yani C'de iki karakter
kullanırsınız,
2161
01:42:53.890 --> 01:42:57,010 ve
ardından aralarında boşluk olmayan
bir eşittir işareti.
2162
01:42:57,010 --> 01:42:59,450 Bu
sadece daha küçük veya eşittir anlamına gelir.
2163
01:42:59,450 --> 01:43:03,970
i'yi 2'ye ayarlayarak bu koşulu
şundan küçük yapabiliriz.
2164
01:43:03,970 --> 01:43:05.020 veya
4'e eşit.
2165
01:43:05,020 --> 01:43:10,100 Bunun
10 ve 12'den küçük veya 12'ye eşit
olmasını sağlayabiliriz.
2166
01:43:10,100 --> 01:43:12,010 Ama
yine de, sadece temel bilgilere bağlı kalın.
2167
01:43:12,010 --> 01:43:15,130 0'dan
başlayın ve yukarıya doğru sayın
kural olacaktır.
2168
01:43:15,130 --> 01:43:18.490 Ya da
geri saymayı tercih ederseniz, bu
da sorun değil.
2169
01:43:18,490 --> 01:43:22,900
i'yi 3'e ayarlayın ve sonra bunu yapın

Machine Translated by Google
0'dan büyük olduğu sürece,
2170
01:43:22,900 --> 01:43:25,752 ama
artırmak yerine azaltmak
zorundasınız.
2171
01:43:25,752 --> 01:43:27,460 Yani
yine, bunu tüm gün boyunca
yapabiliriz.
2172
01:43:27,460 --> 01:43:30,595 Bu
fikri uygulamak için kelimenin tam
anlamıyla sonsuz sayıda yol var.
2173
01:43:30,595 --> 01:43:32,470 İşte
bu yüzden gelenekleri vurgulamaya
devam ediyorum.
2174
01:43:32,470 --> 01:43:34,960
Bunun gibi bir şey için i
değişkenini çağırın,
2175
01:43:34,960 --> 01:43:38,470
bunun gibi bir şey için 0'a sıfırlayın ve
genel olarak sayın,
2176
01:43:38,470 --> 01:43:40,360 eğer
gerçekten geri saymayı tercih etmiyorsanız.
2177
01:43:40,360 --> 01:43:43,120 Yine,
sadece belirli insan gelenekleri.
2178
01:43:43,120 --> 01:43:46,310
Pekala, bunu yapmanın başka bir
yoluna ne dersiniz?
2179
01:43:46,310 --> 01:43:50,270 Bu,
C'de for döngüsü olarak adlandırılır
ve çok yaygındır.
2180
01:43:50,270 --> 01:43:53,290
Gerçekten yukarıyı okumadığı için
o kadar basit değil

Machine Translated by Google
2181
01:43:53,290 --> 01:43:55,210
tam olarak aynı şekilde en alta.
2182
01:43:55,210 --> 01:43:58,600 Bu
tür ilk satırında çok daha fazla
mantık barındırıyor.
2183
01:43:58,600 --> 01:44:01,120
Ama tamamen aynı şeyi yapıyor.
2184
01:44:01,120 --> 01:44:02,830
Burada olan şey...
2185
01:44:02,830 --> 01:44:06,550
parantez içinde, kelimesinin
yanında,
2186
01:44:06,550 --> 01:44:09,722 iki
noktalı virgül var-- bu da
sözdiziminin bir başka garip kullanımı.
2187
01:44:09,722 --> 01:44:11,680
Çizginin sonunda
değiller, şimdi onlar
2188
01:44:11,680 --> 01:44:13,055
parantezlerin ortasında.
2189
01:44:13,055 --> 01:44:15,230
Ama insanlar yıllar önce bunu
seçti.
2190
01:44:15,230 --> 01:44:22,150
Noktalı virgüllerden önceki ilk şey
değişkeninizi başlatır, int i = 0.
2191
01:44:22,150 --> 01:44:25,240
Bir sonraki şey, sürekli olarak
alacak olan koşuldur.
2192
01:44:25,240 --> 01:44:27,760 bu
döngü boyunca her döngüyü kontrol etti.

Machine Translated by Google
2193

01:44:27,760 --> 01:44:32,560
Ve son şey, her döngüden sonra
yaptığınız şey olacak, ki bu
2194
01:44:32,560 --> 01:44:34,190 bu
durumda sayılacak.
2195
01:44:34,190 --> 01:44:36,910 Yani,
tekrar geri sararsam i'yi 0 olarak
başlatırız.
2196
01:44:36,910 --> 01:44:39,550 Sonra
şu soruyu soruyoruz, ben 3'ten
küçük müyüm?
2197
01:44:39,550 --> 01:44:43.810 Eğer
öyleyse, döngünün içindekini
yürütün.
2198
01:44:43,810 --> 01:44:49,690 Sonra
bilgisayar bunu yapıyor, güncellemeyi
yapıyor, i'yi 1 artırıyor.
2199
01:44:49,690 --> 01:44:52,420 Ve
sonra tekrar körü körüne
miyavlamayacak.
2200
01:44:52,420 --> 01:44:55,780
Durumu tekrar kontrol edecek,
3'ten küçük mü?
2201
01:44:55,780 --> 01:44:57,550 Eğer
öyleyse miyavlayacak.
2202
01:44:57,550 --> 01:45:01,960 Sonra
devam edip i'yi artırıp durumu tekrar kontrol
edebilir.
2203
01:45:01,960 --> 01:45:05,648 Yani,
yine, bu tamamen aynı basit modayı
yukarıdan aşağıya okumuyor.
2204
01:45:05,648 --> 01:45:07,940

Machine Translated by Google
Soldan sağa okursun ve

sonra etrafta zıplarsın.
2205
01:45:07,940 --> 01:45:13,090
Ama yine, başlatma, sabit Boole
ifadesi
2206
01:45:13,090 --> 01:45:15,880
kontrol ediliyor ve her seferinde
güncelleme
2207
01:45:15,880 --> 01:45:23,750 bu
while döngüsü formatında biraz önce
gördüğümüzün aynısını yapıyor.
2208
01:45:23,750 --> 01:45:25,300
Hangisi daha iyi?
2209
01:45:25,300 --> 01:45:26,210 Eh,
aynılar.
2210
01:45:26,210 --> 01:45:28,252
Bence çoğu insan muhtemelen
sonunda kullanırdı
2211
01:45:28,252 --> 01:45:33,770 for
döngüsü bir kez rahat, ancak bunun
nedeni gerçekten cevap orada.
2212
01:45:33,770 --> 01:45:36,870
Pekala, o zaman, C'ye çevirdiğimiz
döngüler hakkında herhangi bir sorunuz var mı?
2213
01:45:36,870 --> 01:45:37,370 Evet.

2214
01:45:37,370 --> 01:45:39,122
İZLEYİCİ: [DUYULMAZ]
2215
01:45:39,122 --> 01:45:40,830
DAVID J. MALAN: Bir for döngüsü
ve while döngüsü
2216

Machine Translated by Google

01:45:40.830 --> 01:45:44,340
tamamen aynı şeyi yapmak için
kullanılabilir.

2217
01:45:44,340 --> 01:45:47,932
Kapsam konularında ince
farklılıklar vardır,
2218
01:45:47,932 --> 01:45:49,890 çok
geçmeden tartışacağız, nerede ne
zaman
2219
01:45:49,890 --> 01:45:52,120 for
döngüsünde bir değişken oluşturun-2220
01:45:52,120 --> 01:45:55,590 yine
bu parantezlerin içinde olduğuna
dikkat edin.
2221
01:45:55,590 --> 01:46:000,030
teknik olarak sadece bu dört kod
satırında var olacağı anlamına gelir.
2222
01:46:000,030 --> 01:46:03,780
Buna karşılık, while döngüsü ile,
Değişkenimi dışarıda ilan ettim
2223
01:46:03,780 --> döngünün
01:46:04,410.
2224
01:46:04,410 --> 01:46:08,230 Bu
değişken programımda başka bir
yerde var olmaya devam edecek.
2225
01:46:08,230 --> 01:46:11.207 Yani
buradaki küçük farklılıklardan biri
bu.
2226
01:46:11,207 --> 01:46:11,790 Güzel
soru.
2227
01:46:11,790 --> 01:46:14,070 Ama
zamanla başkalarını da göreceksiniz.

Machine Translated by Google
2228

01:46:14,070 --> 01:46:17,290
Pekala, o zaman bir şekilde
daha iyi olduğunu iddia ediyoruz.
2229
01:46:17,290 --> 01:46:18,490 bunu
döngülerle yapmak için.
2230
01:46:18,490 --> 01:46:20.530 Yani
aslında koda geri dönelim.
2231
01:46:20.530 --> 01:46:25.030
Devam edeyim ve şimdi miyavlamayı örneğin
bir for döngüsü ile yeniden uygulayayım.
2232
01:46:25,030 --> 01:46:30,900 Peki
int i = 0, i 3'ten küçük, i++ için nasıl
olur?
2233
01:46:30,900 --> 01:46:35,640
O zaman kaşlı ayraçlarımın içinde, devam
edeyim ve printf, miyav ile yazdırayım,
2234
01:46:35,640 --> 01:46:38,110 yeni
satır ve noktalı virgül ile.
2235
01:46:38,110 --> 01:46:41,860 Kas
hafızasını uzun süredir edindiğim için bunu
oldukça hızlı bir şekilde yaptım.
2236
01:46:41,860 --> 01:46:44,790 Ama
şimdi miyav yaparsam, orada hata yok.
2237
01:46:44,790 --> 01:46:46,050
Çalıştır ./miyav.
2238
01:46:46,050 --> 01:46:48,300 Ve
miyav, miyav, miyav görüyorum.
2239
01:46:48,300 --> 01:46:50,430
Peki, şimdi geçen hafta
yaptığımızı yapalım.
2240

Machine Translated by Google
01:46:50,430 --> 01:46:54,700 kendi
özel işlevlerimizi yapmaya
başlayacaktık, eğer istersen,
2241
01:46:54,700 --> 01:47:00,630 C'de
kendimizinkini kullanarak. İşte burada
sözdizimi biraz tuhaflaşıyor,
2242
01:47:00,630 --> 01:47:05,040 ancak
bu anahtar kelimelerin her birinin ne
yaptığını zamanla açıklayacağız.
2243
01:47:05,040 --> 01:47:08,400
Miyav adında bir
fonksiyon yaratmak istersem--

2244
01:47:08,400 --> 01:47:12,480 çünkü
C'nin yazarları onlarca yıl önce miyav adlı bir
işlev yaratmadı-2245
01:47:12,480 --> 01:47:15,150 Miyav
gibi bir isim vermem gerekiyor.
2246
01:47:15,150 --> 01:47:17,730 Herhangi
bir girdi alıp almadığını belirtmem
gerekiyor.

2247
01:47:17,730 --> 01:47:19,590
Şimdilik hayır diyeceğim.
2248
01:47:19,590 --> 01:47:25,400 Ve
void özel kelimesini yazarak açıkça
hayır diyeceğim.
2249
01:47:25,400 --> 01:47:28,280
C'de bir işlev uygularken de
gereklidir-2250
01:47:28,280 --> 01:47:30,050
Scratch'te gerekli değildi-2251
01:47:30,050 --> 01:47:32,610 dönüş
türünün ne olduğunu belirtmek için.

Machine Translated by Google
2252

01:47:32,610 --> 01:47:36,260
Ama şimdilik, sadece miyavın işlevin
adı olduğunu söyleyeceğim,
2253
01:47:36,260 --> 01:47:37,790 girdi
almaz-2254
01:47:37,790 --> 01:47:40,730 ve
parantez içindeki boşluğun anlamı
bu-2255
01:47:40,730 --> 01:47:45,290 ve
ask yaptığı gibi bir şey döndürmez,

2256
01:47:45,290 --> 01:47:47,420 veya
get_string veya get_int gibi.
2257
01:47:47,420 --> 01:47:51,140
Miyav'ın hayattaki amacı sadece
yan etkilere, görsel yan etkilere sahip olmaktır.
2258
01:47:51,140 --> 01:47:53,190
ekrana bir şey yazdırarak.
2259
01:47:53,190 --> 01:47:55,460 Peki
miyav ne yapacak?
2260
01:47:55,460 --> 01:47:57,680
Oldukça basit bir şekilde
printf demesini sağlayacağım,

2261
01:47:57,680 --> 01:48:01,490 alıntı
yapma, "miyav", ters eğik çizgi n.
2262
01:48:01,490 --> 01:48:05,870
Ve şimdi, tıpkı içinde olduğu gibi

Scratch, şimdi arayabilirim
2263
01:48:05,870 --> 01:48:08,030
miyav adında yepyeni bir işlev.
2264

Machine Translated by Google
01:48:08,030 --> 01:48:10.730

Ve burada da, eğer kaşlı ayraçları
gerçekten sevmiyorsanız,
2265
01:48:10,730 --> 01:48:13,790 teknik
olarak konuşursak, onlardan
kurtulabilirsin
2266
01:48:13,790 --> 01:48:16,010
döngünüz içinde yalnızca bir satır kod.
2267
01:48:16,010 --> 01:48:18,710
Ama yine, stilistik olarak,
teşvik ederdim
2268
01:48:18,710 --> 01:48:21.710
kendinize ve başkalarına süper
netlik kazandırmak için onları korumanız
2269
01:48:21,710 --> 01:48:23,670 neler
oluyor.
2270
01:48:23,670 --> 01:48:26,300
Devam edip bunu kaydedip
miyavlama yapayım.
2271
01:48:26,300 --> 01:48:27,730 Hata.

2272
01:48:27,730 --> 01:48:28,230 Lanet
olsun.
2273
01:48:28,230 --> 01:48:29,272
Pekala, ne yaptım?
2274
01:48:29,272 --> 01:48:30,295
Aptalca bir şey.
2275
01:48:30,295 --> 01:48:31,170
İZLEYİCİ: [DUYULMAZ]
2276
01:48:31,170 --> 01:48:33,340 DAVID
J. MALAN: Evet, yani

Machine Translated by Google
0 oraya ait değil.
2277
01:48:33,340 --> 01:48:35,760
Parantezlere basmak istedim.
2278
01:48:35,760 --> 01:48:38,190 Bu yüzden
miyav yapmak için tekrar çalışmama izin verin.

2279
01:48:38,190 --> 01:48:39,720 Tamam,
düzeltildi.
2280
01:48:39,720 --> 01:48:40,800 Benim
hatam.
2281
01:48:40,800 --> 01:48:42,820 Tamam,
hala çalışıyor.
2282
01:48:42,820 --> 01:48:45,970 Ama
Scratch'te ne yaptığımı hatırla, bir nevi
gözden uzak, akıl dışı.
2283
01:48:45,970 --> 01:48:49.020
Ve sadece bir noktaya değinmek için,
bunu vurgulamama ve taşımama izin verin
2284
01:48:49.020 --> 01:48:50.460 dosyanın
aşağısında.
2285
01:48:50.460 --> 01:48:53.490 Çünkü,
şimdi miyav var olduğuna göre, bu bir
soyutlamadır.
2286
01:48:53,490 --> 01:48:55,800 Sadece bir
miyav fonksiyonunun var olduğunu biliyorum.
2287
01:48:55,800 --> 01:48:57,310 Onu
kullanabilmek istiyorum.
2288
01:48:57,310 --> 01:48:59,220 O halde
yukarı kaydırmama izin verin.
2289
01:48:59,220 --> 01:49:00,930

Machine Translated by Google
Ana işlevim aynı.
2290
01:49:00,930 --> 01:49:03,480
Devam edip tekrar miyavlayayım.
2291
01:49:03,480 --> 01:49:08,730 Ve
şimdi, sadece bu işlevi hareket ettirerek,
tüm bu hata satırlarını yarattım.
2292
01:49:08,730 --> 01:49:10,050 Ve
ilkine bakalım.
2293
01:49:10,050 --> 01:49:12,217
Yine, buradaki temel kural-biraz küçük,
2294
01:49:12,217 --> 01:49:16,260 ama
kalın harflerle miyav.c yazıyor-- hatanın
olduğu dosyanın adı-2295
01:49:16,260 --> 01:49:19,110 5
satır numarası ve 20 karakterdir.

2296
01:49:19,110 --> 01:49:21,940 Yani
tek başına satır numarası yeterlidir.

2297
01:49:21.940 --> 01:49:23,700
Bakalım.
2298
01:49:23,700 --> 01:49:27,810 Ah,
çok yukarı kaydırdığımda olan şey
bu.
2299
01:49:27,810 --> 01:49:28,410
Üzgünüm.
2300
01:49:28,410 --> 01:49:30,960 Şu
anda baktığımız hata bu, 7. satır.

2301
01:49:30,960 --> 01:49:34,890
eski hata mesajına bakıyordum

Machine Translated by Google
0'ı düzeltmeden önce.

2302
01:49:34,890 --> 01:49:36,750
miyav.c satır 7.
2303
01:49:36,750 --> 01:49:40,980
Pekâlâ, görünüşe göre C, miyav
fonksiyonunun ne olduğunu bilmiyor.
2304
01:49:40.980 --> 01:49:44,640
C99'da miyav işlevinin örtük
bildirimi geçersiz.
2305
01:49:44,640 --> 01:49:45,780 Peki,
bu ne anlama geliyor?
2306
01:49:45,780 --> 01:49:49,140 İşlev
bildirimi, bir işlev oluşturmanız
anlamına gelir.
2307
01:49:49,140 --> 01:49:52,710
Mesela, miyavın var olduğunu ilan
ediyorum, ama görünüşe göre yok
2308
01:49:52,710 --> 01:49:53,700 henüz
tanımladı.
2309
01:49:53,700 --> 01:49:57,430
Ve sonra C99, 1999 yılındaki C
versiyonudur,
2310
01:49:57,430 --> 01:50:00,390
Genellikle burada kullandığımız, daha
yeni sürümlerden biridir.
2311
01:50:00,390 --> 01:50:03,660 Peki
neden böyle?
2312
01:50:03,660 --> 01:50:07,230
Sadece miyavlamayı dibe taşıdığım
gerçeğinden çıkarsama yapabilir misin?
2313
01:50:07,230 --> 01:50:10,240

Machine Translated by Google
dosyanın-- Scratch'te iyiydi ama

şimdi kötü--

2314
01:50:10,240 --> 01:50:11,618
neden bu?
2315
01:50:11,618 --> 01:50:13,065
İZLEYİCİ: [DUYULMAZ]
2316
01:50:13,065 --> 01:50:15,190
DAVID J. MALAN: Evet, C biraz eski
okul.
2317
01:50:15,190 --> 01:50:16,880
Kodunuzu yukarıdan aşağıya okur.
2318
01:50:16,880 --> 01:50:21,200
Ve ilk kullanmaya çalıştığınızda miyavın
ne olduğunu bilmiyorsa,
2319
01:50:21,200 --> 01:50:24,110
çıldırıyor ve bu hata mesajlarını
yazdırıyor.
2320
01:50:24,110 --> 01:50:29,710 Yani
çözüm, oldukça basit, bunu yapma,
olduğu yerde bırak.
2321
01:50:29,710 --> 01:50:33,670
Ama bunun zamanla biraz can sıkıcı hale
geldiğini hayal edebilirsiniz, eğer sadece

2322
01:50:33,670 --> 01:50:37,960
çünkü main, ismiyle programınızın
ana kısmıdır.
2323
01:50:37,960 --> 01:50:41,170
Ve dürüst olmak gerekirse,
main her zaman olsaydı iyi olurdu
2324
01:50:41,170 --> 01:50:42,298
kodunuzun en üstünde.
2325

Machine Translated by Google
01:50:42,298 --> 01:50:44,590
Çünkü bir dosyanın ne
yaptığını anlamak istiyorsanız,
2326
01:50:44,590 --> 01:50:46,600
sadece yukarıdan aşağıya
okumak mantıklı.
2327
01:50:46,600 --> 01:50:48,775
Bunun bir çözümü var.
2328
01:50:48,775 --> 01:50:53,920
Fonksiyonları ana üstte olacak
şekilde farklı sıralara koyabilirsiniz.
2329
01:50:53,920 --> 01:50:58,700
sizin gibi-- ve bu belki de kopyala
yapıştırın uygun olduğu tek zamandır-2330
01:50:58,700 --> 01:51:01,870
derleyici için biraz kırıntı
bıraktığınız sürece
2331
01:51:01,870 --> 01:51:04,330
dosyanızın en üstünde

2332
01:51:04,330 --> 01:51:08,290
dönüş değerini, adı ve bağımsız
değişkenleri tekrarlar
2333
01:51:08,290 --> 01:51:10,880
bu işleve, noktalı virgül.
2334
01:51:10,880 --> 01:51:13,990
Bu, tabiri caizse,
işlevinizi ilan etmek-2335
01:51:13,990 --> 01:51:16,460 ve
asıl süslü yol, bunun bir prototip
olmasıdır.
2336
01:51:16,460 --> 01:51:18,740
Sanki bu ne

Machine Translated by Google
şey neye benzeyecek?
2337
01:51:18,740 --> 01:51:21,680 Ama
noktalı virgül bununla henüz
uğraşmayacağım anlamına geliyor.
2338
01:51:21,680 --> 01:51:23,530
Aslında işlevi
tanımlayacağım
2339
01:51:23,530 --> 01:51:25,900 veya
aşağıdan buraya uygulayın.
2340
01:51:25,900 --> 01:51:27,880 Bu
biraz aptalca bir ayrıntı.
2341
01:51:27,880 --> 01:51:31,420
Daha yeni diller bu
ihtiyaçtan kurtulur,
2342
01:51:31,420 --> 01:51:33,193
işlevlerinizi istediğiniz sıraya koyabilirsiniz.
2343
01:51:33,193 --> 01:51:35,110
Ama yine de, sadece
temelleri düşünürseniz
2344
01:51:35,110 --> 01:51:37.430
burada bunun gibi programlama
dilleri-2345
01:51:37,430 --> 01:51:38,410 ve
belirttiğiniz gibi-2346
01:51:38,410 --> 01:51:40,550
sadece kodunuzu yukarıdan
aşağıya okuyor olmalı.
2347
01:51:40,550 --> 01:51:44,260 Çok
sinir bozucu, evet, ama açıkladı,
evet de.
2348
01:51:44,260 --> 01:51:49,480

Machine Translated by Google
Öyleyse devam edeyim ve bir kez daha
miyavlayayım, ./miyav, hala iyi çalışıyor.
2349
01:51:49,480 --> 01:51:53,530 Ve
burada bu miyav programında son bir geliştirme
yapmama izin verin.
2350
01:51:53,530 --> 01:51:56,420 Şimdi
devam edip şöyle bir şey söyleyeyim.

2351
01:51:56,420 --> 01:51:58,390
Devam edeyim ve tamam,
olmaz mı?
2352
01:51:58,390 --> 01:52:04,140 Miyav
işlevim birkaç kez benim için bir şeyler
yapabilseydi iyi olurdu?
2353
01:52:04,140 --> 01:52:05,900 Diyelim
ki bunu yapmak istiyorum.
2354
01:52:05,900 --> 01:52:09,070 Şu
anda bu miyav işlevi üç kez miyavlayacak.

2355
01:52:09,070 --> 01:52:12,310
Ama diyelim ki n kez miyavlamak
istiyorum, burada n sadece
2356
01:52:12,310 --> 01:52:14,380
kullanıcı tarafından sağlanan bir numara.
2357
01:52:14,380 --> 01:52:18,760
Pekala, tıpkı Scratch'ta olduğu
gibi, özel işlevler girdi alabilir,
2358
01:52:18,760 --> 01:52:21,320 Şu
anda geçersiz diyorum.
2359
01:52:21,320 --> 01:52:25,750
Ama bunu int n olarak
değiştirirsem, derleyiciye şunu söylersem,

Machine Translated by Google
2360

01:52:25,750 --> 01:52:29,350 hey,
miyav hala bir şey döndürmüyor,

2361
01:52:29,350 --> 01:52:31,780 ama
girdi olarak bir şey alıyor.
2362
01:52:31,780 --> 01:52:34,780 Bir
tamsayı alıyor ve ben ona n demek
istiyorum.
2363
01:52:34,780 --> 01:52:37,270
Yani bu bir değişken
bildirmenin başka bir yolu
2364
01:52:37,270 --> 01:52:40,090
ancak teslim edilen bir değişkeni
bildirmenin bir yolu,
2365
01:52:40,090 --> 01:52:41.630 girdi
olarak, fonksiyon.
2366
01:52:41,630 --> 01:52:46,300
Yani şimdi, eğer burayı sıkarsam, şimdi
Aslında gerçekten harika bir şey yapabilirim
2367
01:52:46,300 --> 01:52:49,750 tıpkı
Scratch'teki gibi, bu da bu.
2368
01:52:49,750 --> 01:52:52,240
Şimdi bu koda
bakarsam-- buraya yakınlaştırayım--

2369
01:52:52,240 --> 01:52:55,510 şimdi
ana programım bu anlamda
gerçekten iyi yazılmış
2370
01:52:55,510 --> 01:52:58,390
sadece ne yaptığını söylüyor, üç
kez miyav.
2371
01:52:58,390 --> 01:53:02,230
Bu işe yarıyor, çünkü ben

Machine Translated by Google
miyav'ı şimdi bir girdi alıyor olarak tanımladı,
2372
01:53:02,230 --> 01:53:08,890 n
adında bir tamsayı ve sonra artık tanıdık
for döngümde n kullanıyor.
2373
01:53:08,890 --> 01:53:09,970 Bir
değişiklik var.
2374
01:53:09,970 --> 01:53:12,470 Bir
hatamı yakalamış olabilirsiniz.
2375
01:53:12,470 --> 01:53:16,300 Ben
de bu değişikliği yapmak için burada
kendime hatırlatmam gerekiyor.
2376
01:53:16,300 --> 01:53:19.090
Yine, bu sadece fazlalıklardan
veya kopyala-yapıştırlardan biridir.
2377
01:53:19,090 --> 01:53:20.710 bu
biraz makul.
2378
01:53:20.710 --> 01:53:23,230 Ama
işte şimdi daha iyi bir versiyonum var.
2379
01:53:23,230 --> 01:53:27,580 Şimdi
devam edeyim ve bunu yeniden
çalıştırayım, miyav yapın, ./miyav.
2380
01:53:27,580 --> 01:53:28,180 İşte.

2381
01:53:28,180 --> 01:53:30,730
Yani, yine, doğrulukta
bir değişiklik yok ama şimdi,
2382
01:53:30,730 --> 01:53:32,590 yine
kodumuzu modülerleştiriyoruz.

2383
01:53:32,590 --> 01:53:35,920
Ve, kahretsin, şimdi ne yapabilirsin-- ve

Machine Translated by Google
bu sadece bir özellik hakkında bir alay
2384
01:53:35,920 --> 01:53:36,700 yolun
aşağısında-2385
01:53:36,700 --> 01:53:39,520 Daha
önce bahsettiğimiz şu başlık
dosyaları, şu kütüphaneler,
2386
01:53:39,520 --> 01:53:42,250
Bahsettiğimiz modülerleştirme türü
budur.
2387
01:53:42,250 --> 01:53:46,120
Biz personel olarak get_string, get_int ve
benzeri adında bir fonksiyon yazdık,
2388
01:53:46,120 --> 01:53:52,390 CS50
adlı bir dosyaya koyduk ve küçük kırıntıları
koyduk-- özellikle,
2389
01:53:52,390 --> 01:53:54,580
bunlara prototip denir-2390
01:53:54,580 --> 01:53:56,770
cs50.h'de.
2391
01:53:56,770 --> 01:54:01,450
Böylece, hevesli programcılar olarak
hepiniz cs50.h'yi dahil ettiğinizde,
2392
01:54:01,450 --> 01:54:05,500
derleyiciye kodunuzun en üstünde
gizlice söylüyorsunuz
2393
01:54:05,500 --> 01:54:07,490
mevcut işlevler menüsünün ne olduğu.
2394
01:54:07,490 --> 01:54:07,990
Neden?
2395
01:54:07,990 --> 01:54:12,760
Çünkü CS50'de satırlar şöyledir:

Machine Translated by Google
bunlar-- açıkçası, miyav için değil,
2396
01:54:12,760 --> 01:54:15,340 ancak
get_string, get_int vb. için.

2397
01:54:15,340 --> 01:54:20.740 Ve
stdio.h aynı satırlar
printf gibi şeyler için kod.
2398
01:54:20.740 --> 01:54:22,940 Demek
olan bitenler bundan ibaret.
2399
01:54:22,940 --> 01:54:29,240
Bilgisayara önceden hangi işlevlerin
beklendiğini söylemenin bir yolu.
2400
01:54:29,240 --> 01:54:32,120 Pekala,
o halde bunlarla ilgili herhangi bir
sorunuz var mı?
2401
01:54:35,000 --> 01:54:35,510 Doğru.

2402
01:54:35,510 --> 01:54:38,330
Bu yüzden sakıncası yoksa, el
sallamaya devam etmek istiyorum

2403
01:54:38,330 --> 01:54:40,250
bugünlük bu ayrıntıda elim.
2404
01:54:40,250 --> 01:54:44,780
Gerçekten de, int main void biraz tuhaf,
çünkü girdi etki alanı ne olurdu?
2405
01:54:44,780 --> 01:54:46,867 Henüz
girdi sağlamak için bir mekanizmamız
yok.
2406
01:54:46,867 --> 01:54:48,950 Main'in
herhangi bir şey döndürmesi ne
anlama geliyor?
2407

Machine Translated by Google

01:54:48,950 --> 01:54:50,450 Kime

dönüyor?
2408
01:54:50,450 --> 01:54:51,577
Mümkünse başka bir gün için.
2409
01:54:51,577 --> 01:54:53.660
Oyuna girecekler ama şimdilik,

2410
01:54:53,660 --> 01:54:56,300
bugün tam anlamıyla almanız
gereken bir şey,
2411
01:54:56,300 --> 01:54:59,520
programları başlatmak için gerekli
kopyala-yapıştır.
2412
01:54:59,520 --> 01:55:02,690
Yani miyav, bir girdi alan bir
fonksiyondur, miyavlama sayısını,
2413
01:55:02,690 --> 01:55:06,170 ama
aslında bir dönüş değeri yoktu,
dolayısıyla boşluk.
2414
01:55:06,170 --> 01:55:08,720
Ama ya gerçekten kendi
fonksiyonumuzu yaratmak istiyorsak,
2415
01:55:08,720 --> 01:55:11,630
argüman olarak sadece 0 veya
daha fazla girdi almaz
2416
01:55:11,630 --> 01:55:15,260 ama
aynı zamanda bir değer döndürür, belki
bir int, belki bir kayan nokta, belki bir şey
2417
01:55:15,260 --> 01:55:16,190
tamamen başka mı?
2418
01:55:16,190 --> 01:55:18,840
Görünüşe göre C'de bunu da
yapabiliriz.

Machine Translated by Google
2419
01:55:18,840 --> 01:55:22,280 Devam
edip burada indirim adında yeni bir
dosya oluşturayım.
2420
01:55:22,280 --> 01:55:24,320
Ve üzerinden hızlı bir
program uygulayalım.
2421
01:55:24,320 --> 01:55:26,840 bazı
normal fiyatlarda belirli bir oranda
indirim yapabiliriz,
2422
01:55:26,840 --> 01:55:28,940 sanki
bir mağazada indirim oluyormuş gibi.

2423
01:55:28,940 --> 01:55:35,690 Devam
edeyim ve her zamanki cs50.h ve ardından
stdio.h'yi ekleyeyim.
2424
01:55:35,690 --> 01:55:38,750 Daha
önce olduğu gibi kendime int main
void vereyim.
2425
01:55:38,750 --> 01:55:41.580 Ve
main'in içinde, devam edelim ve basit
bir şey yapalım.
2426
01:55:41.580 --> 01:55:43.670
Kendimize düzenli denilen
bir şamandıra verelim,
2427
01:55:43.670 --> 01:55:46,550 bir
mağazadaki bir şeyin normal fiyatını
temsil eder.
2428
01:55:46,550 --> 01:55:49,310
Devam edelim ve kullanıcıdan
onlara soran bir şamandıra alalım
2429
01:55:49,310 --> 01:55:51,680 bu
normal fiyat nedir.

Machine Translated by Google
2430

01:55:51,680 --> 01:55:55,940
Sonra, devam edelim ve ikinci bir değişken
tanımlayalım-- ayrıca bir kayan nokta-2431
01:55:55,940 --> 01:55:59,150 satış
olarak adlandırılır ve nihai olarak
satış fiyatını temsil eder
2432
01:55:59,150 --> 01:56:01,010 bir
miktar indirimden sonra.
2433
01:56:01,010 --> 01:56:04,220 Ve
devam edelim ve basitçe normal
olanı hesaplayalım.
2434
01:56:04,220 --> 01:56:07,050 Ve
diyelim ki %15 indirim oldukça iyi
bir indirim.
2435
01:56:07,050 --> 01:56:11,670
Öyleyse devam edelim ve düzenli,
her ne ise, %15 indirim yapalım,
2436
01:56:11,670 --> 01:56:15,110 Bu,
elbette onu yıldız işaretiyle çarpmaya
eşdeğerdir
2437
01:56:15,110 --> 01:56:16,880 ile
0,85.
2438
01:56:16,880 --> 01:56:21.325 Tabii
%15 indirim yapıyorsak normal fiyatı
0,85 ile çarpıyoruz.
2439
01:56:21,325 --> 01:56:23,450 Şimdi
devam edelim ve sonuçları buradan
yazdıralım.
2440
01:56:23,450 --> 01:56:27,470
Devam edeyim ve printf satış
fiyatı diyelim, iki nokta üst üste--

2441
01:56:27,470 --> 01:56:30,140

Machine Translated by Google
devam edeyim ve %f, ama
daha spesifik olarak,
2442
01:56:30,140 --> 01:56:35,150 %.2f
çünkü en azından ABD para biriminde
senti iki ondalık basamağa kadar gösteriyoruz
2443
01:56:35,150 --> 01:56:35,810 yer--

2444
01:56:35,810 --> 01:56:36,950
ardından bir yeni satır.
2445
01:56:36,950 --> 01:56:39,830
Sonra devam edip satış değerini
girmeme izin verin.
2446
01:56:39,830 --> 01:56:43,430
Pekala, buraya inelim ve indirim
yapalım, Girin.
2447
01:56:43,430 --> 01:56:45,980
Şimdiye kadar çok iyi-- ./indirim.
2448
01:56:45,980 --> 01:56:48,200 Ve
normal fiyat belki 100$'dır.
2449
01:56:48,200 --> 01:56:50.760 Yani
satış fiyatı 85$ olmalıdır.
2450
01:56:50,760 --> 01:56:52,682 Yani
burada aritmetiğimiz doğru
görünüyor.
2451
01:56:52,682 --> 01:56:54,140 Ama
şimdi zamanı ileri saralım.
2452
01:56:54,140 --> 01:56:56.000
Kendimizi indirim yaparken
bulduğumuzu varsayalım.

2453
01:56:56.000 --> 01:56:58.927 bir
çok fiyat

Machine Translated by Google
uygulama, belki bir web sitesi
2454
01:56:58,927 --> 01:57:01,760 bir tür
yüzde indirim sundukları Amazon gibi.

2455
01:57:01,760 --> 01:57:04,400
Ve yeniden kullanılabilir bir
işleve sahip olmak güzel olurdu

2456
01:57:04,400 --> 01:57:07,620 bizim
için bu aritmetiği yapar, basit olsa
da.
2457
01:57:07,620 --> 01:57:09,710
Öyleyse devam edelim
ve bu sefer indirimi değiştirelim
2458
01:57:09,710 --> 01:57:13,250
kendimize indirim denilen kendi
fonksiyonumuzu vermek,
2459
01:57:13,250 --> 01:57:14,977
örneğin, bir girdi alır-2460
01:57:14.977 --> 01:57:17.060 indirim
yapmak istediğiniz normal fiyat gibi--

2461
01:57:17,060 --> 01:57:19,272 ve
ardından bir değer döndürür.
2462
01:57:19,272 --> 01:57:20,480 Sadece
çıktısını almıyor.
2463
01:57:20,480 --> 01:57:25,280 Bir
değer, yani satış fiyatının ne olduğunu
gösteren bir kayan nokta döndürür.
2464
01:57:25,280 --> 01:57:28,430
Bu yüzden ana aşağıya
inmeme izin verin ve devam edin

2465

Machine Translated by Google

01:57:28,430 --> 01:57:31,100 ve bir
şamandıra döndürecek bir işlev

tanımlayın,
2466
01:57:31,100 --> 01:57:33,317 çünkü
hala dolar miktarıyla uğraşıyoruz.

2467
01:57:33,317 --> 01:57:35,150
Fonksiyona indirim adı verilecek.

2468
01:57:35,150 --> 01:57:39,170
İndirmek istediğimiz fiyat gibi bir girdi
alacak.
2469
01:57:39,170 --> 01:57:41,370
Burada çok basit bir şey yapacağım.

2470
01:57:41,370 --> 01:57:47.010 Float
satışın fiyatı ne olursa olsun çarpı
0,85'e eşit olduğunu söyleyeceğim.
2471
01:57:47.010 --> 01:57:49,252 Ve
sonra devam edip satışı iade
edeceğim.
2472
01:57:49,252 --> 01:57:51,710 Şimdi,
aslında bu konuyu biraz daha
sıkılaştırabilirim.
2473
01:57:51,710 --> 01:57:55,280
Yalnızca bir değeri saklamak için bir
değişken bildiriyorsam, o zaman
2474
01:57:55,280 --> 01:58:00,390 bu
anahtar kelime dönüşüyle dönüyor,
aslında o değişkene bile ihtiyacım yok.
2475
01:58:00,390 --> 01:58:02,240
Böylece ikinci satırı silebilirim.
2476
01:58:02,240 --> 01:58:04,880

Machine Translated by Google
Ve aslında devam edip bu değişkenden
kurtulabilirim
2477
01:58:04,880 --> 01:58:07,490
tamamen ve aritmetik ne olursa
olsun hemen geri dönün
2478
01:58:07,490 --> 01:58:11,360 sonucu,
geçirilen argüman olan fiyat girişinin
alınmasıdır,
2479
01:58:11,360 --> 01:58:13,100 kere
0,85.
2480
01:58:13,100 --> 01:58:16,880 Benim
için iskontoyu yapan çok basit bir
fonksiyon.
2481
01:58:16,880 --> 01:58:20,210
Her zamanki gibi, devam
edeyim ve kopyala-yapıştır-2482
01:58:20,210 --> 01:58:23,450
kopyalayıp yapıştırmanın uygun olduğu tek
zaman-- bu fonksiyonun prototipi, yani
2483
01:58:23,450 --> 01:58:26,540
dosyanın en üstünde, böylece bu
kodu derlerken,
2484
01:58:26,540 --> 01:58:29,810 main
daha önce indirim kelimesini
görmüştü.
2485
01:58:29,810 --> 01:58:31,470 Şimdi
buradaki koda girmeme izin verin.
2486
01:58:31,470 --> 01:58:34,610
Ve esas olarak matematiği
kendim yapmak yerine,
2487
01:58:34,610 --> 01:58:37.670 farz
edelim ki zaten bir fonksiyonumuz
var

Machine Translated by Google
2488
01:58:37.670 --> 01:58:41.990
İndirim adı verilen ve normal fiyattan
indirim yapmamı sağlayan araç setimizde
2489
01:58:41.990 --> 01:58:44,045 ve bu
değeri döndürün.
2490
01:58:44,045 --> 01:58:46,170 Ve
sonra burada kodumun değişmesi
gerekmiyor.
2491
01:58:46,170 --> 01:58:49,400
Hala içinde bulunduğum
değişkeni satışa çıkaracağım
2492
01:58:49,400 --> 01:58:51,640 bu
sonucu saklar. Ama burada ne
yaptığımı fark et.
2493
01:58:51,640 --> 01:58:53,390
Kavramın yolunu bir
nevi soyutladım
2494
01:58:53,390 --> 01:58:57,290 bir
float alan kendi fonksiyonumu yaratarak
indirim almanın adı
2495
01:58:57,290 --> 01:58:59,150 fiyat
veya girdi olarak başka bir şey.
2496
01:58:59,150 --> 01:59:01,640
Biraz matematik yapıyor,
burada olmasına rağmen basit,
2497
01:59:01,640 --> 01:59:03,210 ve
ardından bir değer döndürür.
2498
01:59:03,210 --> 01:59:06,140 Ancak
indirimin bu değeri yazdırmadığına
dikkat edin.
2499
01:59:06,140 --> 01:59:08,390

Machine Translated by Google
Kelimenin tam anlamıyla
şu diğer anahtar kelimeyi kullanıyor:

2500
01:59:08,390 --> 01:59:13,010 döner,
böylece bu değeri geri verebilirim, tıpkı
get_string elleri gibi
2501
01:59:13,010 --> 01:59:16,610 bir
değeri geri döndürür, tıpkı get_int
gibi bir tamsayıyı yazdırmadan geri döndürür
2502
01:59:16,610 --> 01:59:21,050 sizin
için-- böylece ben burada 9. hatta
devam edip depolayabilirim
2503
01:59:21,050 --> 01:59:24,920
istersem bu değeri bir değişkende ve
sonra gerçekten yazdırın.
2504
01:59:24,920 --> 01:59:29,640 Şimdi
devam edeyim ve bu kodu make indirim ile
yeniden derleyeyim.
2505
01:59:29,640 --> 01:59:31.580 Devam
edeyim ve ./indirimi yapayım.
2506
01:59:31,580 --> 01:59:34,240 Ve yine
100$ yapalım.
2507
01:59:34,240 --> 01:59:37,730 Satış
fiyatı da 85$ olacak.
2508
01:59:37,730 --> 01:59:41.920
Şimdi, fonksiyonların sadece 0 veya 1
argüman alması gerekmediği ortaya çıktı.
2509
01:59:41.920 --> 01:59:42.460 girdi
olarak.
2510
01:59:42,460 --> 01:59:44,440 Aslında
2 veya 3 veya daha fazlasını alabilirler.
2511
01:59:44,440 --> 01:59:48,400

Machine Translated by Google

Aslında, şimdi programımın bu versiyonunu

geliştirmek istediğimizi varsayalım.
2512
01:59:48,400 --> 01:59:52,600 ve
sadece fiyatı değil, indirim işlevine
girdi olarak alın
2513
01:59:52,600 --> 01:59:55,090
indirim yapmak istediğim ama
aynı zamanda yüzde indirim,
2514
01:59:55,090 --> 01:59:59,350
böylece sadece %15 değil, herhangi bir
sayıda yüzdeyi desteklememize izin veriyor
2515
01:59:59,350 --> 02:00:000,070
puan.
2516
02:00:000,070 --> 02:00:04,810
Pekala, hadi yukarı çıkıp bir int ilan
edeyim ve buna yüzde_kapalı diyelim.
2517
02:00:04,810 --> 02:00:07,150
Ve kullanıcıya yüzde kaçını
sorayım
2518
02:00:07,150 --> 02:00:09,010 puan
almak istiyorlar.
2519
02:00:09,010 --> 02:00:12,700
Bu yüzden, buradaki istemin içinde
yüzde_kapalı diyeceğim,
2520
02:00:12,700 --> 02:00:14,950
yüzde_kapalı denen int'yi al.
2521
02:00:14,950 --> 02:00:18.070
Ve şimdi girdi olarak
düzenli olarak geçmenin yanı sıra
2522
02:00:18.070 --> 02:00:22.000
indirim fonksiyonuna, ben de
yüzde_kapalı olarak geçeceğim.

Machine Translated by Google
2523

02:00:22.000 --> 02:00:26.020
Ama bilgisayara şimdi iki argüman
aldığını söylemem gerekiyor,
2524
02:00:26.020 --> 02:00:28,330 ve
bunu sadece virgülle yapıyorum

2525
02:00:28,330 --> 02:00:30,580
burada işlevin kendi tanımında.

2526
02:00:30,580 --> 02:00:34,810
İşte bir yüzde argümanı olacak,
ikinci bir argüman,
2527
02:00:34,810 --> 02:00:35,710
virgül başına.
2528
02:00:35,710 --> 02:00:41,290 Ve
şimdi bu yüzdeyi biraz tanıdık bir
şekilde kullanacağım.
2529
02:00:41,290 --> 02:00:44,680
Sadece böyle bir yüzde yapmak
istemiyorum, çünkü tabii ki,
2530
02:00:44,680 --> 02:00:47,943 bu
toplam fiyatın boyutunu artıracak.

2531
02:00:47,943 --> 02:00:50,860
Aslında biraz gerçek dünya
matematiği yapmam gerekiyor, eğer bu ise
2532
02:00:50.860 --> 02:00:54,580 bir
yüzde indirim, 15 puan için 15 sayısı
gibi,
2533
02:00:54,580 --> 02:00:57,790
100 eksi o kadar çok yüzde
puanı yapmam gerekiyor,
2534

Machine Translated by Google
02:00:57,790 --> 02:01:000,070
böylece bana 100 eksi 15 veriyor-2535
02:01:000,070 --> 02:01:00,910
85.
2536
02:01:00,910 --> 02:01:04,330
Ve sonra bölmem gerekiyor

şimdi 100 sıra ile
2537
02:01:04,330 --> 02:01:09,230
geçen fiyatın 0,85 katını kendime
vermek için.
2538
02:01:09,230 --> 02:01:14,110
Ama şimdi devam edip bunu
kurtarırsam, koş, son bir kez indirim yap,
2539
02:01:14,110 --> 02:01:16.090
Burada aslında bir hatam
olduğunu fark ettim.
2540
02:01:16,090 --> 02:01:17,500
Neyi yanlış yaptım?
2541
02:01:17,500 --> 02:01:19,420 O
prototipi de değiştirmem
gerekiyor.
2542
02:01:19,420 --> 02:01:21,918
Ve yine, bu kuşkusuz C'nin can
sıkıcı bir yönüdür.
2543
02:01:21.918 --> 02:01:23,710
burada tutarlılığı sağlamanız
gerekiyor.
2544
02:01:23,710 --> 02:01:24,377
Ama sorun değil.
2545
02:01:24,377 --> 02:01:26,590
Ben sadece buraya gideceğim,
bunu int olarak değiştireceğim

Machine Translated by Google
2546
02:01:26,590 --> 02:01:28,840
yüzde-- yanlış yazım.
2547
02:01:28,840 --> 02:01:31,780
Ve şimdi derlemeyi
yeniden denememe izin ver, indirim yap,

2548
02:01:31,780 --> 02:01:33,310 bu
sefer parmaklarımı çıtlattım.
2549
02:01:33,310 --> 02:01:37,900
Tamam çalıştı. ./indirim ve işte, 100$.
2550
02:01:37,900 --> 02:01:40,420 Ve
yüzde, diyelim ki 15 puan.
2551
02:01:40,420 --> 02:01:44,180 Ve
işte 85 dolar.
2552
02:01:44,180 --> 02:01:46,510
Şimdi, bilerek yaptığımı
belirtmekte fayda var.
2553
02:01:46,510 --> 02:01:49,600 bu
fonksiyondan matematiğimin
sonuçlarını döndürdü.
2554
02:01:49,600 --> 02:01:52,990
Geçmekte olan orijinal değişkenin
matematiğini henüz yapmadım.
2555
02:01:52,990 --> 02:01:55,150
Aslında, bu ikinci versiyona
bir göz atarsak
2556
02:01:55,150 --> 02:01:58,970
burada indirim şimdi bir fiyat argümanı
ve bir yüzde argümanı alıyor,
2557
02:01:58,970 --> 02:02:01,240
Böyle bir şey yapmadığımı fark
edin.

Machine Translated by Google
2558

02:02:01,240 --> 02:02:05,620
Sadece fiyatın fiyatın 100 katına
eşit olduğunu söylemiyorum.

2559
02:02:05,620 --> 02:02:09,460 eksi
yüzde bölü 100'e bölünür ve burada
bırakılır.
2560
02:02:09,460 --> 02:02:13,150
Sorun şu ki, bu değişken fiyat

2561
02:02:13,150 --> 02:02:15,490 bu
indirim işlevinin kapsamına dahil edilecek.
2562
02:02:15,490 --> 02:02:18,430
Çok geçmeden bununla tekrar
karşılaşacağız, ancak bu kapsam kavramı
2563
02:02:18,430 --> 02:02:23,290
sadece bir değişkenin gerçekte
nerede yaşadığını veya var olduğunu belirtir
2564
02:02:23,290 --> 02:02:24,410 veya
erişilebilir.
2565
02:02:24,410 --> 02:02:27,400
Bu indirim bağlamında fiyatı
değiştirirsem ortaya çıkıyor
2566
02:02:27,400 --> 02:02:29,800 işlevi,
bunun kalıcı bir etkisi olmayacak.

2567
02:02:29,800 --> 02:02:31,510
Gerçekten sonucu geri
almak istersem
2568
02:02:31,510 --> 02:02:34,960
indirim işlevini kullanan işleve, yani
ana,
2569
02:02:34,960 --> 02:02:38,200

Machine Translated by Google
Aslında geri dönmek için bu
yaklaşımı benimsemem gerekiyor
2570
02:02:38,200 --> 02:02:42,920 değeri
açıkça, böylece sonunda indirimli fiyatı geri
veriyorum.
2571
02:02:42,920 --> 02:02:43,420 Pekala.

2572
02:02:43,420 --> 02:02:45,545
Pekala, hadi devam edelim
ve belki de
2573
02:02:45,545 --> 02:02:49,000 bu
temel öğeleri yalnızca birkaç farklı
şekilde kullanır.
2574
02:02:49,000 --> 02:02:53,500 Geçen
yılın küçük bir oyununa ne dersiniz,
Super Mario Brothers?
2575
02:02:53,500 --> 02:02:56,860
Ve orijinal Super Mario'da
Kardeşler ve çeşitli varyantlarda,
2576
02:02:56,860 --> 02:02:59,260 yani
şu yandan kayan dünyalara
sahipsiniz,
2577
02:02:59,260 --> 02:03:02,670
Gökyüzünde bu sorunun arkasına gizlenmiş
madeni paraların olduğu yerde böyle görünüyorsun
2578
02:03:02,670 --> 02:03:03,170 işaret.

2579
02:03:03,170 --> 02:03:06,430
Öyleyse bunu C'de nasıl
olabileceğini düşünmek için bir görsel olarak kullanalım.

2580
02:03:06,430 --> 02:03:08,260 Yarı
grafik bir şeyler yapmaya başlıyorum.

Machine Translated by Google
2581
02:03:08,260 --> 02:03:11.470
Gerçek renkler ya da fantezi değil, bu çok
erken gibi geliyor-2582
02:03:11,470 --> 02:03:14,210 sadece
bazı soru işaretlerini yazdırmak gibi
bir şey.
2583
02:03:14,210 --> 02:03:17,230
Pekala, eğer buraya geri dönersem, o
gerçek dosyayı oluşturmama izin verin.

Daha
önce bahsettiğim 2584 02:03:17,230
--> 02:03:18,620.
2585
02:03:18,620 --> 02:03:21.490 O halde
mario.c'yi kodlamama izin verin.
2586
02:03:21,490 --> 02:03:25,390 Devam
edeyim ve tekrar stdio.h, int main
void'i ekleyeyim,
2587
02:03:25,390 --> 02:03:27,520 bugün
için kopyala-yapıştır yapmaya devam
edeceğiz.
2588
02:03:27,520 --> 02:03:31,630
Ve sonra devam edeyim ve 1, 2, 3, 4 gibi
basit bir şey yapayım,
2589
02:03:31,630 --> 02:03:32,620 ve yeni
satır.
2590
02:03:32,620 --> 02:03:35,808
Pekala, bu bizim ASCII sanatı
diyebileceğimiz şeydir.
2591
02:03:35,808 --> 02:03:38,600 sadece
grafik anlamına gelir, ancak gerçekten
klavyenizle gerçeklenmiştir.
2592
02:03:38,600 --> 02:03:43,330

Machine Translated by Google

Ve eğer mario yapıp ./mario yaparsam,
görsel olarak neredeyse ilgi çekici olmuyor
2593
02:03:43,330 --> 02:03:47,110 bu
şekilde, ancak bir oyun için bu tür
bir haritanın başlangıcı.
2594
02:03:47,110 --> 02:03:51,250
Pekala, şimdi o şeyleri dinamik
olarak yazdırmak isteseydim,
2595
02:03:51,250 --> 02:03:52,930
buradaki koduma geri dönmeme izin verin.
2596
02:03:52,930 --> 02:03:55,030
Ve hepsini bir kerede
yazdırmak yerine,
2597
02:03:55,030 --> 02:03:59,650 Dört
int 0 alır, i 4'ten küçük, i artı artı gibi bir
şey yapabilirim.
2598
02:03:59,650 --> 02:04:04,430 Ve
sonra burada, her seferinde bir

tanesinin çıktısını alabiliyordum.
2599
02:04:04,430 --> 02:04:07,090 Bırak
da bunu kaydedeyim, mario yap.
2600
02:04:07,090 --> 02:04:11,830
Ve hayal kırıklığı
yaşama pahasına, çok yakın
2601
02:04:11,830 --> 02:04:15,000 ama
bir hata yaptım, sadece aptalca bir
estetik.
2602
02:04:15,000 --> 02:04:17.170 Bilgi
istemi yeni satırda değil.
2603
02:04:17.170 --> 02:04:18,675 Nasıl
hareket ettirebilirim?
2604

Machine Translated by Google
02:04:18,675 --> 02:04:20,260
İZLEYİCİ: [DUYULMAZ]
2605
02:04:20,260 --> 02:04:23,010
DAVID J. MALAN: Evet, bir kaçış
karakterine ihtiyacım var, ters eğik çizgi n.
2606
02:04:23,010 --> 02:04:26,740
Ama buraya koyayım mı?
2607
02:04:26,740 --> 02:04:28,990
Tamam, hayır, çünkü bu
herkesin peşine düşecek,
2608
02:04:28,990 --> 02:04:31,698 ve
bu şeyi yatay yerine dikey yapacak.

2609
02:04:31,698 --> 02:04:35,230
Yani, mantıksal olarak, tıpkı Scratch'ta olduğu
gibi, onu döngünün sonuna koyun, yani bir şey

2610
02:04:35,230 --> 02:04:35,950
burada.
2611
02:04:35,950 --> 02:04:39,500 Ve
örneğin sadece, alıntı yapmadan,
yeni satırı yazdırın.
2612
02:04:39,500 --> 02:04:42,550 Ve
şimdi tekrar mario yaparsam, ./
mario, tamam.
2613
02:04:42,550 --> 02:04:43,537 İşe
geri döndük.

2614
02:04:43,537 --> 02:04:45,370
Ama şimdi biraz
daha iyi tasarlanmış
2615
02:04:45,370 --> 02:04:48,590
Kendimi defalarca tekrar etmiyorum,
bunu tekrar tekrar yapıyorum.

Machine Translated by Google
2616

02:04:48,590 --> 02:04:51,910 Ama
burada mario ile bir şey daha yapalım.

2617
02:04:51,910 --> 02:04:57,160 Devam
edip kullanıcıya kaç soru işareti veya madeni
para basılacağını sorayım.
2618
02:04:57,160 --> 02:05:00,910
Buradaki yakalama, bunun için yararlı olan
başka bir döngü türü olmasıdır,
2619
02:05:00,910 --> 02:05:03,370 ve buna
genellikle do while döngüsü denir.

2620
02:05:03,370 --> 02:05:06,910
do while döngüsü,
while döngüsüne benzer,
2621
02:05:06,910 --> 02:05:10,420 ancak
ilk yerine son durumu kontrol eder.

2622
02:05:10,420 --> 02:05:12,238
Slaytta daha önce
hatırlayın, bir süre geçirdik,
2623
02:05:12,238 --> 02:05:13,780 açık
parantez, kapalı parantez.
2624
02:05:13,780 --> 02:05:17,140
Ve ben daha az olup olmadığımızı kontrol
ettiğimizi iddia etmeye devam ettim-- her neyse

2625
02:05:17,140 --> 02:05:20,270 oldu, 3
kez tekrar tekrar.
2626
02:05:20,270 --> 02:05:23,830
do while döngüsü mantığı tersine
çevirir, böylece gerçekten yapabilirsiniz
2627
02:05:23,830 --> 02:05:25,240

Machine Translated by Google
böyle bir şey yap.

2628
02:05:25,240 --> 02:05:27,580
Bu programın başında,
şimdi devam edeceğim
2629
02:05:27,580 --> 02:05:31,660 ve
kendime bunun gibi tamsayı
türünde bir n değişkeni verin.
2630
02:05:31,660 --> 02:05:36,070 Ve
sonra, kelimenin tam anlamıyla, do
anahtar kelimesiyle aşağıdakileri yapacağım.
2631
02:05:36.070 --> 02:05:39,790 n
eşittir get_int-- ve kullanıcıdan
genişliği isteyeceğim,
2632
02:05:39,790 --> 02:05:42,640 gibi
yazdırılacak dolar işareti sayısı.

2633
02:05:42,640 --> 02:05:47,230 Ve
bunu n, diyelim ki 1'den küçükken
yapacağım.
2634
02:05:47,230 --> 02:05:50,230
Yani bu biraz şifreli, ancak
göze çarpan farklılıklar
2635
02:05:50,230 --> 02:05:55,390 Boole
ifadesi artık kod bloğumun en altında,

2636
02:05:55,390 --> 02:05:57,100 en
üstte değil.
2637
02:05:57,100 --> 02:05:58,580
Şimdi, bu neden?
2638
02:05:58,580 --> 02:06:02,590
Buradaki fark, eğer
mario yaparsam--

Machine Translated by Google
2639

02:06:02,590 --> 02:06:04,090 kusura
bakmayın.
2640
02:06:04,090 --> 02:06:07,820 cs50.h
eklemem gerekiyor çünkü şimdi
get_int kullanıyorum.
2641
02:06:07,820 --> 02:06:13,250 Şimdi
Mario'nun bu sürümünü derler ve ./
mario yaparsam,
2642
02:06:13,250 --> 02:06:17,840 Bir do
while döngüsü, önce ne olursa olsun bir şey
yapmak istediğinizde yardımcı olur
2643
02:06:17,840 --> 02:06:22,130 ve
sonra bazı durumları veya bazılarını kontrol edin
Boole ifadesi, belki görmek için
2644
02:06:22,130 --> 02:06:23,660 bu
durumda kullanıcı işbirliği yaptı.
2645
02:06:23,660 --> 02:06:26,972
Kullanıcının örneğin 0 yazması
bir anlam ifade etmeyecektir.
2646
02:06:26,972 --> 02:06:28,430 çünkü
yapılacak iş yok.
2647
02:06:28,430 --> 02:06:30,650
Eksi 100 deselerdi
gerçekten garip olurdu,
2648
02:06:30,650 --> 02:06:32,420 çünkü
bu mantıklı değil.
2649
02:06:32,420 --> 02:06:37,460
Yani buradaki bu basit yapı ile
aşağıdakileri yapıyorum
2650
02:06:37,460 --> 02:06:40,010 n 1'den
küçükken.

Machine Translated by Google
2651

02:06:40,010 --> 02:06:44,277
Bunun anlamı, n'nin 1'e eşit olması
veya 1'den büyük olması durumunda,
2652
02:06:44,277 --> 02:06:46,610
Bu döngüden çıkacağım ve
kendime sahibim
2653
02:06:46,610 --> 02:06:51,830 n adlı
bir değişken, temelde pozitif bir
değer, 1
2654
02:06:51,830 --> 02:06:54,410'dan 2
milyara kadar.
2655
02:06:54,410 --> 02:06:58,520
Ve şimdi bunu kullanabilirim,
örneğin burada, 4'ü bir n olarak değiştirin
2656
02:06:58,520 --> 02:07:01,010 yani
şimdi programım tamamen dinamik.
2657
02:07:01,010 --> 02:07:04,910 Devam
edeyim ve tekrar mario, ./mario
yapayım.
2658
02:07:04,910 --> 02:07:07,070 Ve 4
tane yapacağım, hala çalışıyor.
2659
02:07:07,070 --> 02:07:09,950 40
yapacağım, hala çalışıyor.
2660
02:07:09,950 --> 02:07:13,340
Ve burada do while ile arasındaki fark,
bunun gibi bir şeyse
2661
02:07:13,340 --> 02:07:16,520
kullanıcı girdisi almayı içerir, peki,
sorulacak soru yok.
2662
02:07:16,520 --> 02:07:18,360
Kullanıcı henüz size bir şey vermedi.

Machine Translated by Google
2663

02:07:18,360 --> 02:07:22,310
Yani önce bir şeyler yapmalı, sonra
kontrol etmeli ve döngüden çıkmalısın.
2664
02:07:22,310 --> 02:07:27,007
örneğin bu durumda insan
işbirliği yaptıysa.
2665
02:07:27,007 --> 02:07:29,090
Pekala, neden bir şeye
tırmanmıyoruz?
2666
02:07:29,090 --> 02:07:33,140
Mario ile yeraltında olduğunuz aynı
oyunda bunun gibi daha fazlası,
2667
02:07:33,140 --> 02:07:36,680 ve
burada ortaya çıkan iki boyutlu bir
duvar gibi mi?
2668
02:07:36,680 --> 02:07:39,680
Tartışma olsun diye 3'e 3 gibi
görünüyor.
2669
02:07:39,680 --> 02:07:43,130 Ve
sanki tuğladan yapılmış gibi, bu
sefer belki karma semboller kullanacağım.
2670
02:07:43,130 --> 02:07:44,960
Görünüşe göre yuva yapabileceğimiz-2671
02:07:44,960 --> 02:07:48,510
yani birleştirin-- bu aynı fikirlerden
bazıları aşağıdaki gibidir.
2672
02:07:48,510 --> 02:07:52,310
Şimdi devam edeyim ve bu koda
geri dönelim.
2673
02:07:52,310 --> 02:07:56,700 Ve
do while döngüsünü öncekinden
devam ettireceğim.
2674

Machine Translated by Google
02:07:56,700 --> 02:07:58,640

Ve yine de şu soruyu
soracağım,
2675
02:07:58,640 --> 02:08:00,290 Bu
karenin boyutu nedir?
2676
02:08:00,290 --> 02:08:05,040
Bunun n'ye n olduğunu
varsayacağım, yani 3'e 3, 4'e 4, her neyse.
2677
02:08:05,040 --> 02:08:07,820 Bu
yüzden sadece bu kare tuğlanın
boyutunu soracağım.
2678
02:08:07,820 --> 02:08:09,573
Şimdi bunu nasıl yapacağım?
2679
02:08:09,573 --> 02:08:11.990
Pekala, örneğin devam edeceğim
ve yazdıracağım-2680
02:08:11,990 --> 02:08:17,107 int i
= 0, i n'den küçük, i++ için ne
dersiniz?
2681
02:08:17,107 --> 02:08:19,190
Basit tutayım ve bir şeyler
yazdırayım
2682
02:08:19,190 --> 02:08:23,990
bunun gibi, sadece tuğla olan tek
bir kare sembolü,
2683
02:08:23.990 --> 02:08:26.000 ve
ondan sonra yeni bir satır.
2684
02:08:26.000 --> 02:08:27,470
Pekala, haydi mario yapalım.
2685
02:08:27,470 --> 02:08:29,600 3'lü
mario'yu çalıştırın.
2686

Machine Translated by Google
02:08:29,600 --> 02:08:31,520
Tamam, bu olmaya yakın.
2687
02:08:31,520 --> 02:08:32,630 Bir
sütunum var.
2688
02:08:32,630 --> 02:08:34,380 Pekala,
ama daha geniş olmasına ihtiyacım var.
2689
02:08:34,380 --> 02:08:36,950
Bu yüzden çözüm geçen
sefer yeni satırdan kurtulmaktı.
2690
02:08:36,950 --> 02:08:41,120 ve
sonra yeni satırı döngüden sonra
buraya koyabilirsiniz.
2691
02:08:41,120 --> 02:08:47,150 Pekâlâ,
hadi mario, ./mario yapalım ve 3
yazalım ve huh.
2692
02:08:47,150 --> 02:08:51,680 Pekâlâ,
bu yüzden bu iki fikri bir şekilde
birleştirmem gerekiyor.
2693
02:08:51,680 --> 02:08:55,550 Peki
bu sorunu nasıl çözebiliriz?
2694
02:08:55,550 --> 02:09:01,790 Satır
veya sütun değil, satır ve sütun
yazdırmak istiyorum.
2695
02:09:01,790 --> 02:09:03,320 Bunu
nasıl yaparım?
2696
02:09:03,320 --> 02:09:03,830 Evet.

2697
02:09:03,830 --> 02:09:06,215
İZLEYİCİ: for döngüsüne başka bir
döngü ekleyin.
2698
02:09:06,215 --> 02:09:07,090

Machine Translated by Google
DAVID J. MALAN: Evet.
2699
02:09:07,090 --> 02:09:08,770 for
döngüsüne başka bir döngü ekle, değil mi?
2700
02:09:08,770 --> 02:09:13.090
Üstten satırları saymak için
kavramsal olarak bir döngü kullanırsanız
2701
02:09:13,090 --> 02:09:15,670 en
alta ve sonra her satırda

2702
02:09:15,670 --> 02:09:18.070 bir
tür daktilo stili-- eski tarz daktilo--

2703
02:09:18,070 --> 02:09:21,220
beğen, karakter, karakter,
karakter, karakter yatay olarak,
2704
02:09:21,220 --> 02:09:23,720
Burada tam olarak istediğimiz
şeyi yapabileceğimizi düşünüyorum.
2705
02:09:23,720 --> 02:09:24,620 Peki
buna ne dersiniz?
2706
02:09:24,620 --> 02:09:27,640
Şimdilik bu hattan kurtulayım.

2707
02:09:27,640 --> 02:09:30,400 Ve
kendi kendime içeriden bir döngü
daha vereyim.
2708
02:09:30,400 --> 02:09:34,120
Ve zaten i kullandığım için başka
bir makul kural
2709
02:09:34,120 --> 02:09:36,220
burada j gibi bir şey söylemek olur.
2710

Machine Translated by Google
02:09:36,220 --> 02:09:40,510 Yani j
ayrıca 0 alır, j n'den küçüktür, j++.
2711
02:09:40,510 --> 02:09:42,820 Ve şimdi
ne olacak?
2712
02:09:42,820 --> 02:09:47,380 Devam
edeyim ve her seferinde bunlardan sadece
birini yazdırayım.
2713
02:09:47,380 --> 02:09:49,640 Ve bunu
kaydetmeme ve çalıştırmama izin ver.
2714
02:09:49,640 --> 02:09:51,190 Bakalım
ne kadar yakınız.
2715
02:09:51,190 --> 02:09:53,170 Mario 3
yapın.
2716
02:09:53,170 --> 02:09:57.620 Tamam,
üç, bu kesinlikle yanlış, ama orada ekranda
dokuz şey görüyorum.
2717
02:09:57,620 --> 02:09:58,780 Yani
yakınız.
2718
02:09:58,780 --> 02:10:04,090
Eski okul daktilo kafasını hareket ettirmek
için şimdi ihtiyacım olan tek düzeltme nedir?
2719
02:10:04,090 --> 02:10:06,400 uygun
olduğunda bir sonraki satıra mı geçilecek?
2720
02:10:06,400 --> 02:10:08,340 Ne
düşünüyorsun?
2721
02:10:08,340 --> 02:10:10.290 Evet, bu
ters eğik çizgilerden birine ihtiyacım var.
2722
02:10:10,290 --> 02:10:15,120 Ve şimdi
herkesin ne yaptığımı görselleştirmesine yardımcı
olmak için bazı yorumlar eklememe izin verin.

Machine Translated by Google
2723

02:10:15,120 --> 02:10:22,170
Her satır için, her sütun için bir
tuğla basmaya ne dersiniz?
2724
02:10:22,170 --> 02:10:24,300
sadece mantığı açıklamak için mi?
2725
02:10:24,300 --> 02:10:29,010
Ve bunu ekliyorum çünkü
şimdi bir sonraki satıra geçin,
2726
02:10:29,010 --> 02:10:31,590 Ters
eğik çizgi n ile böyle bir şey
yapabilirim.
2727
02:10:31,590 --> 02:10:34,950
İşte burada yorumlar, gerçekten,
benim sözde kodum
2728
02:10:34,950 --> 02:10:37,930
aslında durumu biraz aydınlatıyor.

2729
02:10:37,930 --> 02:10:42,553
Devam edip mario, ./mario 3'ü
yeniden derlememe izin verin, şimdi konuşuyoruz.
2730
02:10:42,553 --> 02:10:44,970
Bu tam kare değil, çünkü
bu karma semboller
2731
02:10:44,970 --> 02:10:48,750
genişliklerinden biraz daha uzunlar,
ama bu burada sadece bir yazı tipi detayı.
2732
02:10:48,750 --> 02:10:54,950 Şimdi
buna daha çok benzeyen bir şey yaptım.

2733
02:10:54,950 --> 02:10:59,443
Pekala, burada durup herhangi bir
soru olup olmadığına bakmama izin verin.
2734

Machine Translated by Google

02:10:59,443 --> 02:11:01,610

Yine, kod biraz daha
karmaşıklaşıyor,
2735
02:11:01,610 --> 02:11:05,315
ama biz sadece Scratch'taki gibi
daha karmaşık programlar oluşturuyoruz,
2736
02:11:05,315 --> 02:11:07,190
tanıdık yapboz parçalarıyla-- bazı
değişkenler,
2737
02:11:07,190 --> 02:11:08,540
bazı döngüler, bazı koşullar.
2738
02:11:08,540 --> 02:11:10,610 Her
şey eskisi gibi.
2739
02:11:10,610 --> 02:11:12,080
Evet.
2740
02:11:12,080 --> 02:11:13,340
C'deki dizeleri çoğaltabilir misiniz?
2741
02:11:13,340 --> 02:11:14,090
Hayır.
2742
02:11:14,090 --> 02:11:17,007
Ama aynı soruyu birkaç hafta sonra
Python'a geldiğimizde tekrar sorun,
2743
02:11:17,007 --> 02:11:18,973 ve
cevap evet olacak.
2744
02:11:18,973 --> 02:11:19,640
Diğer sorular.
2745
02:11:19,640 --> 02:11:21,080
Evet.
2746
02:11:21,080 --> 02:11:23,720
C'de dönüş türünü, adını
belirtmelisiniz.

Machine Translated by Google
2747
02:11:23,720 --> 02:11:25,780
işlevin girdileri veya bağımsız
değişkenleri,
2748
02:11:25,780 --> 02:11:27,030 bu
sırayla işleve.
2749
02:11:27,030 --> 02:11:30,380 Ve
bunların hiçbiri geçerli değilse, void
kelimesini yazarsınız.
2750
02:11:30,380 --> 02:11:33,260
Yani öncekiyle aynı soru, bir
hafta kadar tekme atmama izin ver,
2751
02:11:33,260 --> 02:11:35,460 ve
buna geri döneceğiz ve nedenini
göreceğiz.
2752
02:11:35,460 --> 02:11:38,480
Ama şimdilik, bunu main ile
yapmanız gerektiğine inanın.
2753
02:11:38,480 --> 02:11:40,850
Main biraz özel
olduğundan,
2754
02:11:40,850 --> 02:11:42,230
yeşil bayrak tıklandığında.
2755
02:11:42,230 --> 02:11:45,470 O
da biraz özeldi.
2756
02:11:45,470 --> 02:11:46,448
Evet
2757
02:11:46,448 --> 02:11:52,777
İZLEYİCİ: [DUYULMAZ]
2758
02:11:52,777 --> 02:11:53,610
DAVID J. MALAN: Evet.

Machine Translated by Google
2759

02:11:53,610 --> 02:11:57,160 Bir
döngüden erken çıkmak istiyorsanız
bunu yapabilirsiniz.
2760
02:11:57,160 --> 02:11:59,520 Bu
soruya şöyle cevap vereyim.
2761
02:11:59,520 --> 02:12:05,590 Do
while döngüsüne bir alternatif, bunun
gibi bir şey yapmak olabilir.
2762
02:12:05,590 --> 02:12:07,080
Peki ya doğruysa...
2763
02:12:07,080 --> 02:12:09,490 bu
yüzden sonsuza kadar şunu yapın-2764
02:12:09,490 --> 02:12:14,670
devam edip bu şeyin boyutu için
kullanıcıdan bir inç almama izin verin.
2765
02:12:14,670 --> 02:12:17,970
n 0'dan büyükse-2766
02:12:17,970 --> 02:12:19,810 yani
pozitif bir tam sayı-2767
02:12:19,810 --> 02:12:23,610 sonra
devam edin ve break adlı yeni bir
anahtar kelime kullanın.
2768
02:12:23,610 --> 02:12:26,890 Bu,
az önce yaptığımızla aynı.
2769
02:12:26,890 --> 02:12:28,330
Sadece biraz daha uzun.
2770
02:12:28,330 --> 02:12:30,870
Fazladan birkaç satır gibi, çoğu boş.

2771
02:12:30,870 --> 02:12:32,310

Machine Translated by Google
Ve bu yüzden sadece bir alternatif.
2772
02:12:32,310 --> 02:12:35,055
Ama do while aynı şeyi yapar ama
biraz daha sıkı-2773
02:12:35,055 --> 02:12:38,200 eğer
sorunuzun cevabı buysa.
2774
02:12:38,200 --> 02:12:42,633
Pekala, şimdi, nihayet, bir dizi
problemi tanıtalım.
2775
02:12:42,633 --> 02:12:44,550 halının
altına süpürdüğüm,

2776
02:12:44,550 --> 02:12:46,980 daha
önce bunun biraz kanıtını görmemize
rağmen
2777
02:12:46,980 --> 02:12:49.080 2
milyar 2 milyar eklemeye
çalıştığımızda,
2778
02:12:49.080 --> 02:12:53,380 ve
tabiri caizse bir int içindeki bit
sayısını aştı.
2779
02:12:53,380 --> 02:12:57,630 Devam
edip hesap makinesi adlı bir
programı yeniden kodlayayım.
2780
02:12:57,630 --> 02:13:00,420 Ama
şimdi devam edeceğim ve bunu
yüzer olarak değiştireceğim.
2781
02:13:00,420 --> 02:13:04,020 Yani
x'i bir kayan nokta ile değiştireceğim ve
get_float kullanacağım.
2782
02:13:04,020 --> 02:13:06,850
Ve bir şamandıra, yine, sadece
bir kayan nokta değeridir,

Machine Translated by Google
2783
02:13:06,850 --> 02:13:10,270 ki
bu, içinde ondalık nokta bulunan gerçek
bir sayıyı söylemenin süslü bir yoludur.
2784
02:13:10,270 --> 02:13:13,680 Ve
aşağıda, devam edeceğim ve
kayan nokta için %f kullanacağım.
2785
02:13:13,680 --> 02:13:16,050 Ve
şimdi devam edeceğim ve bir şey
daha yapacağım.
2786
02:13:16,050 --> 02:13:18,842
Eklemek yerine, bölme gibi daha
süslü bir şey yapmak istiyorum.
2787
02:13:18,842 --> 02:13:20,700 yani
x'i y'ye bölün.
2788
02:13:20,700 --> 02:13:23,250
Ve kendime z adında başka bir
üçüncü şamandıra vereceğim,
2789
02:13:23,250 --> 02:13:24,930
bugünün başında yaptığımız gibi.
2790
02:13:24,930 --> 02:13:28,530 Ve
x ve y yerine açıkça z yazdıracağım.

2791
02:13:28,530 --> 02:13:33,210
Şimdi devam edeceğim ve hesap
makinesi yapacağım, ./hesap makinesi.
2792
02:13:33,210 --> 02:13:35,520 Ve
hadi 2/3 gibi bir şey yapalım.
2793
02:13:35,520 --> 02:13:38,910
2'nin 3'e bölümü 0,66667'dir.
2794
02:13:38,910 --> 02:13:40,800 Yani
beklediğiniz şey bu.

Machine Translated by Google
2795
02:13:40,800 --> 02:13:43,510 Tekrar
çalıştırayım, 1/10.
2796
02:13:43,510 --> 02:13:45,700 Pekala,
yani 0.1 ve bir sürü sıfır.
2797
02:13:45,700 --> 02:13:47,720 Sizin de
beklediğiniz şey bu.

2798
02:13:47,720 --> 02:13:49,390 Ama
şimdi biraz merak etmeme izin verin.
2799
02:13:49,390 --> 02:13:53,470
Görünüşe göre C'de bu formatın
davranışını değiştirebilirsiniz.
2800
02:13:53,470 --> 02:13:54,430 biraz
kod.
2801
02:13:54,430 --> 02:13:56.590 Varsayılan
olarak, 6 ya da daha fazla rakam alırsınız.

2802
02:13:56,590 --> 02:13:59,050 Tam
olarak 2 basamak almak istediğinizi
varsayalım.
2803
02:13:59,050 --> 02:14:03,015 f'den
önce ve yüzdeden sonra 0.2'yi daha kısa
ve öz olarak söyleyebilirsiniz.
2804
02:14:03,015 --> 02:14:05,890
Bu, hatırlaması zor olan bir şey, ama
Google'da,
2805
02:14:05,890 --> 02:14:08,110 ve bunu
buluyorsunuz, tamam, kayan noktalar
için biçim kodu
2806
02:14:08,110 --> 02:14:10.730 iki
ondalık basamak yapmak için 0.2 kullanır.

Machine Translated by Google
2807

02:14:10,730 --> 02:14:14,260 O halde
tekrar hesap makinesi yapayım, ./hesap
makinesi.
2808
02:14:14,260 --> 02:14:15,610 Peki ya
2/3?
2809
02:14:15,610 --> 02:14:16,700 0,67.

2810
02:14:16,700 --> 02:14:19,690 Yani
burada bizim için önemli rakamların
gösterimini idare ediyor.
2811
02:14:19,690 --> 02:14:23,380 Şimdi
devam edip 1/10 ve 0.10 yapmama izin
verin.
2812
02:14:23,380 --> 02:14:24,693 Yani buna
bağlı kalıyor.
2813
02:14:24,693 --> 02:14:26,860 Belki
gerçekten çok fazla hassasiyet istiyorum,
değil mi?
2814
02:14:26,860 --> 02:14:28,360 Gerçekten
güçlü bir bilgisayarım var.
2815
02:14:28,360 --> 02:14:30,880 Ondalık
noktadan sonra 50 sayı göreyim.

2816
02:14:30,880 --> 02:14:32,750 Bu çok
sayıda anlamlı rakam.
2817
02:14:32,750 --> 02:14:35,540 Hesap
makinesini yeniden yapmama izin
verin-- Hata, yazım hatası.
2818
02:14:35,540 --> 02:14:40,180 İzin verin
hesap makinesini yeniden yapayım, ./
mario hesap makinesi.

Machine Translated by Google
2819

02:14:40,180 --> 02:14:42,930
Peki yine 2/3'e ne dersiniz?
2820
02:14:42,930 --> 02:14:45,600 Bu
ilginç.
2821
02:14:45,600 --> 02:14:49,590
Üzerinde bir çizgi olan 0,6 olması
gerekiyordu, değil mi?
2822
02:14:49,590 --> 02:14:50,730
İlkokul matematikte.
2823
02:14:50,730 --> 02:14:52,438
Pekala, peki, belki bu sadece bir
hatadır.
2824
02:14:52,438 --> 02:14:53,490
Peki ya 1/10?
2825
02:14:53,490 --> 02:14:56,250
Tamam, bu gerçekten tuhaflaşıyor.
2826
02:14:56,250 --> 02:14:57,600
Peki neler oluyor?
2827
02:14:57,600 --> 02:15:01,647
Görünüşe göre programım toplama
işlemini çok iyi yapamıyor-2828
02:15:01,647 --> 02:15:03,480
sonunda milyarlarca sorunla
karşılaştık-2829
02:15:03,480 --> 02:15:08,060
Burada çok kesin sayılar bile
yapamıyoruz.
2830
02:15:08,060 --> 02:15:10,520
Neler oluyor?
2831
02:15:10,520 --> 02:15:11,060

Machine Translated by Google
Aynen öyle.

2832
02:15:11,060 --> 02:15:13,400
Özetle, bilgisayar cevaba
yaklaşıyor
2833
02:15:13,400 --> 02:15:16,342
ondalık noktadan sonra bu kadar
çok sayı kullanarak.
2834
02:15:16,342 --> 02:15:18,050
Ama temelde
sorun aslında
2835
02:15:18,050 --> 02:15:21,300
öncekinden tamsayı taşmasına çok
benzer.
2836
02:15:21,300 --> 02:15:23.000 Ve
şimdi bunu bir sanat terimi olarak kullanıyorum.
2837
02:15:23.000 --> 02:15:27,410
Gerçekte sizden daha fazla bit kullanmaya
çalışıyorsanız, tamsayılar taşabilir
2838
02:15:27,410 --> 02:15:28,327 sizin
için hazır.
2839
02:15:28,327 --> 02:15:31,577
Hepsini bire çeviriyorsunuz ve sonra tabiri
caizse bitiyorsunuz.
2840
02:15:31,577 --> 02:15:33,960
Burada da aynı şey, ancak
farklı yüzen bağlamlarda-2841
02:15:33,960 --> 02:15:36,260
sadece 32 bitiniz varsa-- veya, heck,
eğer biz
2842
02:15:36,260 --> 02:15:39,920 ikiye
katlanır ve yalnızca 64 bit vardır, bu çok
fazla hassasiyet,

Machine Translated by Google
2843
02:15:39,920 --> 02:15:41,270
ama sonsuz değil.
2844
02:15:41,270 --> 02:15:45,270 Ve
yine de sonsuz sayıda gerçek
sayı olduğundan oldukça eminim.
2845
02:15:45,270 --> 02:15:50,240
Dünyada, yani sınırlı belleğe sahip bir
bilgisayar mümkün değildir.
2846
02:15:50,240 --> 02:15:52,613
dünyadaki tüm olası sayıları
temsil eder.
2847
02:15:52,613 --> 02:15:54,530
Çünkü, yine, sonsuz bir
sayı yoktur.
2848
02:15:54,530 --> 02:15:57,770 32
veya 64 bitlik permütasyonlar.
2849
02:15:57,770 --> 02:16:01,550
Milyarlarca veya daha fazla
olabilir ama yine de sonlu.
2850
02:16:01,550 --> 02:16:04,970
Ve böylece, gerçekten de,
bu, bilgisayarın en yakın yaklaşımıdır.
2851
02:16:04,970 --> 02:16:07,170
orada gerçekte neler olduğuna dair.
2852
02:16:07,170 --> 02:16:10,190
Ve bu aslında genel olarak
adlandırdığımız şeyin bir örneğidir.
2853
02:16:10,190 --> 02:16:12,200
kayan nokta belirsizliği.
2854
02:16:12,200 --> 02:16:17,540
Kayan nokta belirsizliği, temelde
bilgisayarların yetersizliğini ifade eder.

Machine Translated by Google
2855
02:16:17,540 --> 02:16:20.540 olası
tüm gerçek sayıları temsil etmek için
%100
2856
02:16:20.540 --> 02:16:24,317 tam
olarak, en azından varsayılan olarak
C gibi dillerde. Neyse ki,
2857
02:16:24,317 --> 02:16:26,400 bilimsel
hesaplama dünyasında vb.

2858
02:16:26,400 --> 02:16:30,020 Bu
sorunun size daha fazla rakam veren
çözümleri var.
2859
02:16:30,020 --> 02:16:33,270 Ama
temelde sorun hala orada olacak.

2860
02:16:33,270 --> 02:16:35,990 Yani x
ve y'yi yüzer olarak değiştirmemin
bir nedeni var.
2861
02:16:35,990 --> 02:16:38,250 Biraz
geriye sararsak ne olacağını görelim.

2862
02:16:38,250 --> 02:16:43,700 Ve x ve
y için kayan nokta kullanmak yerine yine
tamsayı diyorsunuz, yani int x ve y.
2863
02:16:43,700 --> 02:16:47,360
Ve çok geriye gidelim ve
get_int'i de kullanalım,
2864
02:16:47,360 --> 02:16:50,337 böylece
bize x ve y tam sayılarını verir.
2865
02:16:50,337 --> 02:16:52,920
Yine de z'yi bir kayan nokta
olarak bırakalım, çünkü günün sonunda,

Machine Translated by Google
2866
02:16:52,920 --> 02:16:55,640
kesirleri veya kayan nokta
değerlerini işleyebilmek istiyoruz.
2867
02:16:55,640 --> 02:16:58,580
Ama şimdi devam edelim ve
bu z değerini yazdıralım.
2868
02:16:58,580 --> 02:17:00,920 x
ve y'yi şimdi ints olarak değiştirdi.
2869
02:17:00,920 --> 02:17:06,590
hesap makinesi, ./hesap makinesi
yapın ve pay için diyelim ki 2 yapalım,
2870
02:17:06,590 --> 02:17:07,910 3
payda için.
2871
02:17:07,910 --> 02:17:13,160 Ve
0.666 değil ve garip bir şekilde
yuvarlanmıyor bile.
2872
02:17:13,160 --> 02:17:14,960 Bu
sefer sadece sıfırlar.
2873
02:17:14.960 --> 02:17:16.170
Peki neden böyle?
2874
02:17:16,170 --> 02:17:19,970
Görünen o ki, bir tamsayıyı bir
tamsayıya bölerken C,
2875
02:17:19,970 --> 02:17:22,970
size her zaman bir tamsayı, bir
int verecektir.
2876
02:17:22,970 --> 02:17:26,150
Sorun, kayan nokta değerlerinin
int'lere uymamasıdır.
2877
02:17:26,150 --> 02:17:28,850
Yalnızca ondalık noktanın
solundaki integral kısım yapar.

Machine Translated by Google
2878
02:17:28,850 --> 02:17:32,690
Ondalık noktasındaki ve ötesindeki her
şey atılır,
2879
02:17:32,690 --> 02:17:35,480 C'de
kesme adı verilen bir özellik olarak
bilinir.
2880
02:17:35,480 --> 02:17:38,790 Bir
tamsayıyı bir tamsayıya bölerken
bir tamsayı geri alırsınız.
2881
02:17:38,790 --> 02:17:42,380
Ancak, aslında kayan nokta olan
şeyi saklamaya çalışıyorsanız
2882
02:17:42,380 --> 02:17:45,830 bu
tamsayıyla sonuçlanır, C her şeyi
çöpe atacak
2883
02:17:45,830 --> 02:17:48,620
ondalık nokta ve ötesinde, bizi bu
durumda bırakarak,
2884
02:17:48,620 --> 02:17:54,720
0,666666 olması gerekenden
sadece 0'a kadar.
2885
02:17:54,720 --> 02:17:56,429
Aslında bir örnek daha görelim.
2886
02:17:56,429 --> 02:17:58,040
Buradaki terminalime geri döneyim.
2887
02:17:58,040 --> 02:17:59,750
Tekrar ./hesap makinesini yapayım.
2888
02:17:59,750 --> 02:18:00,950 Ve
4/3 yapalım.
2889
02:18:00,950 --> 02:18:04,950
Bu sefer olmalı

Machine Translated by Google
1.33333 ve benzeri.

2890
02:18:04,950 --> 02:18:11.929 Ama
bir bakalım, 4 bölü 3, her ikisi de
tamsayı olarak, bu sefer bize 1,0000 veriyor,
2891
02:18:11,929 --> 02:18:14,960 ama
orada da cevap 1.333 olmalı.

2892
02:18:14,960 --> 02:18:19,070
Ancak kayan nokta kısmı
kesiliyor veya atılıyor,
2893
02:18:19,070 --> 02:18:20,370 bize
sadece 1 tane kaldı.
2894
02:18:20,370 --> 02:18:21.570 Peki
bunu nasıl çözeceğiz?
2895
02:18:21.570 --> 02:18:25,170 Şey,
kesinlikle, benim yaptığım gibi, en
başından itibaren şamandıraları kullanabilirdik.

2896
02:18:25,170 --> 02:18:28,790
Ancak, programınızın doğası gereği,
yalnızca tamsayılara erişiminiz varsa-2897
02:18:28,790 --> 02:18:32,000 veya
hatta aynı sorunun ortaya çıkacağı
uzunlar-2898
02:18:32,000 --> 02:18:35,269
Aslında yapabileceğimiz şeye tür
dönüştürme denir.
2899
02:18:35,269 --> 02:18:38,240
Ve bilgisayara açıkça
söyleyebiliriz ki aslında
2900
02:18:38,240 --> 02:18:41.429 bu
int'ye bir kayan nokta değeriymiş
gibi davranmak istiyor.

Machine Translated by Google
2901

02:18:41.429 --> 02:18:43,220 Ve
bunu hem x hem de y için yapabiliriz.
2902
02:18:43,220 --> 02:18:47.070
Buradaki koduma geri dönmeme izin verin ve
aslında birkaç seçeneğim var.
2903
02:18:47,070 --> 02:18:52,460
Bunu yaparak y'yi bir şamandıraya
çevirebilirim, y'yi bir şamandıraya çevirebilirim

2904
02:18:52,460 --> 02:18:55,460
parantez içinde tam anlamıyla float
tipini yazarak
2905
02:18:55,460 --> 02:18:56,630 y'den
hemen önce.
2906
02:18:56,630 --> 02:19:00,080 Ve
eğer gerçekten açık olmak istersem,
aynısını x için de yapabilirim.
2907
02:19:00,080 --> 02:19:03,990
Ama kesin konuşmak gerekirse, birini
ya da diğerini değiştirmek yeterlidir,
2908
02:19:03,990 --> 02:19:05,269 her
ikisi de olmayabilir.
2909
02:19:05,269 --> 02:19:10,310 Şimdi
devam edeyim ve tekrar hesap makinesi
yapayım, ./hesap makinesi,
2910
02:19:10,310 --> 02:19:13,099 ve 2'yi
3'e bölmeyi deneyelim.
2911
02:19:13,099 --> 02:19:16,339 Ve
şimdi, düzeltmeye daha yakın olan
bir cevaba geri döndük.
2912
02:19:16,339 --> 02:19:19,040 Ama
gerçekten de hala bazı yuvarlama
sorunları yaşıyoruz.

Machine Translated by Google
2913
02:19:19,040 --> 02:19:22,820 4
bölü 3 için bir kez daha çalıştıralım.

2914
02:19:22,820 --> 02:19:25,189
Orada da en azından doğru
cevaba daha yakınız.
2915
02:19:25,189 --> 02:19:27,650
Ama hala o kayan nokta
belirsizliğine sahibiz,
2916
02:19:27,650 --> 02:19:30,500 ama
bu tamamen çözülmesi gereken
başka bir problem olacak.
2917
02:19:30,500 --> 02:19:32,420
Ve burada biraz daha
ayrıntılı olarak bu sorun

2918
02:19:32,420 --> 02:19:35,599 ints
bağlamındaki tamsayı taşması.

2919
02:19:35,599 --> 02:19:39,589
Üç bitimiz olduğunda geçen
haftayı düşündüğümüzü varsayalım,
2920
02:19:39,589 --> 02:19:45,170 ve
0'dan 7'ye kadar saydık, 0, 1, 2, 3,
4, 5, 6, 7.
2921
02:19:45,170 --> 02:19:47,420
Sanırım şu soruyu sordum, 8'e
kadar nasıl sayarız?
2922
02:19:47,420 --> 02:19:49,490 Biri
önerdi, peki, dördüncü bir parçaya
ihtiyacımız var.
2923
02:19:49,490 --> 02:19:52.759
Dördüncü bir bitiniz varsa,
erişiminiz varsa sorun değil.

Machine Translated by Google
2924
02:19:52.759 --> 02:19:54,679
başka bir ampule veya transistöre.
2925
02:19:54,679 --> 02:20:00,439
Bunu yapmazsanız, bundan sonraki sayı
teknik olarak 1000'dir.
2926
02:20:00,439 --> 02:20:04,310
Ancak bu dördüncü bit için yeriniz
veya donanımınız yoksa,
2927
02:20:04,310 --> 02:20:07,540
sadece 0 sayısını temsil ediyor
olabilirsiniz.
2928
02:20:07,540 --> 02:20:10.839
Yani tamsayılar dünyasında,
eğer sadece üç bit kullanıyorsanız,
2929
02:20:10,839 --> 02:20:14.560 7'yi
geçtiğinizde bu üç bit sonunda
taşar.
2930
02:20:14,560 --> 02:20:19,210
Çünkü 8 olması gereken, tabiri caizse
sığamaz, bu yüzden 0'a geri döner.
2931
02:20:19,210 --> 02:20:22,040
Ve bu sorun ne kadar
gizemli görünse de,
2932
02:20:22,040 --> 02:20:24,250 biz
insanlar bunu birkaç kez yaptık.

2933
02:20:24,250 --> 02:20:26,527
hakkında bilgi sahibi
olduğunuzu veya okuduğunuzu hatırlıyor olabilirsiniz.

2934
02:20:26,527 --> 02:20:28,360 Y2K
sorunu hakkında, birçok insan

Machine Translated by Google
2935

02:20:28,360 --> 02:20:29,660
dünyanın sonunun geleceğini düşünüyordu.
2936
02:20:29,660 --> 02:20:30,160
Neden?
2937
02:20:30,160 --> 02:20:35,110
Çünkü 1 Ocak 2000'de birçok
bilgisayar,
2938
02:20:35,110 --> 02:20:39,700
muhtemelen 1999'dan 2000 yılına kadar
saatlerini güncelleyeceklerdi.
2939
02:20:39,700 --> 02:20:43.030
Sorun şu ki, onlarca yıldır
verimlilik için biz insanlar
2940
02:20:43.030 --> 02:20:45,910
dürüstçe yılları dört basamaklı
olarak kaydetmeme alışkanlığı içindeydi.
2941
02:20:45,910 --> 02:20:46,432
Neden?
2942
02:20:46,432 --> 02:20:49,390
Çünkü bu, özellikle yüzyıllardan beri
boşa harcanacak çok fazla alan.
2943
02:20:49,390 --> 02:20:50.660 bu
kadar sık olmaz.
2944
02:20:50,660 --> 02:20:53,740
Bu yüzden birçok bilgisayar
sistemi, özellikle erken
2945
02:20:53,740 --> 02:20:56,980
donanım çok pahalıydı ve bellek
çok dardı,
2946
02:20:56,980 --> 02:20:59,589
herhangi bir yılın son iki basamağını
kaydetti.

Machine Translated by Google
2947
02:20:59,589 --> 02:21:05,470
Sorun, elbette, 1 Ocak 2000'de 99'un 100'e
yuvarlanmasıdır.
2948
02:21:05,470 --> 02:21:10.540 Ama
başka bir rakam için yeriniz yoksa
00'dır.
2949
02:21:10.540 --> 02:21:14.920
Ve kodunuz 19'luk bir önek varsayarsa, o
yıldan yola çıktık.
2950
02:21:14,920 --> 02:21:18.062 1999
1900 yılına geri dönelim.
2951
02:21:18,062 --> 02:21:20.770
Neyse ki, uzun lafın kısası, birçok
insan çok fazla kod yazdı.
2952
02:21:20.770 --> 02:21:24,080 birçok
eski dilde ve çoğunlukla bu sorunu
ortadan kaldırdı,
2953
02:21:24,080 --> 02:21:25,600 yani
dünyanın sonu gelmedi.
2954
02:21:25,600 --> 02:21:31,180
Dünyanın bir sonraki sonunun
gelebileceği tarih ise 19 Ocak 2038.
2955
02:21:31,180 --> 02:21:33,760
Şimdi, bu uzun bir süre
uzakta gibi gelebilir,
2956
02:21:33,760 --> 02:21:36,130 ama
bir noktada 2000 yılı da öyleydi.
2957
02:21:36,130 --> 02:21:42,550
2038'de günümüzün modern
bilgisayarlarında saatler neden tekrar kırılabilir?
2958
02:21:42,550 --> 02:21:43,420

Machine Translated by Google
düşünebilir misin?
2959
02:21:43,420 --> 02:21:45,222
İZLEYİCİ: [DUYULMAZ]
2960
02:21:45,222 --> 02:21:46,180
DAVID J. MALAN: Gerçekten.
2961
02:21:46,180 --> 02:21:48,350
Yani bu bir kaç saniyeyi ifade
ediyor.
2962
02:21:48,350 --> 02:21:51,760
Böylece, bilgisayarların
genellikle zamanı takip etme şeklinin
2963
02:21:51,760 --> 02:21:55,330
Çağdan bu yana geçen toplam
saniye sayısını mı sayıyorlar?
2964
02:21:55,330 --> 02:21:57,820 1
Ocak 1970 olarak tanımlanır.
2965
02:21:57,820 --> 02:21:58,420
Neden?
2966
02:21:58,420 --> 02:22:01,090
Saymaya başlamak için
sadece iyi bir yıldı,
2967
02:22:01,090 --> 02:22:03,080
bilgisayarlar gerçekten sahneye
çıktığında.
2968
02:22:03,080 --> 02:22:07,600
Ne yazık ki, çoğu bilgisayar saniye sayısını
saymak için 32 bit kullandı.
2969
02:22:07,600 --> 02:22:11.530 1
Ocak 1970'den bu yana, bunun
anlamı şudur:
2970
02:22:11,530 --> 02:22:14.410

Machine Translated by Google
sadece kabaca 2 milyar
saniyeye kadar sayabilir.
2971
02:22:14,410 --> 02:22:21,010 30 11'in
gerçekleştiği 2038'de 2 milyar saniye
olacak.
2972
02:22:21,010 --> 02:22:22,900
aşağıdaki gibi yuvarlanacak.
2973
02:22:22,900 --> 02:22:26,098
Bu sayı 2 milyar, ki bu
maksimum-2974
02:22:26,098 --> 02:22:28,640 çünkü
pozitif ve negatif sayıları temsil
ediyorsanız,
2975
02:22:28,640 --> 02:22:31,140 sadece
pozitif 2 milyara kadar sayabileceğinizi
hatırlayın
2976
02:22:31,140 --> 02:22:32,380 veya
eksi 2 milyar-2977
02:22:32,380 --> 02:22:33,580 şöyle
görünüyor.
2978
02:22:33,580 --> 02:22:35,620 Bu, ikili
sistemde kabaca 2 milyar sayısıdır.

2979
02:22:35,620 --> 02:22:38,240 Burada
hepsi bir sıfır yolu olan birler.

2980
02:22:38,240 --> 02:22:42,190
Eğer o 2 milyardan bir saniye
sonrasını sayarsam, ver ya da al-2981
02:22:42,190 --> 02:22:45,250 bu da
demek oluyor ki, tamam,
1 ekliyorum, 1-'i taşıyorum

Machine Translated by Google
2982

02:22:45,250 --> 02:22:48,490 9'ların
ondalık olarak 0 olması gibi.

2983
02:22:48,490 --> 02:22:52,360
Bu tür basit animasyonu
sürdürürsem ve 1'i taşımaya devam edersem,
2984
02:22:52,360 --> 02:22:56,650 1'i
taşıyor, 1'i taşıyor, 2 milyar saniye sonra 1'i
taşıyor, ver ya da al,
2985
02:22:56,650 --> 02:22:59,420
Bilgisayarın belleğinde bu numara
var.
2986
02:22:59,420 --> 02:23:02,980 Yani
hala 1 bit var ve bu tamamen solda
1'dir.
2987
02:23:02,980 --> 02:23:07,240
Ne yazık ki, bu parça
genellikle olumsuzluğu temsil eder,
2988
02:23:07,240 --> 02:23:11,920
burada ilk bit negatifse, bu onun geri
kalanının
2989
02:23:11,920 --> 02:23:13,480 bir
şekilde negatif bir sayıyı temsil ediyor.
2990
02:23:13,480 --> 02:23:14.530
Negatif 0 değil.
2991
02:23:14.530 --> 02:23:16.030 Daha
gösterişli bir temsil var.
2992
02:23:16,030 --> 02:23:19,000
Ama çok büyük, pozitif bir
sayı aniden
2993
02:23:19,000 --> 02:23:20.890 çok
büyük, negatif bir sayı olur.

Machine Translated by Google
2994
02:23:20.890 --> 02:23:23.870 Ve
bu sayı kabaca eksi 2 milyar.

2995
02:23:23,870 --> 02:23:26,740
Bu, o tarihte 2038'deki
bilgisayarlar anlamına gelir.

2996
02:23:26,740 --> 02:23:29,170
yanlışlıkla olduğunu düşünecek

2997
02:23:29,170 --> 02:23:34,810 o
zamandan beri 2 milyar saniye eksi oldu
1 Ocak 1970,
2998
02:23:34,810 --> 02:23:37,930
bilgisayarlar potansiyel olarak 1901 olduğunu düşünüyor.

2999
02:23:37,930 --> 02:23:42,190
Peki 2038 sorununun çözümü
belki de nedir?
3000
02:23:42,190 --> 02:23:44,800
Y2K, çünkü yıllardır iki rakam
kullanıyoruz.
3001
02:23:44,800 --> 02:23:46,360
Peki ya 2038?
3002
02:23:46,360 --> 02:23:47,170
Daha fazla bit.

3003
02:23:47,170 --> 02:23:51,790
Ve şükür ki, burada öğrenilen
derslerde biraz daha iyi oluyoruz,
3004
02:23:51,790 --> 02:23:54,520 ve
bilgisayarlar artık giderek 64 bit
kullanıyor.
3005
02:23:54,520 --> 02:23:56,915

Machine Translated by Google
Ve hepimiz tükenene kadar
çoktan gitmiş olacağız
3006
02:23:56,915 --> 02:23:59,290
saniyenin bu kadarı, yani bu başka
birinin sorunu
3007
02:23:59,290 --> 02:24:01,040 bundan
çok, çok uzun yıllar sonra.
3008
02:24:01,040 --> 02:24:02,973 Ama
bu gerçekten temel çözüm.

3009
02:24:02,973 --> 02:24:05,140
Sonlu bir şeye karşı koşuyorsan,
peki,
3010
02:24:05,140 --> 02:24:07,570 sadece
kutuyu daha fazla tekmeleyin ve
kendinize daha fazla parça verin.
3011
02:24:07,570 --> 02:24:09,910
Ve açıkçası, donanım bugünlerde çok
daha ucuz olduğu için,
3012
02:24:09,910 --> 02:24:12,400
bilgisayarlar çok daha hızlı, o kadar
da büyük bir şey değil
3013
02:24:12,400 --> 02:24:13,930 on
yıllar önce olabileceği gibi.
3014
02:24:13,930 --> 02:24:15,700 Ama
aslında çözüm bu.
3015
02:24:15,700 --> 02:24:18,490 Ancak
bu çok yaygın bağlamlarda ortaya çıkar.
3016
02:24:18,490 --> 02:24:23,320
Aslında, devam edip buraya pennies
adında çok hızlı bir program yazayım.
3017

Machine Translated by Google
02:24:23,320 --> 02:24:26,350
Doları ABD para biriminde kuruşa dönüştürmenin
sadece bir şey olduğunu düşünebilirsiniz.

3018
02:24:26,350 --> 02:24:28,930
basit olabilir ama izin verin
şunu yapayım.
3019
02:24:28,930 --> 02:24:32,530
pennies.c'de devam edip
cs50.h'yi dahil edeceğim.
3020
02:24:32,530 --> 02:24:39,470
Ve başlangıç noktam olarak
stdio.h, int main void'i ekleyeceğim.
3021
02:24:39,470 --> 02:24:41,600
Ve şimdi burada, bunu yapacağım.
3022
02:24:41,600 --> 02:24:43,570
Miktar adında bir
şamandıra alacağım ve ben
3023
02:24:43,570 --> 02:24:47,740
kullanıcıdan bir miktar dolar isteyecek,
yani bir dolar miktarı,
3024
02:24:47,740 --> 02:24:50,470
ve bunu miktar adlı bir
değişkende saklayacağım.
3025
02:24:50,470 --> 02:24:58,660
Sonra, diyelim ki, nasıl yapılacağını
yaparak bu miktarı peniye çevireceğim.
3026
02:24:58,660 --> 02:25:01,310
yaklaşık miktar çarpı 100?
3027
02:25:01,310 --> 02:25:07,480
Ve sonra devam edeceğim ve peni
sayısının %i olduğunu yazdıracağım-3028
02:25:07,480 --> 02:25:09,430
çünkü bu sadece bir

Machine Translated by Google
peni cinsinden tamsayı--

3029
02:25:09,430 --> 02:25:13,690 ters
eğik çizgi n, alıntı yapma, virgül,
pennies.
3030
02:25:13,690 --> 02:25:17,380
Pekala, eğer burada hata
yapmadıysam, bir kuruş yapayım.
3031
02:25:17,380 --> 02:25:19,000 ./
peni.
3032
02:25:19,000 --> 02:25:22,900
Diyelim ki 0,99 $, yani 0,99 var.
3033
02:25:22,900 --> 02:25:24,190 Bu
99 peni eder.
3034
02:25:24,190 --> 02:25:26,998
Diyelim ki 1,23 dolarım var.
3035
02:25:26,998 --> 02:25:27,790 Bu
oldukça iyi.
3036
02:25:27,790 --> 02:25:31,050
Diyelim ki 4,20 dolarım var.
3037
02:25:31,050 --> 02:25:32,510 Ha.

3038
02:25:32,510 --> 02:25:34,130 Bir
belirsizlik sorunu var.
3039
02:25:34,130 --> 02:25:36,440 Ve
bu o kadar da büyük bir miktar
değil.
3040
02:25:36,440 --> 02:25:40,502
Şimdi, eğer kasiyer size borcunuzdan bir
kuruş daha az verirse, önemli değil.
3041

Machine Translated by Google

02:25:40,502 --> 02:25:41,960 ama

bunun toplandığını hayal edebilirsiniz.
3042
02:25:41.960 --> 02:25:45,440
Bunun finansal sonuçlar için endişe verici
olduğunu hayal edebilirsiniz,
3043
02:25:45,440 --> 02:25:48,830
finansal işlemler, bilimsel ölçümler
ve benzerleri için.
3044
02:25:48,830 --> 02:25:51,060
Programım bunu bile kaldıramıyor.
3045
02:25:51,060 --> 02:25:53,180
Burada bazı çözümler var.
3046
02:25:53,180 --> 02:25:55,370
Ve görünüşe göre
gerçekten olan şey-3047
02:25:55,370 --> 02:25:59,930 %f
ile 0,50 veya daha fazla ondalık görmek
için herhangi bir şey kullanarak yazdırırsam
3048
02:25:59,930 --> 02:26:00,650 puan--

3049
02:26:00,650 --> 02:26:05,480
muhtemelen, bilgisayar tam olarak 4,20
doları temsil etmekte zorlanıyor.
3050
02:26:05,480 --> 02:26:11,960
Muhtemelen 4 dolar ve 19.9999
sent depoluyordur.
3051
02:26:11,960 --> 02:26:14,750 Yani
yakın, ama tam olarak orada değil.
3052
02:26:14,750 --> 02:26:19,280 Yani
en azından bunu yuvarlayarak
çözebilirdim, örneğin.
3053

Machine Translated by Google

02:26:19,280 --> 02:26:22,280 Ve
orada yuvarlak bir fonksiyon
olduğu ortaya çıktı.
3054
02:26:22,280 --> 02:26:25,040 Ve
matematik kütüphanesi denen bir
kütüphanede olduğu ortaya çıktı.
3055
02:26:25,040 --> 02:26:28,040
Bunu, çevrimiçi belgelere ve benzerlerine
bakarak anlarsınız,
3056
02:26:28,040 --> 02:26:29,150 size
işaret edeceğimiz gibi.
3057
02:26:29,150 --> 02:26:35,000 Ve
şimdi tekrar peni kazanır ve ./pennies
yaparsam, şimdi 4,20$ yapabilirim.
3058
02:26:35,000 --> 02:26:35,900 Ve
işte.
3059

02:26:35,900 --> 02:26:37,370 Şimdi
doğru.
3060
02:26:37,370 --> 02:26:40,730 Yani
en azından bu bağlamda çözülebilir
bir problem gibi görünüyor.
3061
02:26:40,730 --> 02:26:44,660 Ama
yine de kesinlikle dikkat etmem
gereken bir şey.
3062
02:26:44,660 --> 02:26:48,380
Ne yazık ki, yıllar içinde profesyonel,
tam zamanlı programcılar bile
3063
02:26:48,380 --> 02:26:51,272 bu
tür ayrıntılara özellikle dikkat
etmemiştir.
3064
02:26:51,272 --> 02:26:54,230
Ve bunun gibi bir sınıfta amaç
sadece size programlama öğretmek değildir.

Machine Translated by Google
3065
02:26:54,230 --> 02:26:57,750
ama size kaputun altında neler
olduğunu gerçekten öğretmek için, tabiri caizse,
3066
02:26:57,750 --> 02:27:00,800 böylece
verinin nasıl olduğu hakkında aşağıdan
yukarıya bir anlayışa sahip olursunuz.

3067
02:27:00,800 --> 02:27:03,180
temsil edilir, bilgisayarların onu
nasıl manipüle ettiği,
3068
02:27:03,180 --> 02:27:07,260
böylece bazı programların hata
veren tarafında değilsiniz.
3069
02:27:07,260 --> 02:27:10.560
Ve toplum olarak bu tür hatalara
maruz kalmamak için
3070
02:27:10.560 --> 02:27:11,060 da.

3071
02:27:11,060 --> 02:27:13,430 Ve
bu maalesef her zaman oluyor.

3072
02:27:13,430 --> 02:27:17,210
Bu, birkaç yıl önce ihtiyaç
duyulan bir Boeing uçağı.
3073
02:27:17,210 --> 02:27:20.820 her
248 günde bir yeniden başlatılacak.
3074
02:27:20.820 --> 02:27:21,320
Neden?
3075
02:27:21,320 --> 02:27:25,940
Çünkü bu Boeing uçak yazılımı, 32 bitlik
bir tam sayı sayma kullanıyordu.
3076
02:27:25,940 --> 02:27:28,190

Machine Translated by Google
bir şeyi veya başka bir şeyi
takip etmek için saniyenin onda biri

3077
02:27:28,190 --> 02:27:29,960
elektrik gücüyle ilgili.
3078
02:27:29,960 --> 02:27:34,670
Ve ne yazık ki, 248 gün boyunca uçak
sürekli hareket halindeyken-3079
02:27:34,670 --> 02:27:36,890
havayolunda
endüstri görünüşte değil
3080
02:27:36,890 --> 02:27:40,580
uçakları çalışır durumda tutmak için her
doların sayılması olağandışı
3081
02:27:40,580 --> 02:27:41.780
her zaman-3082
02:27:41.780 --> 02:27:45,710
32-bit sayı devrilir ve güç

3083
02:27:45,710 --> 02:27:48,800
sıralama nedeniyle bir yan etki
olarak uçakta kapanırdı
3084
02:27:48,800 --> 02:27:50.880
bu durumda tanımsız davranış.
3085
02:27:50,880 --> 02:27:54,140
Boeing'in o zamanki geçici çözümü,
görünüşe göre, esasen,
3086
02:27:54,140 --> 02:27:57,350
bir tür işletim sistemi stili, peki,
uçağınızı yeniden başlattınız mı?
3087
02:27:57,350 --> 02:28:01,040
Ve gerçek bir yazılım yaması
yayınlayana kadar bu gerçekten de çözümdü.

Machine Translated by Google
3088

02:28:01,040 --> 02:28:02,550 Bu
gerçekten önemli.
3089
02:28:02,550 --> 02:28:05,600
Ve ne kadar çok donanım taşırsak ve
toplum olarak o kadar çok
3090
02:28:05,600 --> 02:28:08,750 bu
tür cihazları kullanırsanız, bu
sorunlar ne kadar fazlaysa
3091
02:28:08,750 --> 02:28:11.630 yolun
aşağısında karşılaşacağız.
3092
02:28:11.630 --> 02:28:13.170 CS50
için bu kadar.
3093
02:28:13.170 --> 02:28:15.460 Bir
dahaki sefere görüşürüz.
3094
02:28:15,460 --> 02:28:50.000
[MÜZİK ÇALIYOR]

